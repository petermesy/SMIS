
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserSession
 * 
 */
export type UserSession = $Result.DefaultSelection<Prisma.$UserSessionPayload>
/**
 * Model AcademicYear
 * 
 */
export type AcademicYear = $Result.DefaultSelection<Prisma.$AcademicYearPayload>
/**
 * Model Semester
 * 
 */
export type Semester = $Result.DefaultSelection<Prisma.$SemesterPayload>
/**
 * Model ClassSection
 * 
 */
export type ClassSection = $Result.DefaultSelection<Prisma.$ClassSectionPayload>
/**
 * Model Grade
 * 
 */
export type Grade = $Result.DefaultSelection<Prisma.$GradePayload>
/**
 * Model Subject
 * 
 */
export type Subject = $Result.DefaultSelection<Prisma.$SubjectPayload>
/**
 * Model Class
 * 
 */
export type Class = $Result.DefaultSelection<Prisma.$ClassPayload>
/**
 * Model TeacherSubject
 * 
 */
export type TeacherSubject = $Result.DefaultSelection<Prisma.$TeacherSubjectPayload>
/**
 * Model StudentEnrollment
 * 
 */
export type StudentEnrollment = $Result.DefaultSelection<Prisma.$StudentEnrollmentPayload>
/**
 * Model ClassSchedule
 * 
 */
export type ClassSchedule = $Result.DefaultSelection<Prisma.$ClassSchedulePayload>
/**
 * Model AttendanceRecord
 * 
 */
export type AttendanceRecord = $Result.DefaultSelection<Prisma.$AttendanceRecordPayload>
/**
 * Model AttendanceSummary
 * 
 */
export type AttendanceSummary = $Result.DefaultSelection<Prisma.$AttendanceSummaryPayload>
/**
 * Model GradeCategory
 * 
 */
export type GradeCategory = $Result.DefaultSelection<Prisma.$GradeCategoryPayload>
/**
 * Model GradeEntry
 * 
 */
export type GradeEntry = $Result.DefaultSelection<Prisma.$GradeEntryPayload>
/**
 * Model GradeReport
 * 
 */
export type GradeReport = $Result.DefaultSelection<Prisma.$GradeReportPayload>
/**
 * Model Announcement
 * 
 */
export type Announcement = $Result.DefaultSelection<Prisma.$AnnouncementPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model DocumentPermission
 * 
 */
export type DocumentPermission = $Result.DefaultSelection<Prisma.$DocumentPermissionPayload>
/**
 * Model Exam
 * 
 */
export type Exam = $Result.DefaultSelection<Prisma.$ExamPayload>
/**
 * Model StudentRegistrationRequest
 * 
 */
export type StudentRegistrationRequest = $Result.DefaultSelection<Prisma.$StudentRegistrationRequestPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  ADMIN: 'ADMIN',
  TEACHER: 'TEACHER',
  STUDENT: 'STUDENT',
  PARENT: 'PARENT'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Status: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type Status = (typeof Status)[keyof typeof Status]


export const AttendanceStatus: {
  PRESENT: 'PRESENT',
  ABSENT: 'ABSENT',
  LATE: 'LATE',
  EXCUSED: 'EXCUSED'
};

export type AttendanceStatus = (typeof AttendanceStatus)[keyof typeof AttendanceStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type AttendanceStatus = $Enums.AttendanceStatus

export const AttendanceStatus: typeof $Enums.AttendanceStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSession`: Exposes CRUD operations for the **UserSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSessions
    * const userSessions = await prisma.userSession.findMany()
    * ```
    */
  get userSession(): Prisma.UserSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.academicYear`: Exposes CRUD operations for the **AcademicYear** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicYears
    * const academicYears = await prisma.academicYear.findMany()
    * ```
    */
  get academicYear(): Prisma.AcademicYearDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.semester`: Exposes CRUD operations for the **Semester** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Semesters
    * const semesters = await prisma.semester.findMany()
    * ```
    */
  get semester(): Prisma.SemesterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classSection`: Exposes CRUD operations for the **ClassSection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassSections
    * const classSections = await prisma.classSection.findMany()
    * ```
    */
  get classSection(): Prisma.ClassSectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.grade`: Exposes CRUD operations for the **Grade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grades
    * const grades = await prisma.grade.findMany()
    * ```
    */
  get grade(): Prisma.GradeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subject`: Exposes CRUD operations for the **Subject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subject.findMany()
    * ```
    */
  get subject(): Prisma.SubjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.class`: Exposes CRUD operations for the **Class** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.class.findMany()
    * ```
    */
  get class(): Prisma.ClassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teacherSubject`: Exposes CRUD operations for the **TeacherSubject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeacherSubjects
    * const teacherSubjects = await prisma.teacherSubject.findMany()
    * ```
    */
  get teacherSubject(): Prisma.TeacherSubjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentEnrollment`: Exposes CRUD operations for the **StudentEnrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentEnrollments
    * const studentEnrollments = await prisma.studentEnrollment.findMany()
    * ```
    */
  get studentEnrollment(): Prisma.StudentEnrollmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classSchedule`: Exposes CRUD operations for the **ClassSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassSchedules
    * const classSchedules = await prisma.classSchedule.findMany()
    * ```
    */
  get classSchedule(): Prisma.ClassScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendanceRecord`: Exposes CRUD operations for the **AttendanceRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceRecords
    * const attendanceRecords = await prisma.attendanceRecord.findMany()
    * ```
    */
  get attendanceRecord(): Prisma.AttendanceRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendanceSummary`: Exposes CRUD operations for the **AttendanceSummary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceSummaries
    * const attendanceSummaries = await prisma.attendanceSummary.findMany()
    * ```
    */
  get attendanceSummary(): Prisma.AttendanceSummaryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gradeCategory`: Exposes CRUD operations for the **GradeCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GradeCategories
    * const gradeCategories = await prisma.gradeCategory.findMany()
    * ```
    */
  get gradeCategory(): Prisma.GradeCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gradeEntry`: Exposes CRUD operations for the **GradeEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GradeEntries
    * const gradeEntries = await prisma.gradeEntry.findMany()
    * ```
    */
  get gradeEntry(): Prisma.GradeEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gradeReport`: Exposes CRUD operations for the **GradeReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GradeReports
    * const gradeReports = await prisma.gradeReport.findMany()
    * ```
    */
  get gradeReport(): Prisma.GradeReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.announcement`: Exposes CRUD operations for the **Announcement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Announcements
    * const announcements = await prisma.announcement.findMany()
    * ```
    */
  get announcement(): Prisma.AnnouncementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentPermission`: Exposes CRUD operations for the **DocumentPermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentPermissions
    * const documentPermissions = await prisma.documentPermission.findMany()
    * ```
    */
  get documentPermission(): Prisma.DocumentPermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exam`: Exposes CRUD operations for the **Exam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exams
    * const exams = await prisma.exam.findMany()
    * ```
    */
  get exam(): Prisma.ExamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentRegistrationRequest`: Exposes CRUD operations for the **StudentRegistrationRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentRegistrationRequests
    * const studentRegistrationRequests = await prisma.studentRegistrationRequest.findMany()
    * ```
    */
  get studentRegistrationRequest(): Prisma.StudentRegistrationRequestDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.1
   * Query Engine version: f40f79ec31188888a2e33acda0ecc8fd10a853a9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserSession: 'UserSession',
    AcademicYear: 'AcademicYear',
    Semester: 'Semester',
    ClassSection: 'ClassSection',
    Grade: 'Grade',
    Subject: 'Subject',
    Class: 'Class',
    TeacherSubject: 'TeacherSubject',
    StudentEnrollment: 'StudentEnrollment',
    ClassSchedule: 'ClassSchedule',
    AttendanceRecord: 'AttendanceRecord',
    AttendanceSummary: 'AttendanceSummary',
    GradeCategory: 'GradeCategory',
    GradeEntry: 'GradeEntry',
    GradeReport: 'GradeReport',
    Announcement: 'Announcement',
    Message: 'Message',
    Notification: 'Notification',
    Document: 'Document',
    DocumentPermission: 'DocumentPermission',
    Exam: 'Exam',
    StudentRegistrationRequest: 'StudentRegistrationRequest'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "userSession" | "academicYear" | "semester" | "classSection" | "grade" | "subject" | "class" | "teacherSubject" | "studentEnrollment" | "classSchedule" | "attendanceRecord" | "attendanceSummary" | "gradeCategory" | "gradeEntry" | "gradeReport" | "announcement" | "message" | "notification" | "document" | "documentPermission" | "exam" | "studentRegistrationRequest"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserSession: {
        payload: Prisma.$UserSessionPayload<ExtArgs>
        fields: Prisma.UserSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findFirst: {
            args: Prisma.UserSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findMany: {
            args: Prisma.UserSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          create: {
            args: Prisma.UserSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          createMany: {
            args: Prisma.UserSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          delete: {
            args: Prisma.UserSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          update: {
            args: Prisma.UserSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          deleteMany: {
            args: Prisma.UserSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          upsert: {
            args: Prisma.UserSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          aggregate: {
            args: Prisma.UserSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSession>
          }
          groupBy: {
            args: Prisma.UserSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSessionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSessionCountAggregateOutputType> | number
          }
        }
      }
      AcademicYear: {
        payload: Prisma.$AcademicYearPayload<ExtArgs>
        fields: Prisma.AcademicYearFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicYearFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicYearFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          findFirst: {
            args: Prisma.AcademicYearFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicYearFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          findMany: {
            args: Prisma.AcademicYearFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>[]
          }
          create: {
            args: Prisma.AcademicYearCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          createMany: {
            args: Prisma.AcademicYearCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AcademicYearCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>[]
          }
          delete: {
            args: Prisma.AcademicYearDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          update: {
            args: Prisma.AcademicYearUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          deleteMany: {
            args: Prisma.AcademicYearDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicYearUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AcademicYearUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>[]
          }
          upsert: {
            args: Prisma.AcademicYearUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          aggregate: {
            args: Prisma.AcademicYearAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcademicYear>
          }
          groupBy: {
            args: Prisma.AcademicYearGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcademicYearGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicYearCountArgs<ExtArgs>
            result: $Utils.Optional<AcademicYearCountAggregateOutputType> | number
          }
        }
      }
      Semester: {
        payload: Prisma.$SemesterPayload<ExtArgs>
        fields: Prisma.SemesterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SemesterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SemesterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterPayload>
          }
          findFirst: {
            args: Prisma.SemesterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SemesterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterPayload>
          }
          findMany: {
            args: Prisma.SemesterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterPayload>[]
          }
          create: {
            args: Prisma.SemesterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterPayload>
          }
          createMany: {
            args: Prisma.SemesterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SemesterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterPayload>[]
          }
          delete: {
            args: Prisma.SemesterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterPayload>
          }
          update: {
            args: Prisma.SemesterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterPayload>
          }
          deleteMany: {
            args: Prisma.SemesterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SemesterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SemesterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterPayload>[]
          }
          upsert: {
            args: Prisma.SemesterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterPayload>
          }
          aggregate: {
            args: Prisma.SemesterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSemester>
          }
          groupBy: {
            args: Prisma.SemesterGroupByArgs<ExtArgs>
            result: $Utils.Optional<SemesterGroupByOutputType>[]
          }
          count: {
            args: Prisma.SemesterCountArgs<ExtArgs>
            result: $Utils.Optional<SemesterCountAggregateOutputType> | number
          }
        }
      }
      ClassSection: {
        payload: Prisma.$ClassSectionPayload<ExtArgs>
        fields: Prisma.ClassSectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassSectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassSectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSectionPayload>
          }
          findFirst: {
            args: Prisma.ClassSectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassSectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSectionPayload>
          }
          findMany: {
            args: Prisma.ClassSectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSectionPayload>[]
          }
          create: {
            args: Prisma.ClassSectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSectionPayload>
          }
          createMany: {
            args: Prisma.ClassSectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassSectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSectionPayload>[]
          }
          delete: {
            args: Prisma.ClassSectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSectionPayload>
          }
          update: {
            args: Prisma.ClassSectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSectionPayload>
          }
          deleteMany: {
            args: Prisma.ClassSectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassSectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassSectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSectionPayload>[]
          }
          upsert: {
            args: Prisma.ClassSectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSectionPayload>
          }
          aggregate: {
            args: Prisma.ClassSectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassSection>
          }
          groupBy: {
            args: Prisma.ClassSectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassSectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassSectionCountArgs<ExtArgs>
            result: $Utils.Optional<ClassSectionCountAggregateOutputType> | number
          }
        }
      }
      Grade: {
        payload: Prisma.$GradePayload<ExtArgs>
        fields: Prisma.GradeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GradeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GradeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          findFirst: {
            args: Prisma.GradeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GradeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          findMany: {
            args: Prisma.GradeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>[]
          }
          create: {
            args: Prisma.GradeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          createMany: {
            args: Prisma.GradeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GradeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>[]
          }
          delete: {
            args: Prisma.GradeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          update: {
            args: Prisma.GradeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          deleteMany: {
            args: Prisma.GradeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GradeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GradeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>[]
          }
          upsert: {
            args: Prisma.GradeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          aggregate: {
            args: Prisma.GradeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGrade>
          }
          groupBy: {
            args: Prisma.GradeGroupByArgs<ExtArgs>
            result: $Utils.Optional<GradeGroupByOutputType>[]
          }
          count: {
            args: Prisma.GradeCountArgs<ExtArgs>
            result: $Utils.Optional<GradeCountAggregateOutputType> | number
          }
        }
      }
      Subject: {
        payload: Prisma.$SubjectPayload<ExtArgs>
        fields: Prisma.SubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findFirst: {
            args: Prisma.SubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findMany: {
            args: Prisma.SubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          create: {
            args: Prisma.SubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          createMany: {
            args: Prisma.SubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          delete: {
            args: Prisma.SubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          update: {
            args: Prisma.SubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          deleteMany: {
            args: Prisma.SubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          upsert: {
            args: Prisma.SubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          aggregate: {
            args: Prisma.SubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubject>
          }
          groupBy: {
            args: Prisma.SubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubjectCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectCountAggregateOutputType> | number
          }
        }
      }
      Class: {
        payload: Prisma.$ClassPayload<ExtArgs>
        fields: Prisma.ClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findFirst: {
            args: Prisma.ClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findMany: {
            args: Prisma.ClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          create: {
            args: Prisma.ClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          createMany: {
            args: Prisma.ClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          delete: {
            args: Prisma.ClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          update: {
            args: Prisma.ClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          deleteMany: {
            args: Prisma.ClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          upsert: {
            args: Prisma.ClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          aggregate: {
            args: Prisma.ClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass>
          }
          groupBy: {
            args: Prisma.ClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassCountArgs<ExtArgs>
            result: $Utils.Optional<ClassCountAggregateOutputType> | number
          }
        }
      }
      TeacherSubject: {
        payload: Prisma.$TeacherSubjectPayload<ExtArgs>
        fields: Prisma.TeacherSubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherSubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherSubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>
          }
          findFirst: {
            args: Prisma.TeacherSubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherSubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>
          }
          findMany: {
            args: Prisma.TeacherSubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>[]
          }
          create: {
            args: Prisma.TeacherSubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>
          }
          createMany: {
            args: Prisma.TeacherSubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeacherSubjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>[]
          }
          delete: {
            args: Prisma.TeacherSubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>
          }
          update: {
            args: Prisma.TeacherSubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>
          }
          deleteMany: {
            args: Prisma.TeacherSubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherSubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeacherSubjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>[]
          }
          upsert: {
            args: Prisma.TeacherSubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>
          }
          aggregate: {
            args: Prisma.TeacherSubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacherSubject>
          }
          groupBy: {
            args: Prisma.TeacherSubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherSubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherSubjectCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherSubjectCountAggregateOutputType> | number
          }
        }
      }
      StudentEnrollment: {
        payload: Prisma.$StudentEnrollmentPayload<ExtArgs>
        fields: Prisma.StudentEnrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentEnrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentEnrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload>
          }
          findFirst: {
            args: Prisma.StudentEnrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentEnrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload>
          }
          findMany: {
            args: Prisma.StudentEnrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload>[]
          }
          create: {
            args: Prisma.StudentEnrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload>
          }
          createMany: {
            args: Prisma.StudentEnrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentEnrollmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload>[]
          }
          delete: {
            args: Prisma.StudentEnrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload>
          }
          update: {
            args: Prisma.StudentEnrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload>
          }
          deleteMany: {
            args: Prisma.StudentEnrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentEnrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentEnrollmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload>[]
          }
          upsert: {
            args: Prisma.StudentEnrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrollmentPayload>
          }
          aggregate: {
            args: Prisma.StudentEnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentEnrollment>
          }
          groupBy: {
            args: Prisma.StudentEnrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentEnrollmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentEnrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentEnrollmentCountAggregateOutputType> | number
          }
        }
      }
      ClassSchedule: {
        payload: Prisma.$ClassSchedulePayload<ExtArgs>
        fields: Prisma.ClassScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSchedulePayload>
          }
          findFirst: {
            args: Prisma.ClassScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSchedulePayload>
          }
          findMany: {
            args: Prisma.ClassScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSchedulePayload>[]
          }
          create: {
            args: Prisma.ClassScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSchedulePayload>
          }
          createMany: {
            args: Prisma.ClassScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSchedulePayload>[]
          }
          delete: {
            args: Prisma.ClassScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSchedulePayload>
          }
          update: {
            args: Prisma.ClassScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSchedulePayload>
          }
          deleteMany: {
            args: Prisma.ClassScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSchedulePayload>[]
          }
          upsert: {
            args: Prisma.ClassScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSchedulePayload>
          }
          aggregate: {
            args: Prisma.ClassScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassSchedule>
          }
          groupBy: {
            args: Prisma.ClassScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<ClassScheduleCountAggregateOutputType> | number
          }
        }
      }
      AttendanceRecord: {
        payload: Prisma.$AttendanceRecordPayload<ExtArgs>
        fields: Prisma.AttendanceRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          findFirst: {
            args: Prisma.AttendanceRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          findMany: {
            args: Prisma.AttendanceRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>[]
          }
          create: {
            args: Prisma.AttendanceRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          createMany: {
            args: Prisma.AttendanceRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>[]
          }
          delete: {
            args: Prisma.AttendanceRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          update: {
            args: Prisma.AttendanceRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>[]
          }
          upsert: {
            args: Prisma.AttendanceRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          aggregate: {
            args: Prisma.AttendanceRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceRecord>
          }
          groupBy: {
            args: Prisma.AttendanceRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceRecordCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceRecordCountAggregateOutputType> | number
          }
        }
      }
      AttendanceSummary: {
        payload: Prisma.$AttendanceSummaryPayload<ExtArgs>
        fields: Prisma.AttendanceSummaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceSummaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceSummaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>
          }
          findFirst: {
            args: Prisma.AttendanceSummaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceSummaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>
          }
          findMany: {
            args: Prisma.AttendanceSummaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>[]
          }
          create: {
            args: Prisma.AttendanceSummaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>
          }
          createMany: {
            args: Prisma.AttendanceSummaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceSummaryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>[]
          }
          delete: {
            args: Prisma.AttendanceSummaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>
          }
          update: {
            args: Prisma.AttendanceSummaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceSummaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceSummaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceSummaryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>[]
          }
          upsert: {
            args: Prisma.AttendanceSummaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>
          }
          aggregate: {
            args: Prisma.AttendanceSummaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceSummary>
          }
          groupBy: {
            args: Prisma.AttendanceSummaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceSummaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceSummaryCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceSummaryCountAggregateOutputType> | number
          }
        }
      }
      GradeCategory: {
        payload: Prisma.$GradeCategoryPayload<ExtArgs>
        fields: Prisma.GradeCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GradeCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GradeCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeCategoryPayload>
          }
          findFirst: {
            args: Prisma.GradeCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GradeCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeCategoryPayload>
          }
          findMany: {
            args: Prisma.GradeCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeCategoryPayload>[]
          }
          create: {
            args: Prisma.GradeCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeCategoryPayload>
          }
          createMany: {
            args: Prisma.GradeCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GradeCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeCategoryPayload>[]
          }
          delete: {
            args: Prisma.GradeCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeCategoryPayload>
          }
          update: {
            args: Prisma.GradeCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeCategoryPayload>
          }
          deleteMany: {
            args: Prisma.GradeCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GradeCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GradeCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeCategoryPayload>[]
          }
          upsert: {
            args: Prisma.GradeCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeCategoryPayload>
          }
          aggregate: {
            args: Prisma.GradeCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGradeCategory>
          }
          groupBy: {
            args: Prisma.GradeCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<GradeCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.GradeCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<GradeCategoryCountAggregateOutputType> | number
          }
        }
      }
      GradeEntry: {
        payload: Prisma.$GradeEntryPayload<ExtArgs>
        fields: Prisma.GradeEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GradeEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GradeEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeEntryPayload>
          }
          findFirst: {
            args: Prisma.GradeEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GradeEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeEntryPayload>
          }
          findMany: {
            args: Prisma.GradeEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeEntryPayload>[]
          }
          create: {
            args: Prisma.GradeEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeEntryPayload>
          }
          createMany: {
            args: Prisma.GradeEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GradeEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeEntryPayload>[]
          }
          delete: {
            args: Prisma.GradeEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeEntryPayload>
          }
          update: {
            args: Prisma.GradeEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeEntryPayload>
          }
          deleteMany: {
            args: Prisma.GradeEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GradeEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GradeEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeEntryPayload>[]
          }
          upsert: {
            args: Prisma.GradeEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeEntryPayload>
          }
          aggregate: {
            args: Prisma.GradeEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGradeEntry>
          }
          groupBy: {
            args: Prisma.GradeEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<GradeEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.GradeEntryCountArgs<ExtArgs>
            result: $Utils.Optional<GradeEntryCountAggregateOutputType> | number
          }
        }
      }
      GradeReport: {
        payload: Prisma.$GradeReportPayload<ExtArgs>
        fields: Prisma.GradeReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GradeReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GradeReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeReportPayload>
          }
          findFirst: {
            args: Prisma.GradeReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GradeReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeReportPayload>
          }
          findMany: {
            args: Prisma.GradeReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeReportPayload>[]
          }
          create: {
            args: Prisma.GradeReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeReportPayload>
          }
          createMany: {
            args: Prisma.GradeReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GradeReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeReportPayload>[]
          }
          delete: {
            args: Prisma.GradeReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeReportPayload>
          }
          update: {
            args: Prisma.GradeReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeReportPayload>
          }
          deleteMany: {
            args: Prisma.GradeReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GradeReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GradeReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeReportPayload>[]
          }
          upsert: {
            args: Prisma.GradeReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeReportPayload>
          }
          aggregate: {
            args: Prisma.GradeReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGradeReport>
          }
          groupBy: {
            args: Prisma.GradeReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<GradeReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.GradeReportCountArgs<ExtArgs>
            result: $Utils.Optional<GradeReportCountAggregateOutputType> | number
          }
        }
      }
      Announcement: {
        payload: Prisma.$AnnouncementPayload<ExtArgs>
        fields: Prisma.AnnouncementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnnouncementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnnouncementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findFirst: {
            args: Prisma.AnnouncementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnnouncementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findMany: {
            args: Prisma.AnnouncementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          create: {
            args: Prisma.AnnouncementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          createMany: {
            args: Prisma.AnnouncementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnnouncementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          delete: {
            args: Prisma.AnnouncementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          update: {
            args: Prisma.AnnouncementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          deleteMany: {
            args: Prisma.AnnouncementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnnouncementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnnouncementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          upsert: {
            args: Prisma.AnnouncementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          aggregate: {
            args: Prisma.AnnouncementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnnouncement>
          }
          groupBy: {
            args: Prisma.AnnouncementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnnouncementCountArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      DocumentPermission: {
        payload: Prisma.$DocumentPermissionPayload<ExtArgs>
        fields: Prisma.DocumentPermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentPermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentPermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPermissionPayload>
          }
          findFirst: {
            args: Prisma.DocumentPermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentPermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPermissionPayload>
          }
          findMany: {
            args: Prisma.DocumentPermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPermissionPayload>[]
          }
          create: {
            args: Prisma.DocumentPermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPermissionPayload>
          }
          createMany: {
            args: Prisma.DocumentPermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentPermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPermissionPayload>[]
          }
          delete: {
            args: Prisma.DocumentPermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPermissionPayload>
          }
          update: {
            args: Prisma.DocumentPermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPermissionPayload>
          }
          deleteMany: {
            args: Prisma.DocumentPermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentPermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentPermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPermissionPayload>[]
          }
          upsert: {
            args: Prisma.DocumentPermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPermissionPayload>
          }
          aggregate: {
            args: Prisma.DocumentPermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentPermission>
          }
          groupBy: {
            args: Prisma.DocumentPermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentPermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentPermissionCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentPermissionCountAggregateOutputType> | number
          }
        }
      }
      Exam: {
        payload: Prisma.$ExamPayload<ExtArgs>
        fields: Prisma.ExamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findFirst: {
            args: Prisma.ExamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findMany: {
            args: Prisma.ExamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          create: {
            args: Prisma.ExamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          createMany: {
            args: Prisma.ExamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          delete: {
            args: Prisma.ExamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          update: {
            args: Prisma.ExamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          deleteMany: {
            args: Prisma.ExamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          upsert: {
            args: Prisma.ExamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          aggregate: {
            args: Prisma.ExamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExam>
          }
          groupBy: {
            args: Prisma.ExamGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamCountArgs<ExtArgs>
            result: $Utils.Optional<ExamCountAggregateOutputType> | number
          }
        }
      }
      StudentRegistrationRequest: {
        payload: Prisma.$StudentRegistrationRequestPayload<ExtArgs>
        fields: Prisma.StudentRegistrationRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentRegistrationRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRegistrationRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentRegistrationRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRegistrationRequestPayload>
          }
          findFirst: {
            args: Prisma.StudentRegistrationRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRegistrationRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentRegistrationRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRegistrationRequestPayload>
          }
          findMany: {
            args: Prisma.StudentRegistrationRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRegistrationRequestPayload>[]
          }
          create: {
            args: Prisma.StudentRegistrationRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRegistrationRequestPayload>
          }
          createMany: {
            args: Prisma.StudentRegistrationRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentRegistrationRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRegistrationRequestPayload>[]
          }
          delete: {
            args: Prisma.StudentRegistrationRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRegistrationRequestPayload>
          }
          update: {
            args: Prisma.StudentRegistrationRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRegistrationRequestPayload>
          }
          deleteMany: {
            args: Prisma.StudentRegistrationRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentRegistrationRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentRegistrationRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRegistrationRequestPayload>[]
          }
          upsert: {
            args: Prisma.StudentRegistrationRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentRegistrationRequestPayload>
          }
          aggregate: {
            args: Prisma.StudentRegistrationRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentRegistrationRequest>
          }
          groupBy: {
            args: Prisma.StudentRegistrationRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentRegistrationRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentRegistrationRequestCountArgs<ExtArgs>
            result: $Utils.Optional<StudentRegistrationRequestCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    userSession?: UserSessionOmit
    academicYear?: AcademicYearOmit
    semester?: SemesterOmit
    classSection?: ClassSectionOmit
    grade?: GradeOmit
    subject?: SubjectOmit
    class?: ClassOmit
    teacherSubject?: TeacherSubjectOmit
    studentEnrollment?: StudentEnrollmentOmit
    classSchedule?: ClassScheduleOmit
    attendanceRecord?: AttendanceRecordOmit
    attendanceSummary?: AttendanceSummaryOmit
    gradeCategory?: GradeCategoryOmit
    gradeEntry?: GradeEntryOmit
    gradeReport?: GradeReportOmit
    announcement?: AnnouncementOmit
    message?: MessageOmit
    notification?: NotificationOmit
    document?: DocumentOmit
    documentPermission?: DocumentPermissionOmit
    exam?: ExamOmit
    studentRegistrationRequest?: StudentRegistrationRequestOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    announcements: number
    messagesSent: number
    messagesReceived: number
    notifications: number
    documents: number
    documentPermissions: number
    teacherSubjects: number
    studentEnrollments: number
    classSchedules: number
    attendanceRecordsAsStudent: number
    attendanceRecordsMarked: number
    attendanceSummaries: number
    gradeEntriesAsStudent: number
    gradeEntriesCreated: number
    gradeReports: number
    registrationRequests: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    announcements?: boolean | UserCountOutputTypeCountAnnouncementsArgs
    messagesSent?: boolean | UserCountOutputTypeCountMessagesSentArgs
    messagesReceived?: boolean | UserCountOutputTypeCountMessagesReceivedArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    documents?: boolean | UserCountOutputTypeCountDocumentsArgs
    documentPermissions?: boolean | UserCountOutputTypeCountDocumentPermissionsArgs
    teacherSubjects?: boolean | UserCountOutputTypeCountTeacherSubjectsArgs
    studentEnrollments?: boolean | UserCountOutputTypeCountStudentEnrollmentsArgs
    classSchedules?: boolean | UserCountOutputTypeCountClassSchedulesArgs
    attendanceRecordsAsStudent?: boolean | UserCountOutputTypeCountAttendanceRecordsAsStudentArgs
    attendanceRecordsMarked?: boolean | UserCountOutputTypeCountAttendanceRecordsMarkedArgs
    attendanceSummaries?: boolean | UserCountOutputTypeCountAttendanceSummariesArgs
    gradeEntriesAsStudent?: boolean | UserCountOutputTypeCountGradeEntriesAsStudentArgs
    gradeEntriesCreated?: boolean | UserCountOutputTypeCountGradeEntriesCreatedArgs
    gradeReports?: boolean | UserCountOutputTypeCountGradeReportsArgs
    registrationRequests?: boolean | UserCountOutputTypeCountRegistrationRequestsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnnouncementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentPermissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeacherSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherSubjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStudentEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEnrollmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClassSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassScheduleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttendanceRecordsAsStudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceRecordWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttendanceRecordsMarkedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceRecordWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttendanceSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceSummaryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGradeEntriesAsStudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGradeEntriesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGradeReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRegistrationRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentRegistrationRequestWhereInput
  }


  /**
   * Count Type AcademicYearCountOutputType
   */

  export type AcademicYearCountOutputType = {
    semesters: number
    classes: number
    teacherSubjects: number
    studentEnrollments: number
    gradeEntries: number
  }

  export type AcademicYearCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    semesters?: boolean | AcademicYearCountOutputTypeCountSemestersArgs
    classes?: boolean | AcademicYearCountOutputTypeCountClassesArgs
    teacherSubjects?: boolean | AcademicYearCountOutputTypeCountTeacherSubjectsArgs
    studentEnrollments?: boolean | AcademicYearCountOutputTypeCountStudentEnrollmentsArgs
    gradeEntries?: boolean | AcademicYearCountOutputTypeCountGradeEntriesArgs
  }

  // Custom InputTypes
  /**
   * AcademicYearCountOutputType without action
   */
  export type AcademicYearCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYearCountOutputType
     */
    select?: AcademicYearCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AcademicYearCountOutputType without action
   */
  export type AcademicYearCountOutputTypeCountSemestersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SemesterWhereInput
  }

  /**
   * AcademicYearCountOutputType without action
   */
  export type AcademicYearCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }

  /**
   * AcademicYearCountOutputType without action
   */
  export type AcademicYearCountOutputTypeCountTeacherSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherSubjectWhereInput
  }

  /**
   * AcademicYearCountOutputType without action
   */
  export type AcademicYearCountOutputTypeCountStudentEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEnrollmentWhereInput
  }

  /**
   * AcademicYearCountOutputType without action
   */
  export type AcademicYearCountOutputTypeCountGradeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeEntryWhereInput
  }


  /**
   * Count Type SemesterCountOutputType
   */

  export type SemesterCountOutputType = {
    attendanceSummaries: number
    gradeReports: number
    gradeEntries: number
    studentEnrollments: number
    registrationRequests: number
  }

  export type SemesterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendanceSummaries?: boolean | SemesterCountOutputTypeCountAttendanceSummariesArgs
    gradeReports?: boolean | SemesterCountOutputTypeCountGradeReportsArgs
    gradeEntries?: boolean | SemesterCountOutputTypeCountGradeEntriesArgs
    studentEnrollments?: boolean | SemesterCountOutputTypeCountStudentEnrollmentsArgs
    registrationRequests?: boolean | SemesterCountOutputTypeCountRegistrationRequestsArgs
  }

  // Custom InputTypes
  /**
   * SemesterCountOutputType without action
   */
  export type SemesterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterCountOutputType
     */
    select?: SemesterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SemesterCountOutputType without action
   */
  export type SemesterCountOutputTypeCountAttendanceSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceSummaryWhereInput
  }

  /**
   * SemesterCountOutputType without action
   */
  export type SemesterCountOutputTypeCountGradeReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeReportWhereInput
  }

  /**
   * SemesterCountOutputType without action
   */
  export type SemesterCountOutputTypeCountGradeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeEntryWhereInput
  }

  /**
   * SemesterCountOutputType without action
   */
  export type SemesterCountOutputTypeCountStudentEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEnrollmentWhereInput
  }

  /**
   * SemesterCountOutputType without action
   */
  export type SemesterCountOutputTypeCountRegistrationRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentRegistrationRequestWhereInput
  }


  /**
   * Count Type ClassSectionCountOutputType
   */

  export type ClassSectionCountOutputType = {
    classes: number
  }

  export type ClassSectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | ClassSectionCountOutputTypeCountClassesArgs
  }

  // Custom InputTypes
  /**
   * ClassSectionCountOutputType without action
   */
  export type ClassSectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSectionCountOutputType
     */
    select?: ClassSectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassSectionCountOutputType without action
   */
  export type ClassSectionCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }


  /**
   * Count Type GradeCountOutputType
   */

  export type GradeCountOutputType = {
    classSections: number
    subjects: number
    classes: number
  }

  export type GradeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classSections?: boolean | GradeCountOutputTypeCountClassSectionsArgs
    subjects?: boolean | GradeCountOutputTypeCountSubjectsArgs
    classes?: boolean | GradeCountOutputTypeCountClassesArgs
  }

  // Custom InputTypes
  /**
   * GradeCountOutputType without action
   */
  export type GradeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeCountOutputType
     */
    select?: GradeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GradeCountOutputType without action
   */
  export type GradeCountOutputTypeCountClassSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassSectionWhereInput
  }

  /**
   * GradeCountOutputType without action
   */
  export type GradeCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * GradeCountOutputType without action
   */
  export type GradeCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }


  /**
   * Count Type SubjectCountOutputType
   */

  export type SubjectCountOutputType = {
    teacherSubjects: number
    classSchedules: number
    gradeCategories: number
    gradeEntries: number
    attendanceRecords: number
    documents: number
    attendanceSummaries: number
  }

  export type SubjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacherSubjects?: boolean | SubjectCountOutputTypeCountTeacherSubjectsArgs
    classSchedules?: boolean | SubjectCountOutputTypeCountClassSchedulesArgs
    gradeCategories?: boolean | SubjectCountOutputTypeCountGradeCategoriesArgs
    gradeEntries?: boolean | SubjectCountOutputTypeCountGradeEntriesArgs
    attendanceRecords?: boolean | SubjectCountOutputTypeCountAttendanceRecordsArgs
    documents?: boolean | SubjectCountOutputTypeCountDocumentsArgs
    attendanceSummaries?: boolean | SubjectCountOutputTypeCountAttendanceSummariesArgs
  }

  // Custom InputTypes
  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectCountOutputType
     */
    select?: SubjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountTeacherSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherSubjectWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountClassSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassScheduleWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountGradeCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeCategoryWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountGradeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeEntryWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountAttendanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceRecordWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountAttendanceSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceSummaryWhereInput
  }


  /**
   * Count Type ClassCountOutputType
   */

  export type ClassCountOutputType = {
    teacherSubjects: number
    studentEnrollments: number
    classSchedules: number
    attendanceRecords: number
    documents: number
    gradeCategories: number
    gradeEntries: number
  }

  export type ClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacherSubjects?: boolean | ClassCountOutputTypeCountTeacherSubjectsArgs
    studentEnrollments?: boolean | ClassCountOutputTypeCountStudentEnrollmentsArgs
    classSchedules?: boolean | ClassCountOutputTypeCountClassSchedulesArgs
    attendanceRecords?: boolean | ClassCountOutputTypeCountAttendanceRecordsArgs
    documents?: boolean | ClassCountOutputTypeCountDocumentsArgs
    gradeCategories?: boolean | ClassCountOutputTypeCountGradeCategoriesArgs
    gradeEntries?: boolean | ClassCountOutputTypeCountGradeEntriesArgs
  }

  // Custom InputTypes
  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCountOutputType
     */
    select?: ClassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountTeacherSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherSubjectWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountStudentEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEnrollmentWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountClassSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassScheduleWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountAttendanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceRecordWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountGradeCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeCategoryWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountGradeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeEntryWhereInput
  }


  /**
   * Count Type GradeCategoryCountOutputType
   */

  export type GradeCategoryCountOutputType = {
    gradeEntries: number
  }

  export type GradeCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gradeEntries?: boolean | GradeCategoryCountOutputTypeCountGradeEntriesArgs
  }

  // Custom InputTypes
  /**
   * GradeCategoryCountOutputType without action
   */
  export type GradeCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeCategoryCountOutputType
     */
    select?: GradeCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GradeCategoryCountOutputType without action
   */
  export type GradeCategoryCountOutputTypeCountGradeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeEntryWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    childMessages: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    childMessages?: boolean | MessageCountOutputTypeCountChildMessagesArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountChildMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type DocumentCountOutputType
   */

  export type DocumentCountOutputType = {
    permissions: number
  }

  export type DocumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | DocumentCountOutputTypeCountPermissionsArgs
  }

  // Custom InputTypes
  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentCountOutputType
     */
    select?: DocumentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentPermissionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    gender: string | null
    role: $Enums.Role | null
    phone: string | null
    address: string | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    gender: string | null
    role: $Enums.Role | null
    phone: string | null
    address: string | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    firstName: number
    lastName: number
    gender: number
    role: number
    phone: number
    address: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    gender?: true
    role?: true
    phone?: true
    address?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    gender?: true
    role?: true
    phone?: true
    address?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    gender?: true
    role?: true
    phone?: true
    address?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender: string | null
    role: $Enums.Role
    phone: string | null
    address: string | null
    status: $Enums.Status
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    gender?: boolean
    role?: boolean
    phone?: boolean
    address?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    announcements?: boolean | User$announcementsArgs<ExtArgs>
    messagesSent?: boolean | User$messagesSentArgs<ExtArgs>
    messagesReceived?: boolean | User$messagesReceivedArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    documentPermissions?: boolean | User$documentPermissionsArgs<ExtArgs>
    teacherSubjects?: boolean | User$teacherSubjectsArgs<ExtArgs>
    studentEnrollments?: boolean | User$studentEnrollmentsArgs<ExtArgs>
    classSchedules?: boolean | User$classSchedulesArgs<ExtArgs>
    attendanceRecordsAsStudent?: boolean | User$attendanceRecordsAsStudentArgs<ExtArgs>
    attendanceRecordsMarked?: boolean | User$attendanceRecordsMarkedArgs<ExtArgs>
    attendanceSummaries?: boolean | User$attendanceSummariesArgs<ExtArgs>
    gradeEntriesAsStudent?: boolean | User$gradeEntriesAsStudentArgs<ExtArgs>
    gradeEntriesCreated?: boolean | User$gradeEntriesCreatedArgs<ExtArgs>
    gradeReports?: boolean | User$gradeReportsArgs<ExtArgs>
    registrationRequests?: boolean | User$registrationRequestsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    gender?: boolean
    role?: boolean
    phone?: boolean
    address?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    gender?: boolean
    role?: boolean
    phone?: boolean
    address?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    gender?: boolean
    role?: boolean
    phone?: boolean
    address?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "passwordHash" | "firstName" | "lastName" | "gender" | "role" | "phone" | "address" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    announcements?: boolean | User$announcementsArgs<ExtArgs>
    messagesSent?: boolean | User$messagesSentArgs<ExtArgs>
    messagesReceived?: boolean | User$messagesReceivedArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    documentPermissions?: boolean | User$documentPermissionsArgs<ExtArgs>
    teacherSubjects?: boolean | User$teacherSubjectsArgs<ExtArgs>
    studentEnrollments?: boolean | User$studentEnrollmentsArgs<ExtArgs>
    classSchedules?: boolean | User$classSchedulesArgs<ExtArgs>
    attendanceRecordsAsStudent?: boolean | User$attendanceRecordsAsStudentArgs<ExtArgs>
    attendanceRecordsMarked?: boolean | User$attendanceRecordsMarkedArgs<ExtArgs>
    attendanceSummaries?: boolean | User$attendanceSummariesArgs<ExtArgs>
    gradeEntriesAsStudent?: boolean | User$gradeEntriesAsStudentArgs<ExtArgs>
    gradeEntriesCreated?: boolean | User$gradeEntriesCreatedArgs<ExtArgs>
    gradeReports?: boolean | User$gradeReportsArgs<ExtArgs>
    registrationRequests?: boolean | User$registrationRequestsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$UserSessionPayload<ExtArgs>[]
      announcements: Prisma.$AnnouncementPayload<ExtArgs>[]
      messagesSent: Prisma.$MessagePayload<ExtArgs>[]
      messagesReceived: Prisma.$MessagePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      documentPermissions: Prisma.$DocumentPermissionPayload<ExtArgs>[]
      teacherSubjects: Prisma.$TeacherSubjectPayload<ExtArgs>[]
      studentEnrollments: Prisma.$StudentEnrollmentPayload<ExtArgs>[]
      classSchedules: Prisma.$ClassSchedulePayload<ExtArgs>[]
      attendanceRecordsAsStudent: Prisma.$AttendanceRecordPayload<ExtArgs>[]
      attendanceRecordsMarked: Prisma.$AttendanceRecordPayload<ExtArgs>[]
      attendanceSummaries: Prisma.$AttendanceSummaryPayload<ExtArgs>[]
      gradeEntriesAsStudent: Prisma.$GradeEntryPayload<ExtArgs>[]
      gradeEntriesCreated: Prisma.$GradeEntryPayload<ExtArgs>[]
      gradeReports: Prisma.$GradeReportPayload<ExtArgs>[]
      registrationRequests: Prisma.$StudentRegistrationRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      firstName: string
      lastName: string
      gender: string | null
      role: $Enums.Role
      phone: string | null
      address: string | null
      status: $Enums.Status
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    announcements<T extends User$announcementsArgs<ExtArgs> = {}>(args?: Subset<T, User$announcementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messagesSent<T extends User$messagesSentArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messagesReceived<T extends User$messagesReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends User$documentsArgs<ExtArgs> = {}>(args?: Subset<T, User$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documentPermissions<T extends User$documentPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$documentPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teacherSubjects<T extends User$teacherSubjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$teacherSubjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentEnrollments<T extends User$studentEnrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$studentEnrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classSchedules<T extends User$classSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, User$classSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendanceRecordsAsStudent<T extends User$attendanceRecordsAsStudentArgs<ExtArgs> = {}>(args?: Subset<T, User$attendanceRecordsAsStudentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendanceRecordsMarked<T extends User$attendanceRecordsMarkedArgs<ExtArgs> = {}>(args?: Subset<T, User$attendanceRecordsMarkedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendanceSummaries<T extends User$attendanceSummariesArgs<ExtArgs> = {}>(args?: Subset<T, User$attendanceSummariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gradeEntriesAsStudent<T extends User$gradeEntriesAsStudentArgs<ExtArgs> = {}>(args?: Subset<T, User$gradeEntriesAsStudentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradeEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gradeEntriesCreated<T extends User$gradeEntriesCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$gradeEntriesCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradeEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gradeReports<T extends User$gradeReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$gradeReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradeReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    registrationRequests<T extends User$registrationRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$registrationRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentRegistrationRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly gender: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly phone: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'Status'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    cursor?: UserSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * User.announcements
   */
  export type User$announcementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    cursor?: AnnouncementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * User.messagesSent
   */
  export type User$messagesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.messagesReceived
   */
  export type User$messagesReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.documents
   */
  export type User$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * User.documentPermissions
   */
  export type User$documentPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPermission
     */
    select?: DocumentPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPermission
     */
    omit?: DocumentPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPermissionInclude<ExtArgs> | null
    where?: DocumentPermissionWhereInput
    orderBy?: DocumentPermissionOrderByWithRelationInput | DocumentPermissionOrderByWithRelationInput[]
    cursor?: DocumentPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentPermissionScalarFieldEnum | DocumentPermissionScalarFieldEnum[]
  }

  /**
   * User.teacherSubjects
   */
  export type User$teacherSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherSubject
     */
    omit?: TeacherSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    where?: TeacherSubjectWhereInput
    orderBy?: TeacherSubjectOrderByWithRelationInput | TeacherSubjectOrderByWithRelationInput[]
    cursor?: TeacherSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherSubjectScalarFieldEnum | TeacherSubjectScalarFieldEnum[]
  }

  /**
   * User.studentEnrollments
   */
  export type User$studentEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    where?: StudentEnrollmentWhereInput
    orderBy?: StudentEnrollmentOrderByWithRelationInput | StudentEnrollmentOrderByWithRelationInput[]
    cursor?: StudentEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentEnrollmentScalarFieldEnum | StudentEnrollmentScalarFieldEnum[]
  }

  /**
   * User.classSchedules
   */
  export type User$classSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSchedule
     */
    omit?: ClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleInclude<ExtArgs> | null
    where?: ClassScheduleWhereInput
    orderBy?: ClassScheduleOrderByWithRelationInput | ClassScheduleOrderByWithRelationInput[]
    cursor?: ClassScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScheduleScalarFieldEnum | ClassScheduleScalarFieldEnum[]
  }

  /**
   * User.attendanceRecordsAsStudent
   */
  export type User$attendanceRecordsAsStudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    where?: AttendanceRecordWhereInput
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    cursor?: AttendanceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * User.attendanceRecordsMarked
   */
  export type User$attendanceRecordsMarkedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    where?: AttendanceRecordWhereInput
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    cursor?: AttendanceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * User.attendanceSummaries
   */
  export type User$attendanceSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    where?: AttendanceSummaryWhereInput
    orderBy?: AttendanceSummaryOrderByWithRelationInput | AttendanceSummaryOrderByWithRelationInput[]
    cursor?: AttendanceSummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceSummaryScalarFieldEnum | AttendanceSummaryScalarFieldEnum[]
  }

  /**
   * User.gradeEntriesAsStudent
   */
  export type User$gradeEntriesAsStudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeEntry
     */
    select?: GradeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeEntry
     */
    omit?: GradeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeEntryInclude<ExtArgs> | null
    where?: GradeEntryWhereInput
    orderBy?: GradeEntryOrderByWithRelationInput | GradeEntryOrderByWithRelationInput[]
    cursor?: GradeEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeEntryScalarFieldEnum | GradeEntryScalarFieldEnum[]
  }

  /**
   * User.gradeEntriesCreated
   */
  export type User$gradeEntriesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeEntry
     */
    select?: GradeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeEntry
     */
    omit?: GradeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeEntryInclude<ExtArgs> | null
    where?: GradeEntryWhereInput
    orderBy?: GradeEntryOrderByWithRelationInput | GradeEntryOrderByWithRelationInput[]
    cursor?: GradeEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeEntryScalarFieldEnum | GradeEntryScalarFieldEnum[]
  }

  /**
   * User.gradeReports
   */
  export type User$gradeReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeReport
     */
    select?: GradeReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeReport
     */
    omit?: GradeReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeReportInclude<ExtArgs> | null
    where?: GradeReportWhereInput
    orderBy?: GradeReportOrderByWithRelationInput | GradeReportOrderByWithRelationInput[]
    cursor?: GradeReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeReportScalarFieldEnum | GradeReportScalarFieldEnum[]
  }

  /**
   * User.registrationRequests
   */
  export type User$registrationRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRegistrationRequest
     */
    select?: StudentRegistrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentRegistrationRequest
     */
    omit?: StudentRegistrationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRegistrationRequestInclude<ExtArgs> | null
    where?: StudentRegistrationRequestWhereInput
    orderBy?: StudentRegistrationRequestOrderByWithRelationInput | StudentRegistrationRequestOrderByWithRelationInput[]
    cursor?: StudentRegistrationRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentRegistrationRequestScalarFieldEnum | StudentRegistrationRequestScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserSession
   */

  export type AggregateUserSession = {
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  export type UserSessionMinAggregateOutputType = {
    sessionId: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type UserSessionMaxAggregateOutputType = {
    sessionId: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type UserSessionCountAggregateOutputType = {
    sessionId: number
    userId: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type UserSessionMinAggregateInputType = {
    sessionId?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
  }

  export type UserSessionMaxAggregateInputType = {
    sessionId?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
  }

  export type UserSessionCountAggregateInputType = {
    sessionId?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type UserSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSession to aggregate.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSessions
    **/
    _count?: true | UserSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSessionMaxAggregateInputType
  }

  export type GetUserSessionAggregateType<T extends UserSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSession[P]>
      : GetScalarType<T[P], AggregateUserSession[P]>
  }




  export type UserSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithAggregationInput | UserSessionOrderByWithAggregationInput[]
    by: UserSessionScalarFieldEnum[] | UserSessionScalarFieldEnum
    having?: UserSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSessionCountAggregateInputType | true
    _min?: UserSessionMinAggregateInputType
    _max?: UserSessionMaxAggregateInputType
  }

  export type UserSessionGroupByOutputType = {
    sessionId: string
    userId: string
    expiresAt: Date
    createdAt: Date
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  type GetUserSessionGroupByPayload<T extends UserSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
        }
      >
    >


  export type UserSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectScalar = {
    sessionId?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type UserSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sessionId" | "userId" | "expiresAt" | "createdAt", ExtArgs["result"]["userSession"]>
  export type UserSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      sessionId: string
      userId: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["userSession"]>
    composites: {}
  }

  type UserSessionGetPayload<S extends boolean | null | undefined | UserSessionDefaultArgs> = $Result.GetResult<Prisma.$UserSessionPayload, S>

  type UserSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSessionCountAggregateInputType | true
    }

  export interface UserSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSession'], meta: { name: 'UserSession' } }
    /**
     * Find zero or one UserSession that matches the filter.
     * @param {UserSessionFindUniqueArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSessionFindUniqueArgs>(args: SelectSubset<T, UserSessionFindUniqueArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSessionFindUniqueOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSessionFindFirstArgs>(args?: SelectSubset<T, UserSessionFindFirstArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSessions
     * const userSessions = await prisma.userSession.findMany()
     * 
     * // Get first 10 UserSessions
     * const userSessions = await prisma.userSession.findMany({ take: 10 })
     * 
     * // Only select the `sessionId`
     * const userSessionWithSessionIdOnly = await prisma.userSession.findMany({ select: { sessionId: true } })
     * 
     */
    findMany<T extends UserSessionFindManyArgs>(args?: SelectSubset<T, UserSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSession.
     * @param {UserSessionCreateArgs} args - Arguments to create a UserSession.
     * @example
     * // Create one UserSession
     * const UserSession = await prisma.userSession.create({
     *   data: {
     *     // ... data to create a UserSession
     *   }
     * })
     * 
     */
    create<T extends UserSessionCreateArgs>(args: SelectSubset<T, UserSessionCreateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSessions.
     * @param {UserSessionCreateManyArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSessionCreateManyArgs>(args?: SelectSubset<T, UserSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSessions and returns the data saved in the database.
     * @param {UserSessionCreateManyAndReturnArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSessions and only return the `sessionId`
     * const userSessionWithSessionIdOnly = await prisma.userSession.createManyAndReturn({
     *   select: { sessionId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSession.
     * @param {UserSessionDeleteArgs} args - Arguments to delete one UserSession.
     * @example
     * // Delete one UserSession
     * const UserSession = await prisma.userSession.delete({
     *   where: {
     *     // ... filter to delete one UserSession
     *   }
     * })
     * 
     */
    delete<T extends UserSessionDeleteArgs>(args: SelectSubset<T, UserSessionDeleteArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSession.
     * @param {UserSessionUpdateArgs} args - Arguments to update one UserSession.
     * @example
     * // Update one UserSession
     * const userSession = await prisma.userSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSessionUpdateArgs>(args: SelectSubset<T, UserSessionUpdateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSessions.
     * @param {UserSessionDeleteManyArgs} args - Arguments to filter UserSessions to delete.
     * @example
     * // Delete a few UserSessions
     * const { count } = await prisma.userSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSessionDeleteManyArgs>(args?: SelectSubset<T, UserSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSessionUpdateManyArgs>(args: SelectSubset<T, UserSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions and returns the data updated in the database.
     * @param {UserSessionUpdateManyAndReturnArgs} args - Arguments to update many UserSessions.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSessions and only return the `sessionId`
     * const userSessionWithSessionIdOnly = await prisma.userSession.updateManyAndReturn({
     *   select: { sessionId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSession.
     * @param {UserSessionUpsertArgs} args - Arguments to update or create a UserSession.
     * @example
     * // Update or create a UserSession
     * const userSession = await prisma.userSession.upsert({
     *   create: {
     *     // ... data to create a UserSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSession we want to update
     *   }
     * })
     */
    upsert<T extends UserSessionUpsertArgs>(args: SelectSubset<T, UserSessionUpsertArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionCountArgs} args - Arguments to filter UserSessions to count.
     * @example
     * // Count the number of UserSessions
     * const count = await prisma.userSession.count({
     *   where: {
     *     // ... the filter for the UserSessions we want to count
     *   }
     * })
    **/
    count<T extends UserSessionCountArgs>(
      args?: Subset<T, UserSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSessionAggregateArgs>(args: Subset<T, UserSessionAggregateArgs>): Prisma.PrismaPromise<GetUserSessionAggregateType<T>>

    /**
     * Group by UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSessionGroupByArgs['orderBy'] }
        : { orderBy?: UserSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSession model
   */
  readonly fields: UserSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSession model
   */
  interface UserSessionFieldRefs {
    readonly sessionId: FieldRef<"UserSession", 'String'>
    readonly userId: FieldRef<"UserSession", 'String'>
    readonly expiresAt: FieldRef<"UserSession", 'DateTime'>
    readonly createdAt: FieldRef<"UserSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSession findUnique
   */
  export type UserSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findUniqueOrThrow
   */
  export type UserSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findFirst
   */
  export type UserSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findFirstOrThrow
   */
  export type UserSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findMany
   */
  export type UserSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSessions to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession create
   */
  export type UserSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSession.
     */
    data: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
  }

  /**
   * UserSession createMany
   */
  export type UserSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSession createManyAndReturn
   */
  export type UserSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession update
   */
  export type UserSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSession.
     */
    data: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
    /**
     * Choose, which UserSession to update.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession updateMany
   */
  export type UserSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
  }

  /**
   * UserSession updateManyAndReturn
   */
  export type UserSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession upsert
   */
  export type UserSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSession to update in case it exists.
     */
    where: UserSessionWhereUniqueInput
    /**
     * In case the UserSession found by the `where` argument doesn't exist, create a new UserSession with this data.
     */
    create: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
    /**
     * In case the UserSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
  }

  /**
   * UserSession delete
   */
  export type UserSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter which UserSession to delete.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession deleteMany
   */
  export type UserSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSessions to delete
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to delete.
     */
    limit?: number
  }

  /**
   * UserSession without action
   */
  export type UserSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
  }


  /**
   * Model AcademicYear
   */

  export type AggregateAcademicYear = {
    _count: AcademicYearCountAggregateOutputType | null
    _min: AcademicYearMinAggregateOutputType | null
    _max: AcademicYearMaxAggregateOutputType | null
  }

  export type AcademicYearMinAggregateOutputType = {
    id: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    isCurrent: boolean | null
    createdBy: string | null
  }

  export type AcademicYearMaxAggregateOutputType = {
    id: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    isCurrent: boolean | null
    createdBy: string | null
  }

  export type AcademicYearCountAggregateOutputType = {
    id: number
    name: number
    startDate: number
    endDate: number
    isCurrent: number
    createdBy: number
    _all: number
  }


  export type AcademicYearMinAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    isCurrent?: true
    createdBy?: true
  }

  export type AcademicYearMaxAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    isCurrent?: true
    createdBy?: true
  }

  export type AcademicYearCountAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    isCurrent?: true
    createdBy?: true
    _all?: true
  }

  export type AcademicYearAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicYear to aggregate.
     */
    where?: AcademicYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicYears to fetch.
     */
    orderBy?: AcademicYearOrderByWithRelationInput | AcademicYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicYears
    **/
    _count?: true | AcademicYearCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicYearMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicYearMaxAggregateInputType
  }

  export type GetAcademicYearAggregateType<T extends AcademicYearAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicYear]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicYear[P]>
      : GetScalarType<T[P], AggregateAcademicYear[P]>
  }




  export type AcademicYearGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicYearWhereInput
    orderBy?: AcademicYearOrderByWithAggregationInput | AcademicYearOrderByWithAggregationInput[]
    by: AcademicYearScalarFieldEnum[] | AcademicYearScalarFieldEnum
    having?: AcademicYearScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicYearCountAggregateInputType | true
    _min?: AcademicYearMinAggregateInputType
    _max?: AcademicYearMaxAggregateInputType
  }

  export type AcademicYearGroupByOutputType = {
    id: string
    name: string
    startDate: Date
    endDate: Date
    isCurrent: boolean
    createdBy: string
    _count: AcademicYearCountAggregateOutputType | null
    _min: AcademicYearMinAggregateOutputType | null
    _max: AcademicYearMaxAggregateOutputType | null
  }

  type GetAcademicYearGroupByPayload<T extends AcademicYearGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicYearGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicYearGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicYearGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicYearGroupByOutputType[P]>
        }
      >
    >


  export type AcademicYearSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    isCurrent?: boolean
    createdBy?: boolean
    semesters?: boolean | AcademicYear$semestersArgs<ExtArgs>
    classes?: boolean | AcademicYear$classesArgs<ExtArgs>
    teacherSubjects?: boolean | AcademicYear$teacherSubjectsArgs<ExtArgs>
    studentEnrollments?: boolean | AcademicYear$studentEnrollmentsArgs<ExtArgs>
    gradeEntries?: boolean | AcademicYear$gradeEntriesArgs<ExtArgs>
    _count?: boolean | AcademicYearCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicYear"]>

  export type AcademicYearSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    isCurrent?: boolean
    createdBy?: boolean
  }, ExtArgs["result"]["academicYear"]>

  export type AcademicYearSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    isCurrent?: boolean
    createdBy?: boolean
  }, ExtArgs["result"]["academicYear"]>

  export type AcademicYearSelectScalar = {
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    isCurrent?: boolean
    createdBy?: boolean
  }

  export type AcademicYearOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "startDate" | "endDate" | "isCurrent" | "createdBy", ExtArgs["result"]["academicYear"]>
  export type AcademicYearInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    semesters?: boolean | AcademicYear$semestersArgs<ExtArgs>
    classes?: boolean | AcademicYear$classesArgs<ExtArgs>
    teacherSubjects?: boolean | AcademicYear$teacherSubjectsArgs<ExtArgs>
    studentEnrollments?: boolean | AcademicYear$studentEnrollmentsArgs<ExtArgs>
    gradeEntries?: boolean | AcademicYear$gradeEntriesArgs<ExtArgs>
    _count?: boolean | AcademicYearCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AcademicYearIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AcademicYearIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AcademicYearPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AcademicYear"
    objects: {
      semesters: Prisma.$SemesterPayload<ExtArgs>[]
      classes: Prisma.$ClassPayload<ExtArgs>[]
      teacherSubjects: Prisma.$TeacherSubjectPayload<ExtArgs>[]
      studentEnrollments: Prisma.$StudentEnrollmentPayload<ExtArgs>[]
      gradeEntries: Prisma.$GradeEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      startDate: Date
      endDate: Date
      isCurrent: boolean
      createdBy: string
    }, ExtArgs["result"]["academicYear"]>
    composites: {}
  }

  type AcademicYearGetPayload<S extends boolean | null | undefined | AcademicYearDefaultArgs> = $Result.GetResult<Prisma.$AcademicYearPayload, S>

  type AcademicYearCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AcademicYearFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AcademicYearCountAggregateInputType | true
    }

  export interface AcademicYearDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicYear'], meta: { name: 'AcademicYear' } }
    /**
     * Find zero or one AcademicYear that matches the filter.
     * @param {AcademicYearFindUniqueArgs} args - Arguments to find a AcademicYear
     * @example
     * // Get one AcademicYear
     * const academicYear = await prisma.academicYear.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicYearFindUniqueArgs>(args: SelectSubset<T, AcademicYearFindUniqueArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AcademicYear that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AcademicYearFindUniqueOrThrowArgs} args - Arguments to find a AcademicYear
     * @example
     * // Get one AcademicYear
     * const academicYear = await prisma.academicYear.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicYearFindUniqueOrThrowArgs>(args: SelectSubset<T, AcademicYearFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicYear that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearFindFirstArgs} args - Arguments to find a AcademicYear
     * @example
     * // Get one AcademicYear
     * const academicYear = await prisma.academicYear.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicYearFindFirstArgs>(args?: SelectSubset<T, AcademicYearFindFirstArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicYear that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearFindFirstOrThrowArgs} args - Arguments to find a AcademicYear
     * @example
     * // Get one AcademicYear
     * const academicYear = await prisma.academicYear.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicYearFindFirstOrThrowArgs>(args?: SelectSubset<T, AcademicYearFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AcademicYears that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicYears
     * const academicYears = await prisma.academicYear.findMany()
     * 
     * // Get first 10 AcademicYears
     * const academicYears = await prisma.academicYear.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicYearWithIdOnly = await prisma.academicYear.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcademicYearFindManyArgs>(args?: SelectSubset<T, AcademicYearFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AcademicYear.
     * @param {AcademicYearCreateArgs} args - Arguments to create a AcademicYear.
     * @example
     * // Create one AcademicYear
     * const AcademicYear = await prisma.academicYear.create({
     *   data: {
     *     // ... data to create a AcademicYear
     *   }
     * })
     * 
     */
    create<T extends AcademicYearCreateArgs>(args: SelectSubset<T, AcademicYearCreateArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AcademicYears.
     * @param {AcademicYearCreateManyArgs} args - Arguments to create many AcademicYears.
     * @example
     * // Create many AcademicYears
     * const academicYear = await prisma.academicYear.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcademicYearCreateManyArgs>(args?: SelectSubset<T, AcademicYearCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AcademicYears and returns the data saved in the database.
     * @param {AcademicYearCreateManyAndReturnArgs} args - Arguments to create many AcademicYears.
     * @example
     * // Create many AcademicYears
     * const academicYear = await prisma.academicYear.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AcademicYears and only return the `id`
     * const academicYearWithIdOnly = await prisma.academicYear.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AcademicYearCreateManyAndReturnArgs>(args?: SelectSubset<T, AcademicYearCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AcademicYear.
     * @param {AcademicYearDeleteArgs} args - Arguments to delete one AcademicYear.
     * @example
     * // Delete one AcademicYear
     * const AcademicYear = await prisma.academicYear.delete({
     *   where: {
     *     // ... filter to delete one AcademicYear
     *   }
     * })
     * 
     */
    delete<T extends AcademicYearDeleteArgs>(args: SelectSubset<T, AcademicYearDeleteArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AcademicYear.
     * @param {AcademicYearUpdateArgs} args - Arguments to update one AcademicYear.
     * @example
     * // Update one AcademicYear
     * const academicYear = await prisma.academicYear.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcademicYearUpdateArgs>(args: SelectSubset<T, AcademicYearUpdateArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AcademicYears.
     * @param {AcademicYearDeleteManyArgs} args - Arguments to filter AcademicYears to delete.
     * @example
     * // Delete a few AcademicYears
     * const { count } = await prisma.academicYear.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcademicYearDeleteManyArgs>(args?: SelectSubset<T, AcademicYearDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicYears
     * const academicYear = await prisma.academicYear.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcademicYearUpdateManyArgs>(args: SelectSubset<T, AcademicYearUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicYears and returns the data updated in the database.
     * @param {AcademicYearUpdateManyAndReturnArgs} args - Arguments to update many AcademicYears.
     * @example
     * // Update many AcademicYears
     * const academicYear = await prisma.academicYear.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AcademicYears and only return the `id`
     * const academicYearWithIdOnly = await prisma.academicYear.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AcademicYearUpdateManyAndReturnArgs>(args: SelectSubset<T, AcademicYearUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AcademicYear.
     * @param {AcademicYearUpsertArgs} args - Arguments to update or create a AcademicYear.
     * @example
     * // Update or create a AcademicYear
     * const academicYear = await prisma.academicYear.upsert({
     *   create: {
     *     // ... data to create a AcademicYear
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicYear we want to update
     *   }
     * })
     */
    upsert<T extends AcademicYearUpsertArgs>(args: SelectSubset<T, AcademicYearUpsertArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AcademicYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearCountArgs} args - Arguments to filter AcademicYears to count.
     * @example
     * // Count the number of AcademicYears
     * const count = await prisma.academicYear.count({
     *   where: {
     *     // ... the filter for the AcademicYears we want to count
     *   }
     * })
    **/
    count<T extends AcademicYearCountArgs>(
      args?: Subset<T, AcademicYearCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicYearCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicYearAggregateArgs>(args: Subset<T, AcademicYearAggregateArgs>): Prisma.PrismaPromise<GetAcademicYearAggregateType<T>>

    /**
     * Group by AcademicYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicYearGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicYearGroupByArgs['orderBy'] }
        : { orderBy?: AcademicYearGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicYearGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicYearGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicYear model
   */
  readonly fields: AcademicYearFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicYear.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicYearClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    semesters<T extends AcademicYear$semestersArgs<ExtArgs> = {}>(args?: Subset<T, AcademicYear$semestersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classes<T extends AcademicYear$classesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicYear$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teacherSubjects<T extends AcademicYear$teacherSubjectsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicYear$teacherSubjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentEnrollments<T extends AcademicYear$studentEnrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicYear$studentEnrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gradeEntries<T extends AcademicYear$gradeEntriesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicYear$gradeEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradeEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AcademicYear model
   */
  interface AcademicYearFieldRefs {
    readonly id: FieldRef<"AcademicYear", 'String'>
    readonly name: FieldRef<"AcademicYear", 'String'>
    readonly startDate: FieldRef<"AcademicYear", 'DateTime'>
    readonly endDate: FieldRef<"AcademicYear", 'DateTime'>
    readonly isCurrent: FieldRef<"AcademicYear", 'Boolean'>
    readonly createdBy: FieldRef<"AcademicYear", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AcademicYear findUnique
   */
  export type AcademicYearFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter, which AcademicYear to fetch.
     */
    where: AcademicYearWhereUniqueInput
  }

  /**
   * AcademicYear findUniqueOrThrow
   */
  export type AcademicYearFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter, which AcademicYear to fetch.
     */
    where: AcademicYearWhereUniqueInput
  }

  /**
   * AcademicYear findFirst
   */
  export type AcademicYearFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter, which AcademicYear to fetch.
     */
    where?: AcademicYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicYears to fetch.
     */
    orderBy?: AcademicYearOrderByWithRelationInput | AcademicYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicYears.
     */
    cursor?: AcademicYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicYears.
     */
    distinct?: AcademicYearScalarFieldEnum | AcademicYearScalarFieldEnum[]
  }

  /**
   * AcademicYear findFirstOrThrow
   */
  export type AcademicYearFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter, which AcademicYear to fetch.
     */
    where?: AcademicYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicYears to fetch.
     */
    orderBy?: AcademicYearOrderByWithRelationInput | AcademicYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicYears.
     */
    cursor?: AcademicYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicYears.
     */
    distinct?: AcademicYearScalarFieldEnum | AcademicYearScalarFieldEnum[]
  }

  /**
   * AcademicYear findMany
   */
  export type AcademicYearFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter, which AcademicYears to fetch.
     */
    where?: AcademicYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicYears to fetch.
     */
    orderBy?: AcademicYearOrderByWithRelationInput | AcademicYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicYears.
     */
    cursor?: AcademicYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicYears.
     */
    skip?: number
    distinct?: AcademicYearScalarFieldEnum | AcademicYearScalarFieldEnum[]
  }

  /**
   * AcademicYear create
   */
  export type AcademicYearCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicYear.
     */
    data: XOR<AcademicYearCreateInput, AcademicYearUncheckedCreateInput>
  }

  /**
   * AcademicYear createMany
   */
  export type AcademicYearCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicYears.
     */
    data: AcademicYearCreateManyInput | AcademicYearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicYear createManyAndReturn
   */
  export type AcademicYearCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * The data used to create many AcademicYears.
     */
    data: AcademicYearCreateManyInput | AcademicYearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicYear update
   */
  export type AcademicYearUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicYear.
     */
    data: XOR<AcademicYearUpdateInput, AcademicYearUncheckedUpdateInput>
    /**
     * Choose, which AcademicYear to update.
     */
    where: AcademicYearWhereUniqueInput
  }

  /**
   * AcademicYear updateMany
   */
  export type AcademicYearUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicYears.
     */
    data: XOR<AcademicYearUpdateManyMutationInput, AcademicYearUncheckedUpdateManyInput>
    /**
     * Filter which AcademicYears to update
     */
    where?: AcademicYearWhereInput
    /**
     * Limit how many AcademicYears to update.
     */
    limit?: number
  }

  /**
   * AcademicYear updateManyAndReturn
   */
  export type AcademicYearUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * The data used to update AcademicYears.
     */
    data: XOR<AcademicYearUpdateManyMutationInput, AcademicYearUncheckedUpdateManyInput>
    /**
     * Filter which AcademicYears to update
     */
    where?: AcademicYearWhereInput
    /**
     * Limit how many AcademicYears to update.
     */
    limit?: number
  }

  /**
   * AcademicYear upsert
   */
  export type AcademicYearUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicYear to update in case it exists.
     */
    where: AcademicYearWhereUniqueInput
    /**
     * In case the AcademicYear found by the `where` argument doesn't exist, create a new AcademicYear with this data.
     */
    create: XOR<AcademicYearCreateInput, AcademicYearUncheckedCreateInput>
    /**
     * In case the AcademicYear was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicYearUpdateInput, AcademicYearUncheckedUpdateInput>
  }

  /**
   * AcademicYear delete
   */
  export type AcademicYearDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter which AcademicYear to delete.
     */
    where: AcademicYearWhereUniqueInput
  }

  /**
   * AcademicYear deleteMany
   */
  export type AcademicYearDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicYears to delete
     */
    where?: AcademicYearWhereInput
    /**
     * Limit how many AcademicYears to delete.
     */
    limit?: number
  }

  /**
   * AcademicYear.semesters
   */
  export type AcademicYear$semestersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semester
     */
    select?: SemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Semester
     */
    omit?: SemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterInclude<ExtArgs> | null
    where?: SemesterWhereInput
    orderBy?: SemesterOrderByWithRelationInput | SemesterOrderByWithRelationInput[]
    cursor?: SemesterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SemesterScalarFieldEnum | SemesterScalarFieldEnum[]
  }

  /**
   * AcademicYear.classes
   */
  export type AcademicYear$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * AcademicYear.teacherSubjects
   */
  export type AcademicYear$teacherSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherSubject
     */
    omit?: TeacherSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    where?: TeacherSubjectWhereInput
    orderBy?: TeacherSubjectOrderByWithRelationInput | TeacherSubjectOrderByWithRelationInput[]
    cursor?: TeacherSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherSubjectScalarFieldEnum | TeacherSubjectScalarFieldEnum[]
  }

  /**
   * AcademicYear.studentEnrollments
   */
  export type AcademicYear$studentEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    where?: StudentEnrollmentWhereInput
    orderBy?: StudentEnrollmentOrderByWithRelationInput | StudentEnrollmentOrderByWithRelationInput[]
    cursor?: StudentEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentEnrollmentScalarFieldEnum | StudentEnrollmentScalarFieldEnum[]
  }

  /**
   * AcademicYear.gradeEntries
   */
  export type AcademicYear$gradeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeEntry
     */
    select?: GradeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeEntry
     */
    omit?: GradeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeEntryInclude<ExtArgs> | null
    where?: GradeEntryWhereInput
    orderBy?: GradeEntryOrderByWithRelationInput | GradeEntryOrderByWithRelationInput[]
    cursor?: GradeEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeEntryScalarFieldEnum | GradeEntryScalarFieldEnum[]
  }

  /**
   * AcademicYear without action
   */
  export type AcademicYearDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
  }


  /**
   * Model Semester
   */

  export type AggregateSemester = {
    _count: SemesterCountAggregateOutputType | null
    _avg: SemesterAvgAggregateOutputType | null
    _sum: SemesterSumAggregateOutputType | null
    _min: SemesterMinAggregateOutputType | null
    _max: SemesterMaxAggregateOutputType | null
  }

  export type SemesterAvgAggregateOutputType = {
    minAverage: number | null
  }

  export type SemesterSumAggregateOutputType = {
    minAverage: number | null
  }

  export type SemesterMinAggregateOutputType = {
    id: string | null
    name: string | null
    academicYearId: string | null
    startDate: Date | null
    endDate: Date | null
    isCurrent: boolean | null
    registrationOpen: boolean | null
    minAverage: number | null
    noFailedSubjects: boolean | null
  }

  export type SemesterMaxAggregateOutputType = {
    id: string | null
    name: string | null
    academicYearId: string | null
    startDate: Date | null
    endDate: Date | null
    isCurrent: boolean | null
    registrationOpen: boolean | null
    minAverage: number | null
    noFailedSubjects: boolean | null
  }

  export type SemesterCountAggregateOutputType = {
    id: number
    name: number
    academicYearId: number
    startDate: number
    endDate: number
    isCurrent: number
    registrationOpen: number
    minAverage: number
    noFailedSubjects: number
    _all: number
  }


  export type SemesterAvgAggregateInputType = {
    minAverage?: true
  }

  export type SemesterSumAggregateInputType = {
    minAverage?: true
  }

  export type SemesterMinAggregateInputType = {
    id?: true
    name?: true
    academicYearId?: true
    startDate?: true
    endDate?: true
    isCurrent?: true
    registrationOpen?: true
    minAverage?: true
    noFailedSubjects?: true
  }

  export type SemesterMaxAggregateInputType = {
    id?: true
    name?: true
    academicYearId?: true
    startDate?: true
    endDate?: true
    isCurrent?: true
    registrationOpen?: true
    minAverage?: true
    noFailedSubjects?: true
  }

  export type SemesterCountAggregateInputType = {
    id?: true
    name?: true
    academicYearId?: true
    startDate?: true
    endDate?: true
    isCurrent?: true
    registrationOpen?: true
    minAverage?: true
    noFailedSubjects?: true
    _all?: true
  }

  export type SemesterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Semester to aggregate.
     */
    where?: SemesterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Semesters to fetch.
     */
    orderBy?: SemesterOrderByWithRelationInput | SemesterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SemesterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Semesters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Semesters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Semesters
    **/
    _count?: true | SemesterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SemesterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SemesterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SemesterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SemesterMaxAggregateInputType
  }

  export type GetSemesterAggregateType<T extends SemesterAggregateArgs> = {
        [P in keyof T & keyof AggregateSemester]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSemester[P]>
      : GetScalarType<T[P], AggregateSemester[P]>
  }




  export type SemesterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SemesterWhereInput
    orderBy?: SemesterOrderByWithAggregationInput | SemesterOrderByWithAggregationInput[]
    by: SemesterScalarFieldEnum[] | SemesterScalarFieldEnum
    having?: SemesterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SemesterCountAggregateInputType | true
    _avg?: SemesterAvgAggregateInputType
    _sum?: SemesterSumAggregateInputType
    _min?: SemesterMinAggregateInputType
    _max?: SemesterMaxAggregateInputType
  }

  export type SemesterGroupByOutputType = {
    id: string
    name: string
    academicYearId: string
    startDate: Date
    endDate: Date
    isCurrent: boolean
    registrationOpen: boolean
    minAverage: number | null
    noFailedSubjects: boolean | null
    _count: SemesterCountAggregateOutputType | null
    _avg: SemesterAvgAggregateOutputType | null
    _sum: SemesterSumAggregateOutputType | null
    _min: SemesterMinAggregateOutputType | null
    _max: SemesterMaxAggregateOutputType | null
  }

  type GetSemesterGroupByPayload<T extends SemesterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SemesterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SemesterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SemesterGroupByOutputType[P]>
            : GetScalarType<T[P], SemesterGroupByOutputType[P]>
        }
      >
    >


  export type SemesterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    academicYearId?: boolean
    startDate?: boolean
    endDate?: boolean
    isCurrent?: boolean
    registrationOpen?: boolean
    minAverage?: boolean
    noFailedSubjects?: boolean
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
    attendanceSummaries?: boolean | Semester$attendanceSummariesArgs<ExtArgs>
    gradeReports?: boolean | Semester$gradeReportsArgs<ExtArgs>
    gradeEntries?: boolean | Semester$gradeEntriesArgs<ExtArgs>
    studentEnrollments?: boolean | Semester$studentEnrollmentsArgs<ExtArgs>
    registrationRequests?: boolean | Semester$registrationRequestsArgs<ExtArgs>
    _count?: boolean | SemesterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["semester"]>

  export type SemesterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    academicYearId?: boolean
    startDate?: boolean
    endDate?: boolean
    isCurrent?: boolean
    registrationOpen?: boolean
    minAverage?: boolean
    noFailedSubjects?: boolean
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["semester"]>

  export type SemesterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    academicYearId?: boolean
    startDate?: boolean
    endDate?: boolean
    isCurrent?: boolean
    registrationOpen?: boolean
    minAverage?: boolean
    noFailedSubjects?: boolean
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["semester"]>

  export type SemesterSelectScalar = {
    id?: boolean
    name?: boolean
    academicYearId?: boolean
    startDate?: boolean
    endDate?: boolean
    isCurrent?: boolean
    registrationOpen?: boolean
    minAverage?: boolean
    noFailedSubjects?: boolean
  }

  export type SemesterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "academicYearId" | "startDate" | "endDate" | "isCurrent" | "registrationOpen" | "minAverage" | "noFailedSubjects", ExtArgs["result"]["semester"]>
  export type SemesterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
    attendanceSummaries?: boolean | Semester$attendanceSummariesArgs<ExtArgs>
    gradeReports?: boolean | Semester$gradeReportsArgs<ExtArgs>
    gradeEntries?: boolean | Semester$gradeEntriesArgs<ExtArgs>
    studentEnrollments?: boolean | Semester$studentEnrollmentsArgs<ExtArgs>
    registrationRequests?: boolean | Semester$registrationRequestsArgs<ExtArgs>
    _count?: boolean | SemesterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SemesterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
  }
  export type SemesterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
  }

  export type $SemesterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Semester"
    objects: {
      academicYear: Prisma.$AcademicYearPayload<ExtArgs>
      attendanceSummaries: Prisma.$AttendanceSummaryPayload<ExtArgs>[]
      gradeReports: Prisma.$GradeReportPayload<ExtArgs>[]
      gradeEntries: Prisma.$GradeEntryPayload<ExtArgs>[]
      studentEnrollments: Prisma.$StudentEnrollmentPayload<ExtArgs>[]
      registrationRequests: Prisma.$StudentRegistrationRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      academicYearId: string
      startDate: Date
      endDate: Date
      isCurrent: boolean
      registrationOpen: boolean
      minAverage: number | null
      noFailedSubjects: boolean | null
    }, ExtArgs["result"]["semester"]>
    composites: {}
  }

  type SemesterGetPayload<S extends boolean | null | undefined | SemesterDefaultArgs> = $Result.GetResult<Prisma.$SemesterPayload, S>

  type SemesterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SemesterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SemesterCountAggregateInputType | true
    }

  export interface SemesterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Semester'], meta: { name: 'Semester' } }
    /**
     * Find zero or one Semester that matches the filter.
     * @param {SemesterFindUniqueArgs} args - Arguments to find a Semester
     * @example
     * // Get one Semester
     * const semester = await prisma.semester.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SemesterFindUniqueArgs>(args: SelectSubset<T, SemesterFindUniqueArgs<ExtArgs>>): Prisma__SemesterClient<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Semester that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SemesterFindUniqueOrThrowArgs} args - Arguments to find a Semester
     * @example
     * // Get one Semester
     * const semester = await prisma.semester.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SemesterFindUniqueOrThrowArgs>(args: SelectSubset<T, SemesterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SemesterClient<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Semester that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterFindFirstArgs} args - Arguments to find a Semester
     * @example
     * // Get one Semester
     * const semester = await prisma.semester.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SemesterFindFirstArgs>(args?: SelectSubset<T, SemesterFindFirstArgs<ExtArgs>>): Prisma__SemesterClient<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Semester that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterFindFirstOrThrowArgs} args - Arguments to find a Semester
     * @example
     * // Get one Semester
     * const semester = await prisma.semester.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SemesterFindFirstOrThrowArgs>(args?: SelectSubset<T, SemesterFindFirstOrThrowArgs<ExtArgs>>): Prisma__SemesterClient<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Semesters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Semesters
     * const semesters = await prisma.semester.findMany()
     * 
     * // Get first 10 Semesters
     * const semesters = await prisma.semester.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const semesterWithIdOnly = await prisma.semester.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SemesterFindManyArgs>(args?: SelectSubset<T, SemesterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Semester.
     * @param {SemesterCreateArgs} args - Arguments to create a Semester.
     * @example
     * // Create one Semester
     * const Semester = await prisma.semester.create({
     *   data: {
     *     // ... data to create a Semester
     *   }
     * })
     * 
     */
    create<T extends SemesterCreateArgs>(args: SelectSubset<T, SemesterCreateArgs<ExtArgs>>): Prisma__SemesterClient<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Semesters.
     * @param {SemesterCreateManyArgs} args - Arguments to create many Semesters.
     * @example
     * // Create many Semesters
     * const semester = await prisma.semester.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SemesterCreateManyArgs>(args?: SelectSubset<T, SemesterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Semesters and returns the data saved in the database.
     * @param {SemesterCreateManyAndReturnArgs} args - Arguments to create many Semesters.
     * @example
     * // Create many Semesters
     * const semester = await prisma.semester.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Semesters and only return the `id`
     * const semesterWithIdOnly = await prisma.semester.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SemesterCreateManyAndReturnArgs>(args?: SelectSubset<T, SemesterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Semester.
     * @param {SemesterDeleteArgs} args - Arguments to delete one Semester.
     * @example
     * // Delete one Semester
     * const Semester = await prisma.semester.delete({
     *   where: {
     *     // ... filter to delete one Semester
     *   }
     * })
     * 
     */
    delete<T extends SemesterDeleteArgs>(args: SelectSubset<T, SemesterDeleteArgs<ExtArgs>>): Prisma__SemesterClient<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Semester.
     * @param {SemesterUpdateArgs} args - Arguments to update one Semester.
     * @example
     * // Update one Semester
     * const semester = await prisma.semester.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SemesterUpdateArgs>(args: SelectSubset<T, SemesterUpdateArgs<ExtArgs>>): Prisma__SemesterClient<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Semesters.
     * @param {SemesterDeleteManyArgs} args - Arguments to filter Semesters to delete.
     * @example
     * // Delete a few Semesters
     * const { count } = await prisma.semester.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SemesterDeleteManyArgs>(args?: SelectSubset<T, SemesterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Semesters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Semesters
     * const semester = await prisma.semester.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SemesterUpdateManyArgs>(args: SelectSubset<T, SemesterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Semesters and returns the data updated in the database.
     * @param {SemesterUpdateManyAndReturnArgs} args - Arguments to update many Semesters.
     * @example
     * // Update many Semesters
     * const semester = await prisma.semester.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Semesters and only return the `id`
     * const semesterWithIdOnly = await prisma.semester.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SemesterUpdateManyAndReturnArgs>(args: SelectSubset<T, SemesterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Semester.
     * @param {SemesterUpsertArgs} args - Arguments to update or create a Semester.
     * @example
     * // Update or create a Semester
     * const semester = await prisma.semester.upsert({
     *   create: {
     *     // ... data to create a Semester
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Semester we want to update
     *   }
     * })
     */
    upsert<T extends SemesterUpsertArgs>(args: SelectSubset<T, SemesterUpsertArgs<ExtArgs>>): Prisma__SemesterClient<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Semesters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterCountArgs} args - Arguments to filter Semesters to count.
     * @example
     * // Count the number of Semesters
     * const count = await prisma.semester.count({
     *   where: {
     *     // ... the filter for the Semesters we want to count
     *   }
     * })
    **/
    count<T extends SemesterCountArgs>(
      args?: Subset<T, SemesterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SemesterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Semester.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SemesterAggregateArgs>(args: Subset<T, SemesterAggregateArgs>): Prisma.PrismaPromise<GetSemesterAggregateType<T>>

    /**
     * Group by Semester.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SemesterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SemesterGroupByArgs['orderBy'] }
        : { orderBy?: SemesterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SemesterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSemesterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Semester model
   */
  readonly fields: SemesterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Semester.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SemesterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    academicYear<T extends AcademicYearDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicYearDefaultArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attendanceSummaries<T extends Semester$attendanceSummariesArgs<ExtArgs> = {}>(args?: Subset<T, Semester$attendanceSummariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gradeReports<T extends Semester$gradeReportsArgs<ExtArgs> = {}>(args?: Subset<T, Semester$gradeReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradeReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gradeEntries<T extends Semester$gradeEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Semester$gradeEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradeEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentEnrollments<T extends Semester$studentEnrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Semester$studentEnrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    registrationRequests<T extends Semester$registrationRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Semester$registrationRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentRegistrationRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Semester model
   */
  interface SemesterFieldRefs {
    readonly id: FieldRef<"Semester", 'String'>
    readonly name: FieldRef<"Semester", 'String'>
    readonly academicYearId: FieldRef<"Semester", 'String'>
    readonly startDate: FieldRef<"Semester", 'DateTime'>
    readonly endDate: FieldRef<"Semester", 'DateTime'>
    readonly isCurrent: FieldRef<"Semester", 'Boolean'>
    readonly registrationOpen: FieldRef<"Semester", 'Boolean'>
    readonly minAverage: FieldRef<"Semester", 'Float'>
    readonly noFailedSubjects: FieldRef<"Semester", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Semester findUnique
   */
  export type SemesterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semester
     */
    select?: SemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Semester
     */
    omit?: SemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterInclude<ExtArgs> | null
    /**
     * Filter, which Semester to fetch.
     */
    where: SemesterWhereUniqueInput
  }

  /**
   * Semester findUniqueOrThrow
   */
  export type SemesterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semester
     */
    select?: SemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Semester
     */
    omit?: SemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterInclude<ExtArgs> | null
    /**
     * Filter, which Semester to fetch.
     */
    where: SemesterWhereUniqueInput
  }

  /**
   * Semester findFirst
   */
  export type SemesterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semester
     */
    select?: SemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Semester
     */
    omit?: SemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterInclude<ExtArgs> | null
    /**
     * Filter, which Semester to fetch.
     */
    where?: SemesterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Semesters to fetch.
     */
    orderBy?: SemesterOrderByWithRelationInput | SemesterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Semesters.
     */
    cursor?: SemesterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Semesters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Semesters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Semesters.
     */
    distinct?: SemesterScalarFieldEnum | SemesterScalarFieldEnum[]
  }

  /**
   * Semester findFirstOrThrow
   */
  export type SemesterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semester
     */
    select?: SemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Semester
     */
    omit?: SemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterInclude<ExtArgs> | null
    /**
     * Filter, which Semester to fetch.
     */
    where?: SemesterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Semesters to fetch.
     */
    orderBy?: SemesterOrderByWithRelationInput | SemesterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Semesters.
     */
    cursor?: SemesterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Semesters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Semesters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Semesters.
     */
    distinct?: SemesterScalarFieldEnum | SemesterScalarFieldEnum[]
  }

  /**
   * Semester findMany
   */
  export type SemesterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semester
     */
    select?: SemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Semester
     */
    omit?: SemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterInclude<ExtArgs> | null
    /**
     * Filter, which Semesters to fetch.
     */
    where?: SemesterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Semesters to fetch.
     */
    orderBy?: SemesterOrderByWithRelationInput | SemesterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Semesters.
     */
    cursor?: SemesterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Semesters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Semesters.
     */
    skip?: number
    distinct?: SemesterScalarFieldEnum | SemesterScalarFieldEnum[]
  }

  /**
   * Semester create
   */
  export type SemesterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semester
     */
    select?: SemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Semester
     */
    omit?: SemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterInclude<ExtArgs> | null
    /**
     * The data needed to create a Semester.
     */
    data: XOR<SemesterCreateInput, SemesterUncheckedCreateInput>
  }

  /**
   * Semester createMany
   */
  export type SemesterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Semesters.
     */
    data: SemesterCreateManyInput | SemesterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Semester createManyAndReturn
   */
  export type SemesterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semester
     */
    select?: SemesterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Semester
     */
    omit?: SemesterOmit<ExtArgs> | null
    /**
     * The data used to create many Semesters.
     */
    data: SemesterCreateManyInput | SemesterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Semester update
   */
  export type SemesterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semester
     */
    select?: SemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Semester
     */
    omit?: SemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterInclude<ExtArgs> | null
    /**
     * The data needed to update a Semester.
     */
    data: XOR<SemesterUpdateInput, SemesterUncheckedUpdateInput>
    /**
     * Choose, which Semester to update.
     */
    where: SemesterWhereUniqueInput
  }

  /**
   * Semester updateMany
   */
  export type SemesterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Semesters.
     */
    data: XOR<SemesterUpdateManyMutationInput, SemesterUncheckedUpdateManyInput>
    /**
     * Filter which Semesters to update
     */
    where?: SemesterWhereInput
    /**
     * Limit how many Semesters to update.
     */
    limit?: number
  }

  /**
   * Semester updateManyAndReturn
   */
  export type SemesterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semester
     */
    select?: SemesterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Semester
     */
    omit?: SemesterOmit<ExtArgs> | null
    /**
     * The data used to update Semesters.
     */
    data: XOR<SemesterUpdateManyMutationInput, SemesterUncheckedUpdateManyInput>
    /**
     * Filter which Semesters to update
     */
    where?: SemesterWhereInput
    /**
     * Limit how many Semesters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Semester upsert
   */
  export type SemesterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semester
     */
    select?: SemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Semester
     */
    omit?: SemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterInclude<ExtArgs> | null
    /**
     * The filter to search for the Semester to update in case it exists.
     */
    where: SemesterWhereUniqueInput
    /**
     * In case the Semester found by the `where` argument doesn't exist, create a new Semester with this data.
     */
    create: XOR<SemesterCreateInput, SemesterUncheckedCreateInput>
    /**
     * In case the Semester was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SemesterUpdateInput, SemesterUncheckedUpdateInput>
  }

  /**
   * Semester delete
   */
  export type SemesterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semester
     */
    select?: SemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Semester
     */
    omit?: SemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterInclude<ExtArgs> | null
    /**
     * Filter which Semester to delete.
     */
    where: SemesterWhereUniqueInput
  }

  /**
   * Semester deleteMany
   */
  export type SemesterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Semesters to delete
     */
    where?: SemesterWhereInput
    /**
     * Limit how many Semesters to delete.
     */
    limit?: number
  }

  /**
   * Semester.attendanceSummaries
   */
  export type Semester$attendanceSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    where?: AttendanceSummaryWhereInput
    orderBy?: AttendanceSummaryOrderByWithRelationInput | AttendanceSummaryOrderByWithRelationInput[]
    cursor?: AttendanceSummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceSummaryScalarFieldEnum | AttendanceSummaryScalarFieldEnum[]
  }

  /**
   * Semester.gradeReports
   */
  export type Semester$gradeReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeReport
     */
    select?: GradeReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeReport
     */
    omit?: GradeReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeReportInclude<ExtArgs> | null
    where?: GradeReportWhereInput
    orderBy?: GradeReportOrderByWithRelationInput | GradeReportOrderByWithRelationInput[]
    cursor?: GradeReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeReportScalarFieldEnum | GradeReportScalarFieldEnum[]
  }

  /**
   * Semester.gradeEntries
   */
  export type Semester$gradeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeEntry
     */
    select?: GradeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeEntry
     */
    omit?: GradeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeEntryInclude<ExtArgs> | null
    where?: GradeEntryWhereInput
    orderBy?: GradeEntryOrderByWithRelationInput | GradeEntryOrderByWithRelationInput[]
    cursor?: GradeEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeEntryScalarFieldEnum | GradeEntryScalarFieldEnum[]
  }

  /**
   * Semester.studentEnrollments
   */
  export type Semester$studentEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    where?: StudentEnrollmentWhereInput
    orderBy?: StudentEnrollmentOrderByWithRelationInput | StudentEnrollmentOrderByWithRelationInput[]
    cursor?: StudentEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentEnrollmentScalarFieldEnum | StudentEnrollmentScalarFieldEnum[]
  }

  /**
   * Semester.registrationRequests
   */
  export type Semester$registrationRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRegistrationRequest
     */
    select?: StudentRegistrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentRegistrationRequest
     */
    omit?: StudentRegistrationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRegistrationRequestInclude<ExtArgs> | null
    where?: StudentRegistrationRequestWhereInput
    orderBy?: StudentRegistrationRequestOrderByWithRelationInput | StudentRegistrationRequestOrderByWithRelationInput[]
    cursor?: StudentRegistrationRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentRegistrationRequestScalarFieldEnum | StudentRegistrationRequestScalarFieldEnum[]
  }

  /**
   * Semester without action
   */
  export type SemesterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semester
     */
    select?: SemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Semester
     */
    omit?: SemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterInclude<ExtArgs> | null
  }


  /**
   * Model ClassSection
   */

  export type AggregateClassSection = {
    _count: ClassSectionCountAggregateOutputType | null
    _min: ClassSectionMinAggregateOutputType | null
    _max: ClassSectionMaxAggregateOutputType | null
  }

  export type ClassSectionMinAggregateOutputType = {
    id: string | null
    name: string | null
    gradeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassSectionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    gradeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassSectionCountAggregateOutputType = {
    id: number
    name: number
    gradeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClassSectionMinAggregateInputType = {
    id?: true
    name?: true
    gradeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassSectionMaxAggregateInputType = {
    id?: true
    name?: true
    gradeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassSectionCountAggregateInputType = {
    id?: true
    name?: true
    gradeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClassSectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassSection to aggregate.
     */
    where?: ClassSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSections to fetch.
     */
    orderBy?: ClassSectionOrderByWithRelationInput | ClassSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassSections
    **/
    _count?: true | ClassSectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassSectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassSectionMaxAggregateInputType
  }

  export type GetClassSectionAggregateType<T extends ClassSectionAggregateArgs> = {
        [P in keyof T & keyof AggregateClassSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassSection[P]>
      : GetScalarType<T[P], AggregateClassSection[P]>
  }




  export type ClassSectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassSectionWhereInput
    orderBy?: ClassSectionOrderByWithAggregationInput | ClassSectionOrderByWithAggregationInput[]
    by: ClassSectionScalarFieldEnum[] | ClassSectionScalarFieldEnum
    having?: ClassSectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassSectionCountAggregateInputType | true
    _min?: ClassSectionMinAggregateInputType
    _max?: ClassSectionMaxAggregateInputType
  }

  export type ClassSectionGroupByOutputType = {
    id: string
    name: string
    gradeId: string
    createdAt: Date
    updatedAt: Date
    _count: ClassSectionCountAggregateOutputType | null
    _min: ClassSectionMinAggregateOutputType | null
    _max: ClassSectionMaxAggregateOutputType | null
  }

  type GetClassSectionGroupByPayload<T extends ClassSectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassSectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassSectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassSectionGroupByOutputType[P]>
            : GetScalarType<T[P], ClassSectionGroupByOutputType[P]>
        }
      >
    >


  export type ClassSectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    gradeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    classes?: boolean | ClassSection$classesArgs<ExtArgs>
    _count?: boolean | ClassSectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classSection"]>

  export type ClassSectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    gradeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    grade?: boolean | GradeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classSection"]>

  export type ClassSectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    gradeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    grade?: boolean | GradeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classSection"]>

  export type ClassSectionSelectScalar = {
    id?: boolean
    name?: boolean
    gradeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClassSectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "gradeId" | "createdAt" | "updatedAt", ExtArgs["result"]["classSection"]>
  export type ClassSectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    classes?: boolean | ClassSection$classesArgs<ExtArgs>
    _count?: boolean | ClassSectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassSectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grade?: boolean | GradeDefaultArgs<ExtArgs>
  }
  export type ClassSectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grade?: boolean | GradeDefaultArgs<ExtArgs>
  }

  export type $ClassSectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassSection"
    objects: {
      grade: Prisma.$GradePayload<ExtArgs>
      classes: Prisma.$ClassPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      gradeId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["classSection"]>
    composites: {}
  }

  type ClassSectionGetPayload<S extends boolean | null | undefined | ClassSectionDefaultArgs> = $Result.GetResult<Prisma.$ClassSectionPayload, S>

  type ClassSectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassSectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassSectionCountAggregateInputType | true
    }

  export interface ClassSectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassSection'], meta: { name: 'ClassSection' } }
    /**
     * Find zero or one ClassSection that matches the filter.
     * @param {ClassSectionFindUniqueArgs} args - Arguments to find a ClassSection
     * @example
     * // Get one ClassSection
     * const classSection = await prisma.classSection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassSectionFindUniqueArgs>(args: SelectSubset<T, ClassSectionFindUniqueArgs<ExtArgs>>): Prisma__ClassSectionClient<$Result.GetResult<Prisma.$ClassSectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClassSection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassSectionFindUniqueOrThrowArgs} args - Arguments to find a ClassSection
     * @example
     * // Get one ClassSection
     * const classSection = await prisma.classSection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassSectionFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassSectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassSectionClient<$Result.GetResult<Prisma.$ClassSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassSection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSectionFindFirstArgs} args - Arguments to find a ClassSection
     * @example
     * // Get one ClassSection
     * const classSection = await prisma.classSection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassSectionFindFirstArgs>(args?: SelectSubset<T, ClassSectionFindFirstArgs<ExtArgs>>): Prisma__ClassSectionClient<$Result.GetResult<Prisma.$ClassSectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassSection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSectionFindFirstOrThrowArgs} args - Arguments to find a ClassSection
     * @example
     * // Get one ClassSection
     * const classSection = await prisma.classSection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassSectionFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassSectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassSectionClient<$Result.GetResult<Prisma.$ClassSectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClassSections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassSections
     * const classSections = await prisma.classSection.findMany()
     * 
     * // Get first 10 ClassSections
     * const classSections = await prisma.classSection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classSectionWithIdOnly = await prisma.classSection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassSectionFindManyArgs>(args?: SelectSubset<T, ClassSectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClassSection.
     * @param {ClassSectionCreateArgs} args - Arguments to create a ClassSection.
     * @example
     * // Create one ClassSection
     * const ClassSection = await prisma.classSection.create({
     *   data: {
     *     // ... data to create a ClassSection
     *   }
     * })
     * 
     */
    create<T extends ClassSectionCreateArgs>(args: SelectSubset<T, ClassSectionCreateArgs<ExtArgs>>): Prisma__ClassSectionClient<$Result.GetResult<Prisma.$ClassSectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClassSections.
     * @param {ClassSectionCreateManyArgs} args - Arguments to create many ClassSections.
     * @example
     * // Create many ClassSections
     * const classSection = await prisma.classSection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassSectionCreateManyArgs>(args?: SelectSubset<T, ClassSectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClassSections and returns the data saved in the database.
     * @param {ClassSectionCreateManyAndReturnArgs} args - Arguments to create many ClassSections.
     * @example
     * // Create many ClassSections
     * const classSection = await prisma.classSection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClassSections and only return the `id`
     * const classSectionWithIdOnly = await prisma.classSection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassSectionCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassSectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClassSection.
     * @param {ClassSectionDeleteArgs} args - Arguments to delete one ClassSection.
     * @example
     * // Delete one ClassSection
     * const ClassSection = await prisma.classSection.delete({
     *   where: {
     *     // ... filter to delete one ClassSection
     *   }
     * })
     * 
     */
    delete<T extends ClassSectionDeleteArgs>(args: SelectSubset<T, ClassSectionDeleteArgs<ExtArgs>>): Prisma__ClassSectionClient<$Result.GetResult<Prisma.$ClassSectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClassSection.
     * @param {ClassSectionUpdateArgs} args - Arguments to update one ClassSection.
     * @example
     * // Update one ClassSection
     * const classSection = await prisma.classSection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassSectionUpdateArgs>(args: SelectSubset<T, ClassSectionUpdateArgs<ExtArgs>>): Prisma__ClassSectionClient<$Result.GetResult<Prisma.$ClassSectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClassSections.
     * @param {ClassSectionDeleteManyArgs} args - Arguments to filter ClassSections to delete.
     * @example
     * // Delete a few ClassSections
     * const { count } = await prisma.classSection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassSectionDeleteManyArgs>(args?: SelectSubset<T, ClassSectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassSections
     * const classSection = await prisma.classSection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassSectionUpdateManyArgs>(args: SelectSubset<T, ClassSectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassSections and returns the data updated in the database.
     * @param {ClassSectionUpdateManyAndReturnArgs} args - Arguments to update many ClassSections.
     * @example
     * // Update many ClassSections
     * const classSection = await prisma.classSection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClassSections and only return the `id`
     * const classSectionWithIdOnly = await prisma.classSection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassSectionUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassSectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClassSection.
     * @param {ClassSectionUpsertArgs} args - Arguments to update or create a ClassSection.
     * @example
     * // Update or create a ClassSection
     * const classSection = await prisma.classSection.upsert({
     *   create: {
     *     // ... data to create a ClassSection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassSection we want to update
     *   }
     * })
     */
    upsert<T extends ClassSectionUpsertArgs>(args: SelectSubset<T, ClassSectionUpsertArgs<ExtArgs>>): Prisma__ClassSectionClient<$Result.GetResult<Prisma.$ClassSectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClassSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSectionCountArgs} args - Arguments to filter ClassSections to count.
     * @example
     * // Count the number of ClassSections
     * const count = await prisma.classSection.count({
     *   where: {
     *     // ... the filter for the ClassSections we want to count
     *   }
     * })
    **/
    count<T extends ClassSectionCountArgs>(
      args?: Subset<T, ClassSectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassSectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassSectionAggregateArgs>(args: Subset<T, ClassSectionAggregateArgs>): Prisma.PrismaPromise<GetClassSectionAggregateType<T>>

    /**
     * Group by ClassSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassSectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassSectionGroupByArgs['orderBy'] }
        : { orderBy?: ClassSectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassSectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassSection model
   */
  readonly fields: ClassSectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassSection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassSectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    grade<T extends GradeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GradeDefaultArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    classes<T extends ClassSection$classesArgs<ExtArgs> = {}>(args?: Subset<T, ClassSection$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassSection model
   */
  interface ClassSectionFieldRefs {
    readonly id: FieldRef<"ClassSection", 'String'>
    readonly name: FieldRef<"ClassSection", 'String'>
    readonly gradeId: FieldRef<"ClassSection", 'String'>
    readonly createdAt: FieldRef<"ClassSection", 'DateTime'>
    readonly updatedAt: FieldRef<"ClassSection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClassSection findUnique
   */
  export type ClassSectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSection
     */
    select?: ClassSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSection
     */
    omit?: ClassSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSectionInclude<ExtArgs> | null
    /**
     * Filter, which ClassSection to fetch.
     */
    where: ClassSectionWhereUniqueInput
  }

  /**
   * ClassSection findUniqueOrThrow
   */
  export type ClassSectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSection
     */
    select?: ClassSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSection
     */
    omit?: ClassSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSectionInclude<ExtArgs> | null
    /**
     * Filter, which ClassSection to fetch.
     */
    where: ClassSectionWhereUniqueInput
  }

  /**
   * ClassSection findFirst
   */
  export type ClassSectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSection
     */
    select?: ClassSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSection
     */
    omit?: ClassSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSectionInclude<ExtArgs> | null
    /**
     * Filter, which ClassSection to fetch.
     */
    where?: ClassSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSections to fetch.
     */
    orderBy?: ClassSectionOrderByWithRelationInput | ClassSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassSections.
     */
    cursor?: ClassSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassSections.
     */
    distinct?: ClassSectionScalarFieldEnum | ClassSectionScalarFieldEnum[]
  }

  /**
   * ClassSection findFirstOrThrow
   */
  export type ClassSectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSection
     */
    select?: ClassSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSection
     */
    omit?: ClassSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSectionInclude<ExtArgs> | null
    /**
     * Filter, which ClassSection to fetch.
     */
    where?: ClassSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSections to fetch.
     */
    orderBy?: ClassSectionOrderByWithRelationInput | ClassSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassSections.
     */
    cursor?: ClassSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassSections.
     */
    distinct?: ClassSectionScalarFieldEnum | ClassSectionScalarFieldEnum[]
  }

  /**
   * ClassSection findMany
   */
  export type ClassSectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSection
     */
    select?: ClassSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSection
     */
    omit?: ClassSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSectionInclude<ExtArgs> | null
    /**
     * Filter, which ClassSections to fetch.
     */
    where?: ClassSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSections to fetch.
     */
    orderBy?: ClassSectionOrderByWithRelationInput | ClassSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassSections.
     */
    cursor?: ClassSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSections.
     */
    skip?: number
    distinct?: ClassSectionScalarFieldEnum | ClassSectionScalarFieldEnum[]
  }

  /**
   * ClassSection create
   */
  export type ClassSectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSection
     */
    select?: ClassSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSection
     */
    omit?: ClassSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSectionInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassSection.
     */
    data: XOR<ClassSectionCreateInput, ClassSectionUncheckedCreateInput>
  }

  /**
   * ClassSection createMany
   */
  export type ClassSectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassSections.
     */
    data: ClassSectionCreateManyInput | ClassSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassSection createManyAndReturn
   */
  export type ClassSectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSection
     */
    select?: ClassSectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSection
     */
    omit?: ClassSectionOmit<ExtArgs> | null
    /**
     * The data used to create many ClassSections.
     */
    data: ClassSectionCreateManyInput | ClassSectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassSection update
   */
  export type ClassSectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSection
     */
    select?: ClassSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSection
     */
    omit?: ClassSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSectionInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassSection.
     */
    data: XOR<ClassSectionUpdateInput, ClassSectionUncheckedUpdateInput>
    /**
     * Choose, which ClassSection to update.
     */
    where: ClassSectionWhereUniqueInput
  }

  /**
   * ClassSection updateMany
   */
  export type ClassSectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassSections.
     */
    data: XOR<ClassSectionUpdateManyMutationInput, ClassSectionUncheckedUpdateManyInput>
    /**
     * Filter which ClassSections to update
     */
    where?: ClassSectionWhereInput
    /**
     * Limit how many ClassSections to update.
     */
    limit?: number
  }

  /**
   * ClassSection updateManyAndReturn
   */
  export type ClassSectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSection
     */
    select?: ClassSectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSection
     */
    omit?: ClassSectionOmit<ExtArgs> | null
    /**
     * The data used to update ClassSections.
     */
    data: XOR<ClassSectionUpdateManyMutationInput, ClassSectionUncheckedUpdateManyInput>
    /**
     * Filter which ClassSections to update
     */
    where?: ClassSectionWhereInput
    /**
     * Limit how many ClassSections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassSection upsert
   */
  export type ClassSectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSection
     */
    select?: ClassSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSection
     */
    omit?: ClassSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSectionInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassSection to update in case it exists.
     */
    where: ClassSectionWhereUniqueInput
    /**
     * In case the ClassSection found by the `where` argument doesn't exist, create a new ClassSection with this data.
     */
    create: XOR<ClassSectionCreateInput, ClassSectionUncheckedCreateInput>
    /**
     * In case the ClassSection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassSectionUpdateInput, ClassSectionUncheckedUpdateInput>
  }

  /**
   * ClassSection delete
   */
  export type ClassSectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSection
     */
    select?: ClassSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSection
     */
    omit?: ClassSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSectionInclude<ExtArgs> | null
    /**
     * Filter which ClassSection to delete.
     */
    where: ClassSectionWhereUniqueInput
  }

  /**
   * ClassSection deleteMany
   */
  export type ClassSectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassSections to delete
     */
    where?: ClassSectionWhereInput
    /**
     * Limit how many ClassSections to delete.
     */
    limit?: number
  }

  /**
   * ClassSection.classes
   */
  export type ClassSection$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * ClassSection without action
   */
  export type ClassSectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSection
     */
    select?: ClassSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSection
     */
    omit?: ClassSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSectionInclude<ExtArgs> | null
  }


  /**
   * Model Grade
   */

  export type AggregateGrade = {
    _count: GradeCountAggregateOutputType | null
    _avg: GradeAvgAggregateOutputType | null
    _sum: GradeSumAggregateOutputType | null
    _min: GradeMinAggregateOutputType | null
    _max: GradeMaxAggregateOutputType | null
  }

  export type GradeAvgAggregateOutputType = {
    level: number | null
  }

  export type GradeSumAggregateOutputType = {
    level: number | null
  }

  export type GradeMinAggregateOutputType = {
    id: string | null
    name: string | null
    level: number | null
  }

  export type GradeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    level: number | null
  }

  export type GradeCountAggregateOutputType = {
    id: number
    name: number
    level: number
    _all: number
  }


  export type GradeAvgAggregateInputType = {
    level?: true
  }

  export type GradeSumAggregateInputType = {
    level?: true
  }

  export type GradeMinAggregateInputType = {
    id?: true
    name?: true
    level?: true
  }

  export type GradeMaxAggregateInputType = {
    id?: true
    name?: true
    level?: true
  }

  export type GradeCountAggregateInputType = {
    id?: true
    name?: true
    level?: true
    _all?: true
  }

  export type GradeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grade to aggregate.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Grades
    **/
    _count?: true | GradeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GradeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GradeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GradeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GradeMaxAggregateInputType
  }

  export type GetGradeAggregateType<T extends GradeAggregateArgs> = {
        [P in keyof T & keyof AggregateGrade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrade[P]>
      : GetScalarType<T[P], AggregateGrade[P]>
  }




  export type GradeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithAggregationInput | GradeOrderByWithAggregationInput[]
    by: GradeScalarFieldEnum[] | GradeScalarFieldEnum
    having?: GradeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GradeCountAggregateInputType | true
    _avg?: GradeAvgAggregateInputType
    _sum?: GradeSumAggregateInputType
    _min?: GradeMinAggregateInputType
    _max?: GradeMaxAggregateInputType
  }

  export type GradeGroupByOutputType = {
    id: string
    name: string
    level: number
    _count: GradeCountAggregateOutputType | null
    _avg: GradeAvgAggregateOutputType | null
    _sum: GradeSumAggregateOutputType | null
    _min: GradeMinAggregateOutputType | null
    _max: GradeMaxAggregateOutputType | null
  }

  type GetGradeGroupByPayload<T extends GradeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GradeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GradeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GradeGroupByOutputType[P]>
            : GetScalarType<T[P], GradeGroupByOutputType[P]>
        }
      >
    >


  export type GradeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    level?: boolean
    classSections?: boolean | Grade$classSectionsArgs<ExtArgs>
    subjects?: boolean | Grade$subjectsArgs<ExtArgs>
    classes?: boolean | Grade$classesArgs<ExtArgs>
    _count?: boolean | GradeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grade"]>

  export type GradeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    level?: boolean
  }, ExtArgs["result"]["grade"]>

  export type GradeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    level?: boolean
  }, ExtArgs["result"]["grade"]>

  export type GradeSelectScalar = {
    id?: boolean
    name?: boolean
    level?: boolean
  }

  export type GradeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "level", ExtArgs["result"]["grade"]>
  export type GradeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classSections?: boolean | Grade$classSectionsArgs<ExtArgs>
    subjects?: boolean | Grade$subjectsArgs<ExtArgs>
    classes?: boolean | Grade$classesArgs<ExtArgs>
    _count?: boolean | GradeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GradeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GradeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GradePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Grade"
    objects: {
      classSections: Prisma.$ClassSectionPayload<ExtArgs>[]
      subjects: Prisma.$SubjectPayload<ExtArgs>[]
      classes: Prisma.$ClassPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      level: number
    }, ExtArgs["result"]["grade"]>
    composites: {}
  }

  type GradeGetPayload<S extends boolean | null | undefined | GradeDefaultArgs> = $Result.GetResult<Prisma.$GradePayload, S>

  type GradeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GradeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GradeCountAggregateInputType | true
    }

  export interface GradeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Grade'], meta: { name: 'Grade' } }
    /**
     * Find zero or one Grade that matches the filter.
     * @param {GradeFindUniqueArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GradeFindUniqueArgs>(args: SelectSubset<T, GradeFindUniqueArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Grade that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GradeFindUniqueOrThrowArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GradeFindUniqueOrThrowArgs>(args: SelectSubset<T, GradeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindFirstArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GradeFindFirstArgs>(args?: SelectSubset<T, GradeFindFirstArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindFirstOrThrowArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GradeFindFirstOrThrowArgs>(args?: SelectSubset<T, GradeFindFirstOrThrowArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Grades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grades
     * const grades = await prisma.grade.findMany()
     * 
     * // Get first 10 Grades
     * const grades = await prisma.grade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gradeWithIdOnly = await prisma.grade.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GradeFindManyArgs>(args?: SelectSubset<T, GradeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Grade.
     * @param {GradeCreateArgs} args - Arguments to create a Grade.
     * @example
     * // Create one Grade
     * const Grade = await prisma.grade.create({
     *   data: {
     *     // ... data to create a Grade
     *   }
     * })
     * 
     */
    create<T extends GradeCreateArgs>(args: SelectSubset<T, GradeCreateArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Grades.
     * @param {GradeCreateManyArgs} args - Arguments to create many Grades.
     * @example
     * // Create many Grades
     * const grade = await prisma.grade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GradeCreateManyArgs>(args?: SelectSubset<T, GradeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Grades and returns the data saved in the database.
     * @param {GradeCreateManyAndReturnArgs} args - Arguments to create many Grades.
     * @example
     * // Create many Grades
     * const grade = await prisma.grade.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Grades and only return the `id`
     * const gradeWithIdOnly = await prisma.grade.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GradeCreateManyAndReturnArgs>(args?: SelectSubset<T, GradeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Grade.
     * @param {GradeDeleteArgs} args - Arguments to delete one Grade.
     * @example
     * // Delete one Grade
     * const Grade = await prisma.grade.delete({
     *   where: {
     *     // ... filter to delete one Grade
     *   }
     * })
     * 
     */
    delete<T extends GradeDeleteArgs>(args: SelectSubset<T, GradeDeleteArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Grade.
     * @param {GradeUpdateArgs} args - Arguments to update one Grade.
     * @example
     * // Update one Grade
     * const grade = await prisma.grade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GradeUpdateArgs>(args: SelectSubset<T, GradeUpdateArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Grades.
     * @param {GradeDeleteManyArgs} args - Arguments to filter Grades to delete.
     * @example
     * // Delete a few Grades
     * const { count } = await prisma.grade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GradeDeleteManyArgs>(args?: SelectSubset<T, GradeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grades
     * const grade = await prisma.grade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GradeUpdateManyArgs>(args: SelectSubset<T, GradeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grades and returns the data updated in the database.
     * @param {GradeUpdateManyAndReturnArgs} args - Arguments to update many Grades.
     * @example
     * // Update many Grades
     * const grade = await prisma.grade.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Grades and only return the `id`
     * const gradeWithIdOnly = await prisma.grade.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GradeUpdateManyAndReturnArgs>(args: SelectSubset<T, GradeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Grade.
     * @param {GradeUpsertArgs} args - Arguments to update or create a Grade.
     * @example
     * // Update or create a Grade
     * const grade = await prisma.grade.upsert({
     *   create: {
     *     // ... data to create a Grade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grade we want to update
     *   }
     * })
     */
    upsert<T extends GradeUpsertArgs>(args: SelectSubset<T, GradeUpsertArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeCountArgs} args - Arguments to filter Grades to count.
     * @example
     * // Count the number of Grades
     * const count = await prisma.grade.count({
     *   where: {
     *     // ... the filter for the Grades we want to count
     *   }
     * })
    **/
    count<T extends GradeCountArgs>(
      args?: Subset<T, GradeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GradeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GradeAggregateArgs>(args: Subset<T, GradeAggregateArgs>): Prisma.PrismaPromise<GetGradeAggregateType<T>>

    /**
     * Group by Grade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GradeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GradeGroupByArgs['orderBy'] }
        : { orderBy?: GradeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GradeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGradeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Grade model
   */
  readonly fields: GradeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Grade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GradeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classSections<T extends Grade$classSectionsArgs<ExtArgs> = {}>(args?: Subset<T, Grade$classSectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subjects<T extends Grade$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, Grade$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classes<T extends Grade$classesArgs<ExtArgs> = {}>(args?: Subset<T, Grade$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Grade model
   */
  interface GradeFieldRefs {
    readonly id: FieldRef<"Grade", 'String'>
    readonly name: FieldRef<"Grade", 'String'>
    readonly level: FieldRef<"Grade", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Grade findUnique
   */
  export type GradeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade findUniqueOrThrow
   */
  export type GradeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade findFirst
   */
  export type GradeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grades.
     */
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade findFirstOrThrow
   */
  export type GradeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grades.
     */
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade findMany
   */
  export type GradeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grades to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade create
   */
  export type GradeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The data needed to create a Grade.
     */
    data: XOR<GradeCreateInput, GradeUncheckedCreateInput>
  }

  /**
   * Grade createMany
   */
  export type GradeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Grades.
     */
    data: GradeCreateManyInput | GradeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Grade createManyAndReturn
   */
  export type GradeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * The data used to create many Grades.
     */
    data: GradeCreateManyInput | GradeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Grade update
   */
  export type GradeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The data needed to update a Grade.
     */
    data: XOR<GradeUpdateInput, GradeUncheckedUpdateInput>
    /**
     * Choose, which Grade to update.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade updateMany
   */
  export type GradeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Grades.
     */
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyInput>
    /**
     * Filter which Grades to update
     */
    where?: GradeWhereInput
    /**
     * Limit how many Grades to update.
     */
    limit?: number
  }

  /**
   * Grade updateManyAndReturn
   */
  export type GradeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * The data used to update Grades.
     */
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyInput>
    /**
     * Filter which Grades to update
     */
    where?: GradeWhereInput
    /**
     * Limit how many Grades to update.
     */
    limit?: number
  }

  /**
   * Grade upsert
   */
  export type GradeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The filter to search for the Grade to update in case it exists.
     */
    where: GradeWhereUniqueInput
    /**
     * In case the Grade found by the `where` argument doesn't exist, create a new Grade with this data.
     */
    create: XOR<GradeCreateInput, GradeUncheckedCreateInput>
    /**
     * In case the Grade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GradeUpdateInput, GradeUncheckedUpdateInput>
  }

  /**
   * Grade delete
   */
  export type GradeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter which Grade to delete.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade deleteMany
   */
  export type GradeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grades to delete
     */
    where?: GradeWhereInput
    /**
     * Limit how many Grades to delete.
     */
    limit?: number
  }

  /**
   * Grade.classSections
   */
  export type Grade$classSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSection
     */
    select?: ClassSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSection
     */
    omit?: ClassSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSectionInclude<ExtArgs> | null
    where?: ClassSectionWhereInput
    orderBy?: ClassSectionOrderByWithRelationInput | ClassSectionOrderByWithRelationInput[]
    cursor?: ClassSectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassSectionScalarFieldEnum | ClassSectionScalarFieldEnum[]
  }

  /**
   * Grade.subjects
   */
  export type Grade$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Grade.classes
   */
  export type Grade$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Grade without action
   */
  export type GradeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
  }


  /**
   * Model Subject
   */

  export type AggregateSubject = {
    _count: SubjectCountAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  export type SubjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    gradeId: string | null
  }

  export type SubjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    gradeId: string | null
  }

  export type SubjectCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    gradeId: number
    _all: number
  }


  export type SubjectMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    gradeId?: true
  }

  export type SubjectMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    gradeId?: true
  }

  export type SubjectCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    gradeId?: true
    _all?: true
  }

  export type SubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subject to aggregate.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subjects
    **/
    _count?: true | SubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectMaxAggregateInputType
  }

  export type GetSubjectAggregateType<T extends SubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject[P]>
      : GetScalarType<T[P], AggregateSubject[P]>
  }




  export type SubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithAggregationInput | SubjectOrderByWithAggregationInput[]
    by: SubjectScalarFieldEnum[] | SubjectScalarFieldEnum
    having?: SubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectCountAggregateInputType | true
    _min?: SubjectMinAggregateInputType
    _max?: SubjectMaxAggregateInputType
  }

  export type SubjectGroupByOutputType = {
    id: string
    name: string
    code: string
    description: string | null
    gradeId: string
    _count: SubjectCountAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  type GetSubjectGroupByPayload<T extends SubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectGroupByOutputType[P]>
        }
      >
    >


  export type SubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    gradeId?: boolean
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    teacherSubjects?: boolean | Subject$teacherSubjectsArgs<ExtArgs>
    classSchedules?: boolean | Subject$classSchedulesArgs<ExtArgs>
    gradeCategories?: boolean | Subject$gradeCategoriesArgs<ExtArgs>
    gradeEntries?: boolean | Subject$gradeEntriesArgs<ExtArgs>
    attendanceRecords?: boolean | Subject$attendanceRecordsArgs<ExtArgs>
    documents?: boolean | Subject$documentsArgs<ExtArgs>
    attendanceSummaries?: boolean | Subject$attendanceSummariesArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    gradeId?: boolean
    grade?: boolean | GradeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    gradeId?: boolean
    grade?: boolean | GradeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    gradeId?: boolean
  }

  export type SubjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "description" | "gradeId", ExtArgs["result"]["subject"]>
  export type SubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    teacherSubjects?: boolean | Subject$teacherSubjectsArgs<ExtArgs>
    classSchedules?: boolean | Subject$classSchedulesArgs<ExtArgs>
    gradeCategories?: boolean | Subject$gradeCategoriesArgs<ExtArgs>
    gradeEntries?: boolean | Subject$gradeEntriesArgs<ExtArgs>
    attendanceRecords?: boolean | Subject$attendanceRecordsArgs<ExtArgs>
    documents?: boolean | Subject$documentsArgs<ExtArgs>
    attendanceSummaries?: boolean | Subject$attendanceSummariesArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grade?: boolean | GradeDefaultArgs<ExtArgs>
  }
  export type SubjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grade?: boolean | GradeDefaultArgs<ExtArgs>
  }

  export type $SubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subject"
    objects: {
      grade: Prisma.$GradePayload<ExtArgs>
      teacherSubjects: Prisma.$TeacherSubjectPayload<ExtArgs>[]
      classSchedules: Prisma.$ClassSchedulePayload<ExtArgs>[]
      gradeCategories: Prisma.$GradeCategoryPayload<ExtArgs>[]
      gradeEntries: Prisma.$GradeEntryPayload<ExtArgs>[]
      attendanceRecords: Prisma.$AttendanceRecordPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      attendanceSummaries: Prisma.$AttendanceSummaryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      description: string | null
      gradeId: string
    }, ExtArgs["result"]["subject"]>
    composites: {}
  }

  type SubjectGetPayload<S extends boolean | null | undefined | SubjectDefaultArgs> = $Result.GetResult<Prisma.$SubjectPayload, S>

  type SubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubjectCountAggregateInputType | true
    }

  export interface SubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subject'], meta: { name: 'Subject' } }
    /**
     * Find zero or one Subject that matches the filter.
     * @param {SubjectFindUniqueArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubjectFindUniqueArgs>(args: SelectSubset<T, SubjectFindUniqueArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubjectFindUniqueOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, SubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubjectFindFirstArgs>(args?: SelectSubset<T, SubjectFindFirstArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, SubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subject.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectWithIdOnly = await prisma.subject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubjectFindManyArgs>(args?: SelectSubset<T, SubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subject.
     * @param {SubjectCreateArgs} args - Arguments to create a Subject.
     * @example
     * // Create one Subject
     * const Subject = await prisma.subject.create({
     *   data: {
     *     // ... data to create a Subject
     *   }
     * })
     * 
     */
    create<T extends SubjectCreateArgs>(args: SelectSubset<T, SubjectCreateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subjects.
     * @param {SubjectCreateManyArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubjectCreateManyArgs>(args?: SelectSubset<T, SubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subjects and returns the data saved in the database.
     * @param {SubjectCreateManyAndReturnArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subjects and only return the `id`
     * const subjectWithIdOnly = await prisma.subject.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubjectCreateManyAndReturnArgs>(args?: SelectSubset<T, SubjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subject.
     * @param {SubjectDeleteArgs} args - Arguments to delete one Subject.
     * @example
     * // Delete one Subject
     * const Subject = await prisma.subject.delete({
     *   where: {
     *     // ... filter to delete one Subject
     *   }
     * })
     * 
     */
    delete<T extends SubjectDeleteArgs>(args: SelectSubset<T, SubjectDeleteArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subject.
     * @param {SubjectUpdateArgs} args - Arguments to update one Subject.
     * @example
     * // Update one Subject
     * const subject = await prisma.subject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubjectUpdateArgs>(args: SelectSubset<T, SubjectUpdateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subjects.
     * @param {SubjectDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubjectDeleteManyArgs>(args?: SelectSubset<T, SubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubjectUpdateManyArgs>(args: SelectSubset<T, SubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects and returns the data updated in the database.
     * @param {SubjectUpdateManyAndReturnArgs} args - Arguments to update many Subjects.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subjects and only return the `id`
     * const subjectWithIdOnly = await prisma.subject.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubjectUpdateManyAndReturnArgs>(args: SelectSubset<T, SubjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subject.
     * @param {SubjectUpsertArgs} args - Arguments to update or create a Subject.
     * @example
     * // Update or create a Subject
     * const subject = await prisma.subject.upsert({
     *   create: {
     *     // ... data to create a Subject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject we want to update
     *   }
     * })
     */
    upsert<T extends SubjectUpsertArgs>(args: SelectSubset<T, SubjectUpsertArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subject.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends SubjectCountArgs>(
      args?: Subset<T, SubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectAggregateArgs>(args: Subset<T, SubjectAggregateArgs>): Prisma.PrismaPromise<GetSubjectAggregateType<T>>

    /**
     * Group by Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectGroupByArgs['orderBy'] }
        : { orderBy?: SubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subject model
   */
  readonly fields: SubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    grade<T extends GradeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GradeDefaultArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teacherSubjects<T extends Subject$teacherSubjectsArgs<ExtArgs> = {}>(args?: Subset<T, Subject$teacherSubjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classSchedules<T extends Subject$classSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Subject$classSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gradeCategories<T extends Subject$gradeCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Subject$gradeCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradeCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gradeEntries<T extends Subject$gradeEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Subject$gradeEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradeEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendanceRecords<T extends Subject$attendanceRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Subject$attendanceRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Subject$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Subject$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendanceSummaries<T extends Subject$attendanceSummariesArgs<ExtArgs> = {}>(args?: Subset<T, Subject$attendanceSummariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subject model
   */
  interface SubjectFieldRefs {
    readonly id: FieldRef<"Subject", 'String'>
    readonly name: FieldRef<"Subject", 'String'>
    readonly code: FieldRef<"Subject", 'String'>
    readonly description: FieldRef<"Subject", 'String'>
    readonly gradeId: FieldRef<"Subject", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Subject findUnique
   */
  export type SubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findUniqueOrThrow
   */
  export type SubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findFirst
   */
  export type SubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findFirstOrThrow
   */
  export type SubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findMany
   */
  export type SubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subjects to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject create
   */
  export type SubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Subject.
     */
    data: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
  }

  /**
   * Subject createMany
   */
  export type SubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subject createManyAndReturn
   */
  export type SubjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subject update
   */
  export type SubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Subject.
     */
    data: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
    /**
     * Choose, which Subject to update.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject updateMany
   */
  export type SubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to update.
     */
    limit?: number
  }

  /**
   * Subject updateManyAndReturn
   */
  export type SubjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subject upsert
   */
  export type SubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Subject to update in case it exists.
     */
    where: SubjectWhereUniqueInput
    /**
     * In case the Subject found by the `where` argument doesn't exist, create a new Subject with this data.
     */
    create: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
    /**
     * In case the Subject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
  }

  /**
   * Subject delete
   */
  export type SubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter which Subject to delete.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject deleteMany
   */
  export type SubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subjects to delete
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to delete.
     */
    limit?: number
  }

  /**
   * Subject.teacherSubjects
   */
  export type Subject$teacherSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherSubject
     */
    omit?: TeacherSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    where?: TeacherSubjectWhereInput
    orderBy?: TeacherSubjectOrderByWithRelationInput | TeacherSubjectOrderByWithRelationInput[]
    cursor?: TeacherSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherSubjectScalarFieldEnum | TeacherSubjectScalarFieldEnum[]
  }

  /**
   * Subject.classSchedules
   */
  export type Subject$classSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSchedule
     */
    omit?: ClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleInclude<ExtArgs> | null
    where?: ClassScheduleWhereInput
    orderBy?: ClassScheduleOrderByWithRelationInput | ClassScheduleOrderByWithRelationInput[]
    cursor?: ClassScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScheduleScalarFieldEnum | ClassScheduleScalarFieldEnum[]
  }

  /**
   * Subject.gradeCategories
   */
  export type Subject$gradeCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeCategory
     */
    select?: GradeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeCategory
     */
    omit?: GradeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeCategoryInclude<ExtArgs> | null
    where?: GradeCategoryWhereInput
    orderBy?: GradeCategoryOrderByWithRelationInput | GradeCategoryOrderByWithRelationInput[]
    cursor?: GradeCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeCategoryScalarFieldEnum | GradeCategoryScalarFieldEnum[]
  }

  /**
   * Subject.gradeEntries
   */
  export type Subject$gradeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeEntry
     */
    select?: GradeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeEntry
     */
    omit?: GradeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeEntryInclude<ExtArgs> | null
    where?: GradeEntryWhereInput
    orderBy?: GradeEntryOrderByWithRelationInput | GradeEntryOrderByWithRelationInput[]
    cursor?: GradeEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeEntryScalarFieldEnum | GradeEntryScalarFieldEnum[]
  }

  /**
   * Subject.attendanceRecords
   */
  export type Subject$attendanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    where?: AttendanceRecordWhereInput
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    cursor?: AttendanceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * Subject.documents
   */
  export type Subject$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Subject.attendanceSummaries
   */
  export type Subject$attendanceSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    where?: AttendanceSummaryWhereInput
    orderBy?: AttendanceSummaryOrderByWithRelationInput | AttendanceSummaryOrderByWithRelationInput[]
    cursor?: AttendanceSummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceSummaryScalarFieldEnum | AttendanceSummaryScalarFieldEnum[]
  }

  /**
   * Subject without action
   */
  export type SubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
  }


  /**
   * Model Class
   */

  export type AggregateClass = {
    _count: ClassCountAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  export type ClassMinAggregateOutputType = {
    id: string | null
    gradeId: string | null
    classSectionId: string | null
    academicYearId: string | null
  }

  export type ClassMaxAggregateOutputType = {
    id: string | null
    gradeId: string | null
    classSectionId: string | null
    academicYearId: string | null
  }

  export type ClassCountAggregateOutputType = {
    id: number
    gradeId: number
    classSectionId: number
    academicYearId: number
    _all: number
  }


  export type ClassMinAggregateInputType = {
    id?: true
    gradeId?: true
    classSectionId?: true
    academicYearId?: true
  }

  export type ClassMaxAggregateInputType = {
    id?: true
    gradeId?: true
    classSectionId?: true
    academicYearId?: true
  }

  export type ClassCountAggregateInputType = {
    id?: true
    gradeId?: true
    classSectionId?: true
    academicYearId?: true
    _all?: true
  }

  export type ClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Class to aggregate.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassMaxAggregateInputType
  }

  export type GetClassAggregateType<T extends ClassAggregateArgs> = {
        [P in keyof T & keyof AggregateClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass[P]>
      : GetScalarType<T[P], AggregateClass[P]>
  }




  export type ClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithAggregationInput | ClassOrderByWithAggregationInput[]
    by: ClassScalarFieldEnum[] | ClassScalarFieldEnum
    having?: ClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassCountAggregateInputType | true
    _min?: ClassMinAggregateInputType
    _max?: ClassMaxAggregateInputType
  }

  export type ClassGroupByOutputType = {
    id: string
    gradeId: string
    classSectionId: string
    academicYearId: string
    _count: ClassCountAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  type GetClassGroupByPayload<T extends ClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassGroupByOutputType[P]>
            : GetScalarType<T[P], ClassGroupByOutputType[P]>
        }
      >
    >


  export type ClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gradeId?: boolean
    classSectionId?: boolean
    academicYearId?: boolean
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    classSection?: boolean | ClassSectionDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
    teacherSubjects?: boolean | Class$teacherSubjectsArgs<ExtArgs>
    studentEnrollments?: boolean | Class$studentEnrollmentsArgs<ExtArgs>
    classSchedules?: boolean | Class$classSchedulesArgs<ExtArgs>
    attendanceRecords?: boolean | Class$attendanceRecordsArgs<ExtArgs>
    documents?: boolean | Class$documentsArgs<ExtArgs>
    gradeCategories?: boolean | Class$gradeCategoriesArgs<ExtArgs>
    gradeEntries?: boolean | Class$gradeEntriesArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gradeId?: boolean
    classSectionId?: boolean
    academicYearId?: boolean
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    classSection?: boolean | ClassSectionDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gradeId?: boolean
    classSectionId?: boolean
    academicYearId?: boolean
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    classSection?: boolean | ClassSectionDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectScalar = {
    id?: boolean
    gradeId?: boolean
    classSectionId?: boolean
    academicYearId?: boolean
  }

  export type ClassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gradeId" | "classSectionId" | "academicYearId", ExtArgs["result"]["class"]>
  export type ClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    classSection?: boolean | ClassSectionDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
    teacherSubjects?: boolean | Class$teacherSubjectsArgs<ExtArgs>
    studentEnrollments?: boolean | Class$studentEnrollmentsArgs<ExtArgs>
    classSchedules?: boolean | Class$classSchedulesArgs<ExtArgs>
    attendanceRecords?: boolean | Class$attendanceRecordsArgs<ExtArgs>
    documents?: boolean | Class$documentsArgs<ExtArgs>
    gradeCategories?: boolean | Class$gradeCategoriesArgs<ExtArgs>
    gradeEntries?: boolean | Class$gradeEntriesArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    classSection?: boolean | ClassSectionDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
  }
  export type ClassIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grade?: boolean | GradeDefaultArgs<ExtArgs>
    classSection?: boolean | ClassSectionDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
  }

  export type $ClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Class"
    objects: {
      grade: Prisma.$GradePayload<ExtArgs>
      classSection: Prisma.$ClassSectionPayload<ExtArgs>
      academicYear: Prisma.$AcademicYearPayload<ExtArgs>
      teacherSubjects: Prisma.$TeacherSubjectPayload<ExtArgs>[]
      studentEnrollments: Prisma.$StudentEnrollmentPayload<ExtArgs>[]
      classSchedules: Prisma.$ClassSchedulePayload<ExtArgs>[]
      attendanceRecords: Prisma.$AttendanceRecordPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      gradeCategories: Prisma.$GradeCategoryPayload<ExtArgs>[]
      gradeEntries: Prisma.$GradeEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gradeId: string
      classSectionId: string
      academicYearId: string
    }, ExtArgs["result"]["class"]>
    composites: {}
  }

  type ClassGetPayload<S extends boolean | null | undefined | ClassDefaultArgs> = $Result.GetResult<Prisma.$ClassPayload, S>

  type ClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassCountAggregateInputType | true
    }

  export interface ClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Class'], meta: { name: 'Class' } }
    /**
     * Find zero or one Class that matches the filter.
     * @param {ClassFindUniqueArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassFindUniqueArgs>(args: SelectSubset<T, ClassFindUniqueArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Class that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassFindUniqueOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassFindFirstArgs>(args?: SelectSubset<T, ClassFindFirstArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.class.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.class.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classWithIdOnly = await prisma.class.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassFindManyArgs>(args?: SelectSubset<T, ClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Class.
     * @param {ClassCreateArgs} args - Arguments to create a Class.
     * @example
     * // Create one Class
     * const Class = await prisma.class.create({
     *   data: {
     *     // ... data to create a Class
     *   }
     * })
     * 
     */
    create<T extends ClassCreateArgs>(args: SelectSubset<T, ClassCreateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Classes.
     * @param {ClassCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassCreateManyArgs>(args?: SelectSubset<T, ClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Classes and returns the data saved in the database.
     * @param {ClassCreateManyAndReturnArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Class.
     * @param {ClassDeleteArgs} args - Arguments to delete one Class.
     * @example
     * // Delete one Class
     * const Class = await prisma.class.delete({
     *   where: {
     *     // ... filter to delete one Class
     *   }
     * })
     * 
     */
    delete<T extends ClassDeleteArgs>(args: SelectSubset<T, ClassDeleteArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Class.
     * @param {ClassUpdateArgs} args - Arguments to update one Class.
     * @example
     * // Update one Class
     * const class = await prisma.class.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassUpdateArgs>(args: SelectSubset<T, ClassUpdateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Classes.
     * @param {ClassDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.class.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassDeleteManyArgs>(args?: SelectSubset<T, ClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassUpdateManyArgs>(args: SelectSubset<T, ClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes and returns the data updated in the database.
     * @param {ClassUpdateManyAndReturnArgs} args - Arguments to update many Classes.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Class.
     * @param {ClassUpsertArgs} args - Arguments to update or create a Class.
     * @example
     * // Update or create a Class
     * const class = await prisma.class.upsert({
     *   create: {
     *     // ... data to create a Class
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class we want to update
     *   }
     * })
     */
    upsert<T extends ClassUpsertArgs>(args: SelectSubset<T, ClassUpsertArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.class.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClassCountArgs>(
      args?: Subset<T, ClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassAggregateArgs>(args: Subset<T, ClassAggregateArgs>): Prisma.PrismaPromise<GetClassAggregateType<T>>

    /**
     * Group by Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassGroupByArgs['orderBy'] }
        : { orderBy?: ClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Class model
   */
  readonly fields: ClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Class.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    grade<T extends GradeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GradeDefaultArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    classSection<T extends ClassSectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassSectionDefaultArgs<ExtArgs>>): Prisma__ClassSectionClient<$Result.GetResult<Prisma.$ClassSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicYear<T extends AcademicYearDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicYearDefaultArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teacherSubjects<T extends Class$teacherSubjectsArgs<ExtArgs> = {}>(args?: Subset<T, Class$teacherSubjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentEnrollments<T extends Class$studentEnrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Class$studentEnrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classSchedules<T extends Class$classSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Class$classSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendanceRecords<T extends Class$attendanceRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Class$attendanceRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Class$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Class$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gradeCategories<T extends Class$gradeCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Class$gradeCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradeCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gradeEntries<T extends Class$gradeEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Class$gradeEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradeEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Class model
   */
  interface ClassFieldRefs {
    readonly id: FieldRef<"Class", 'String'>
    readonly gradeId: FieldRef<"Class", 'String'>
    readonly classSectionId: FieldRef<"Class", 'String'>
    readonly academicYearId: FieldRef<"Class", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Class findUnique
   */
  export type ClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findUniqueOrThrow
   */
  export type ClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findFirst
   */
  export type ClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findFirstOrThrow
   */
  export type ClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findMany
   */
  export type ClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class create
   */
  export type ClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to create a Class.
     */
    data: XOR<ClassCreateInput, ClassUncheckedCreateInput>
  }

  /**
   * Class createMany
   */
  export type ClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Class createManyAndReturn
   */
  export type ClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Class update
   */
  export type ClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to update a Class.
     */
    data: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
    /**
     * Choose, which Class to update.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class updateMany
   */
  export type ClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
  }

  /**
   * Class updateManyAndReturn
   */
  export type ClassUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Class upsert
   */
  export type ClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The filter to search for the Class to update in case it exists.
     */
    where: ClassWhereUniqueInput
    /**
     * In case the Class found by the `where` argument doesn't exist, create a new Class with this data.
     */
    create: XOR<ClassCreateInput, ClassUncheckedCreateInput>
    /**
     * In case the Class was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
  }

  /**
   * Class delete
   */
  export type ClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter which Class to delete.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class deleteMany
   */
  export type ClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to delete.
     */
    limit?: number
  }

  /**
   * Class.teacherSubjects
   */
  export type Class$teacherSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherSubject
     */
    omit?: TeacherSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    where?: TeacherSubjectWhereInput
    orderBy?: TeacherSubjectOrderByWithRelationInput | TeacherSubjectOrderByWithRelationInput[]
    cursor?: TeacherSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherSubjectScalarFieldEnum | TeacherSubjectScalarFieldEnum[]
  }

  /**
   * Class.studentEnrollments
   */
  export type Class$studentEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    where?: StudentEnrollmentWhereInput
    orderBy?: StudentEnrollmentOrderByWithRelationInput | StudentEnrollmentOrderByWithRelationInput[]
    cursor?: StudentEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentEnrollmentScalarFieldEnum | StudentEnrollmentScalarFieldEnum[]
  }

  /**
   * Class.classSchedules
   */
  export type Class$classSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSchedule
     */
    omit?: ClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleInclude<ExtArgs> | null
    where?: ClassScheduleWhereInput
    orderBy?: ClassScheduleOrderByWithRelationInput | ClassScheduleOrderByWithRelationInput[]
    cursor?: ClassScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScheduleScalarFieldEnum | ClassScheduleScalarFieldEnum[]
  }

  /**
   * Class.attendanceRecords
   */
  export type Class$attendanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    where?: AttendanceRecordWhereInput
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    cursor?: AttendanceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * Class.documents
   */
  export type Class$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Class.gradeCategories
   */
  export type Class$gradeCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeCategory
     */
    select?: GradeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeCategory
     */
    omit?: GradeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeCategoryInclude<ExtArgs> | null
    where?: GradeCategoryWhereInput
    orderBy?: GradeCategoryOrderByWithRelationInput | GradeCategoryOrderByWithRelationInput[]
    cursor?: GradeCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeCategoryScalarFieldEnum | GradeCategoryScalarFieldEnum[]
  }

  /**
   * Class.gradeEntries
   */
  export type Class$gradeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeEntry
     */
    select?: GradeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeEntry
     */
    omit?: GradeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeEntryInclude<ExtArgs> | null
    where?: GradeEntryWhereInput
    orderBy?: GradeEntryOrderByWithRelationInput | GradeEntryOrderByWithRelationInput[]
    cursor?: GradeEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeEntryScalarFieldEnum | GradeEntryScalarFieldEnum[]
  }

  /**
   * Class without action
   */
  export type ClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
  }


  /**
   * Model TeacherSubject
   */

  export type AggregateTeacherSubject = {
    _count: TeacherSubjectCountAggregateOutputType | null
    _min: TeacherSubjectMinAggregateOutputType | null
    _max: TeacherSubjectMaxAggregateOutputType | null
  }

  export type TeacherSubjectMinAggregateOutputType = {
    id: string | null
    teacherId: string | null
    subjectId: string | null
    classId: string | null
    academicYearId: string | null
  }

  export type TeacherSubjectMaxAggregateOutputType = {
    id: string | null
    teacherId: string | null
    subjectId: string | null
    classId: string | null
    academicYearId: string | null
  }

  export type TeacherSubjectCountAggregateOutputType = {
    id: number
    teacherId: number
    subjectId: number
    classId: number
    academicYearId: number
    _all: number
  }


  export type TeacherSubjectMinAggregateInputType = {
    id?: true
    teacherId?: true
    subjectId?: true
    classId?: true
    academicYearId?: true
  }

  export type TeacherSubjectMaxAggregateInputType = {
    id?: true
    teacherId?: true
    subjectId?: true
    classId?: true
    academicYearId?: true
  }

  export type TeacherSubjectCountAggregateInputType = {
    id?: true
    teacherId?: true
    subjectId?: true
    classId?: true
    academicYearId?: true
    _all?: true
  }

  export type TeacherSubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherSubject to aggregate.
     */
    where?: TeacherSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherSubjects to fetch.
     */
    orderBy?: TeacherSubjectOrderByWithRelationInput | TeacherSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeacherSubjects
    **/
    _count?: true | TeacherSubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherSubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherSubjectMaxAggregateInputType
  }

  export type GetTeacherSubjectAggregateType<T extends TeacherSubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacherSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacherSubject[P]>
      : GetScalarType<T[P], AggregateTeacherSubject[P]>
  }




  export type TeacherSubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherSubjectWhereInput
    orderBy?: TeacherSubjectOrderByWithAggregationInput | TeacherSubjectOrderByWithAggregationInput[]
    by: TeacherSubjectScalarFieldEnum[] | TeacherSubjectScalarFieldEnum
    having?: TeacherSubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherSubjectCountAggregateInputType | true
    _min?: TeacherSubjectMinAggregateInputType
    _max?: TeacherSubjectMaxAggregateInputType
  }

  export type TeacherSubjectGroupByOutputType = {
    id: string
    teacherId: string
    subjectId: string
    classId: string
    academicYearId: string
    _count: TeacherSubjectCountAggregateOutputType | null
    _min: TeacherSubjectMinAggregateOutputType | null
    _max: TeacherSubjectMaxAggregateOutputType | null
  }

  type GetTeacherSubjectGroupByPayload<T extends TeacherSubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherSubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherSubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherSubjectGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherSubjectGroupByOutputType[P]>
        }
      >
    >


  export type TeacherSubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    subjectId?: boolean
    classId?: boolean
    academicYearId?: boolean
    teacher?: boolean | UserDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherSubject"]>

  export type TeacherSubjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    subjectId?: boolean
    classId?: boolean
    academicYearId?: boolean
    teacher?: boolean | UserDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherSubject"]>

  export type TeacherSubjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    subjectId?: boolean
    classId?: boolean
    academicYearId?: boolean
    teacher?: boolean | UserDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherSubject"]>

  export type TeacherSubjectSelectScalar = {
    id?: boolean
    teacherId?: boolean
    subjectId?: boolean
    classId?: boolean
    academicYearId?: boolean
  }

  export type TeacherSubjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teacherId" | "subjectId" | "classId" | "academicYearId", ExtArgs["result"]["teacherSubject"]>
  export type TeacherSubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | UserDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
  }
  export type TeacherSubjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | UserDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
  }
  export type TeacherSubjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | UserDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
  }

  export type $TeacherSubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeacherSubject"
    objects: {
      teacher: Prisma.$UserPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
      academicYear: Prisma.$AcademicYearPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teacherId: string
      subjectId: string
      classId: string
      academicYearId: string
    }, ExtArgs["result"]["teacherSubject"]>
    composites: {}
  }

  type TeacherSubjectGetPayload<S extends boolean | null | undefined | TeacherSubjectDefaultArgs> = $Result.GetResult<Prisma.$TeacherSubjectPayload, S>

  type TeacherSubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeacherSubjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeacherSubjectCountAggregateInputType | true
    }

  export interface TeacherSubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeacherSubject'], meta: { name: 'TeacherSubject' } }
    /**
     * Find zero or one TeacherSubject that matches the filter.
     * @param {TeacherSubjectFindUniqueArgs} args - Arguments to find a TeacherSubject
     * @example
     * // Get one TeacherSubject
     * const teacherSubject = await prisma.teacherSubject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherSubjectFindUniqueArgs>(args: SelectSubset<T, TeacherSubjectFindUniqueArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeacherSubject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeacherSubjectFindUniqueOrThrowArgs} args - Arguments to find a TeacherSubject
     * @example
     * // Get one TeacherSubject
     * const teacherSubject = await prisma.teacherSubject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherSubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherSubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeacherSubject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherSubjectFindFirstArgs} args - Arguments to find a TeacherSubject
     * @example
     * // Get one TeacherSubject
     * const teacherSubject = await prisma.teacherSubject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherSubjectFindFirstArgs>(args?: SelectSubset<T, TeacherSubjectFindFirstArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeacherSubject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherSubjectFindFirstOrThrowArgs} args - Arguments to find a TeacherSubject
     * @example
     * // Get one TeacherSubject
     * const teacherSubject = await prisma.teacherSubject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherSubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherSubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeacherSubjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherSubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeacherSubjects
     * const teacherSubjects = await prisma.teacherSubject.findMany()
     * 
     * // Get first 10 TeacherSubjects
     * const teacherSubjects = await prisma.teacherSubject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherSubjectWithIdOnly = await prisma.teacherSubject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeacherSubjectFindManyArgs>(args?: SelectSubset<T, TeacherSubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeacherSubject.
     * @param {TeacherSubjectCreateArgs} args - Arguments to create a TeacherSubject.
     * @example
     * // Create one TeacherSubject
     * const TeacherSubject = await prisma.teacherSubject.create({
     *   data: {
     *     // ... data to create a TeacherSubject
     *   }
     * })
     * 
     */
    create<T extends TeacherSubjectCreateArgs>(args: SelectSubset<T, TeacherSubjectCreateArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeacherSubjects.
     * @param {TeacherSubjectCreateManyArgs} args - Arguments to create many TeacherSubjects.
     * @example
     * // Create many TeacherSubjects
     * const teacherSubject = await prisma.teacherSubject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherSubjectCreateManyArgs>(args?: SelectSubset<T, TeacherSubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeacherSubjects and returns the data saved in the database.
     * @param {TeacherSubjectCreateManyAndReturnArgs} args - Arguments to create many TeacherSubjects.
     * @example
     * // Create many TeacherSubjects
     * const teacherSubject = await prisma.teacherSubject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeacherSubjects and only return the `id`
     * const teacherSubjectWithIdOnly = await prisma.teacherSubject.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeacherSubjectCreateManyAndReturnArgs>(args?: SelectSubset<T, TeacherSubjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeacherSubject.
     * @param {TeacherSubjectDeleteArgs} args - Arguments to delete one TeacherSubject.
     * @example
     * // Delete one TeacherSubject
     * const TeacherSubject = await prisma.teacherSubject.delete({
     *   where: {
     *     // ... filter to delete one TeacherSubject
     *   }
     * })
     * 
     */
    delete<T extends TeacherSubjectDeleteArgs>(args: SelectSubset<T, TeacherSubjectDeleteArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeacherSubject.
     * @param {TeacherSubjectUpdateArgs} args - Arguments to update one TeacherSubject.
     * @example
     * // Update one TeacherSubject
     * const teacherSubject = await prisma.teacherSubject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherSubjectUpdateArgs>(args: SelectSubset<T, TeacherSubjectUpdateArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeacherSubjects.
     * @param {TeacherSubjectDeleteManyArgs} args - Arguments to filter TeacherSubjects to delete.
     * @example
     * // Delete a few TeacherSubjects
     * const { count } = await prisma.teacherSubject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherSubjectDeleteManyArgs>(args?: SelectSubset<T, TeacherSubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherSubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeacherSubjects
     * const teacherSubject = await prisma.teacherSubject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherSubjectUpdateManyArgs>(args: SelectSubset<T, TeacherSubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherSubjects and returns the data updated in the database.
     * @param {TeacherSubjectUpdateManyAndReturnArgs} args - Arguments to update many TeacherSubjects.
     * @example
     * // Update many TeacherSubjects
     * const teacherSubject = await prisma.teacherSubject.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeacherSubjects and only return the `id`
     * const teacherSubjectWithIdOnly = await prisma.teacherSubject.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeacherSubjectUpdateManyAndReturnArgs>(args: SelectSubset<T, TeacherSubjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeacherSubject.
     * @param {TeacherSubjectUpsertArgs} args - Arguments to update or create a TeacherSubject.
     * @example
     * // Update or create a TeacherSubject
     * const teacherSubject = await prisma.teacherSubject.upsert({
     *   create: {
     *     // ... data to create a TeacherSubject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeacherSubject we want to update
     *   }
     * })
     */
    upsert<T extends TeacherSubjectUpsertArgs>(args: SelectSubset<T, TeacherSubjectUpsertArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeacherSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherSubjectCountArgs} args - Arguments to filter TeacherSubjects to count.
     * @example
     * // Count the number of TeacherSubjects
     * const count = await prisma.teacherSubject.count({
     *   where: {
     *     // ... the filter for the TeacherSubjects we want to count
     *   }
     * })
    **/
    count<T extends TeacherSubjectCountArgs>(
      args?: Subset<T, TeacherSubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherSubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeacherSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherSubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherSubjectAggregateArgs>(args: Subset<T, TeacherSubjectAggregateArgs>): Prisma.PrismaPromise<GetTeacherSubjectAggregateType<T>>

    /**
     * Group by TeacherSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherSubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherSubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherSubjectGroupByArgs['orderBy'] }
        : { orderBy?: TeacherSubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherSubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeacherSubject model
   */
  readonly fields: TeacherSubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeacherSubject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherSubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicYear<T extends AcademicYearDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicYearDefaultArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeacherSubject model
   */
  interface TeacherSubjectFieldRefs {
    readonly id: FieldRef<"TeacherSubject", 'String'>
    readonly teacherId: FieldRef<"TeacherSubject", 'String'>
    readonly subjectId: FieldRef<"TeacherSubject", 'String'>
    readonly classId: FieldRef<"TeacherSubject", 'String'>
    readonly academicYearId: FieldRef<"TeacherSubject", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TeacherSubject findUnique
   */
  export type TeacherSubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherSubject
     */
    omit?: TeacherSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * Filter, which TeacherSubject to fetch.
     */
    where: TeacherSubjectWhereUniqueInput
  }

  /**
   * TeacherSubject findUniqueOrThrow
   */
  export type TeacherSubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherSubject
     */
    omit?: TeacherSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * Filter, which TeacherSubject to fetch.
     */
    where: TeacherSubjectWhereUniqueInput
  }

  /**
   * TeacherSubject findFirst
   */
  export type TeacherSubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherSubject
     */
    omit?: TeacherSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * Filter, which TeacherSubject to fetch.
     */
    where?: TeacherSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherSubjects to fetch.
     */
    orderBy?: TeacherSubjectOrderByWithRelationInput | TeacherSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherSubjects.
     */
    cursor?: TeacherSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherSubjects.
     */
    distinct?: TeacherSubjectScalarFieldEnum | TeacherSubjectScalarFieldEnum[]
  }

  /**
   * TeacherSubject findFirstOrThrow
   */
  export type TeacherSubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherSubject
     */
    omit?: TeacherSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * Filter, which TeacherSubject to fetch.
     */
    where?: TeacherSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherSubjects to fetch.
     */
    orderBy?: TeacherSubjectOrderByWithRelationInput | TeacherSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherSubjects.
     */
    cursor?: TeacherSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherSubjects.
     */
    distinct?: TeacherSubjectScalarFieldEnum | TeacherSubjectScalarFieldEnum[]
  }

  /**
   * TeacherSubject findMany
   */
  export type TeacherSubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherSubject
     */
    omit?: TeacherSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * Filter, which TeacherSubjects to fetch.
     */
    where?: TeacherSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherSubjects to fetch.
     */
    orderBy?: TeacherSubjectOrderByWithRelationInput | TeacherSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeacherSubjects.
     */
    cursor?: TeacherSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherSubjects.
     */
    skip?: number
    distinct?: TeacherSubjectScalarFieldEnum | TeacherSubjectScalarFieldEnum[]
  }

  /**
   * TeacherSubject create
   */
  export type TeacherSubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherSubject
     */
    omit?: TeacherSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a TeacherSubject.
     */
    data: XOR<TeacherSubjectCreateInput, TeacherSubjectUncheckedCreateInput>
  }

  /**
   * TeacherSubject createMany
   */
  export type TeacherSubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeacherSubjects.
     */
    data: TeacherSubjectCreateManyInput | TeacherSubjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeacherSubject createManyAndReturn
   */
  export type TeacherSubjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherSubject
     */
    omit?: TeacherSubjectOmit<ExtArgs> | null
    /**
     * The data used to create many TeacherSubjects.
     */
    data: TeacherSubjectCreateManyInput | TeacherSubjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeacherSubject update
   */
  export type TeacherSubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherSubject
     */
    omit?: TeacherSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a TeacherSubject.
     */
    data: XOR<TeacherSubjectUpdateInput, TeacherSubjectUncheckedUpdateInput>
    /**
     * Choose, which TeacherSubject to update.
     */
    where: TeacherSubjectWhereUniqueInput
  }

  /**
   * TeacherSubject updateMany
   */
  export type TeacherSubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeacherSubjects.
     */
    data: XOR<TeacherSubjectUpdateManyMutationInput, TeacherSubjectUncheckedUpdateManyInput>
    /**
     * Filter which TeacherSubjects to update
     */
    where?: TeacherSubjectWhereInput
    /**
     * Limit how many TeacherSubjects to update.
     */
    limit?: number
  }

  /**
   * TeacherSubject updateManyAndReturn
   */
  export type TeacherSubjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherSubject
     */
    omit?: TeacherSubjectOmit<ExtArgs> | null
    /**
     * The data used to update TeacherSubjects.
     */
    data: XOR<TeacherSubjectUpdateManyMutationInput, TeacherSubjectUncheckedUpdateManyInput>
    /**
     * Filter which TeacherSubjects to update
     */
    where?: TeacherSubjectWhereInput
    /**
     * Limit how many TeacherSubjects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeacherSubject upsert
   */
  export type TeacherSubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherSubject
     */
    omit?: TeacherSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the TeacherSubject to update in case it exists.
     */
    where: TeacherSubjectWhereUniqueInput
    /**
     * In case the TeacherSubject found by the `where` argument doesn't exist, create a new TeacherSubject with this data.
     */
    create: XOR<TeacherSubjectCreateInput, TeacherSubjectUncheckedCreateInput>
    /**
     * In case the TeacherSubject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherSubjectUpdateInput, TeacherSubjectUncheckedUpdateInput>
  }

  /**
   * TeacherSubject delete
   */
  export type TeacherSubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherSubject
     */
    omit?: TeacherSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * Filter which TeacherSubject to delete.
     */
    where: TeacherSubjectWhereUniqueInput
  }

  /**
   * TeacherSubject deleteMany
   */
  export type TeacherSubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherSubjects to delete
     */
    where?: TeacherSubjectWhereInput
    /**
     * Limit how many TeacherSubjects to delete.
     */
    limit?: number
  }

  /**
   * TeacherSubject without action
   */
  export type TeacherSubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherSubject
     */
    omit?: TeacherSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
  }


  /**
   * Model StudentEnrollment
   */

  export type AggregateStudentEnrollment = {
    _count: StudentEnrollmentCountAggregateOutputType | null
    _min: StudentEnrollmentMinAggregateOutputType | null
    _max: StudentEnrollmentMaxAggregateOutputType | null
  }

  export type StudentEnrollmentMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    classId: string | null
    academicYearId: string | null
    semesterId: string | null
    enrollmentDate: Date | null
  }

  export type StudentEnrollmentMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    classId: string | null
    academicYearId: string | null
    semesterId: string | null
    enrollmentDate: Date | null
  }

  export type StudentEnrollmentCountAggregateOutputType = {
    id: number
    studentId: number
    classId: number
    academicYearId: number
    semesterId: number
    enrollmentDate: number
    _all: number
  }


  export type StudentEnrollmentMinAggregateInputType = {
    id?: true
    studentId?: true
    classId?: true
    academicYearId?: true
    semesterId?: true
    enrollmentDate?: true
  }

  export type StudentEnrollmentMaxAggregateInputType = {
    id?: true
    studentId?: true
    classId?: true
    academicYearId?: true
    semesterId?: true
    enrollmentDate?: true
  }

  export type StudentEnrollmentCountAggregateInputType = {
    id?: true
    studentId?: true
    classId?: true
    academicYearId?: true
    semesterId?: true
    enrollmentDate?: true
    _all?: true
  }

  export type StudentEnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentEnrollment to aggregate.
     */
    where?: StudentEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrollments to fetch.
     */
    orderBy?: StudentEnrollmentOrderByWithRelationInput | StudentEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentEnrollments
    **/
    _count?: true | StudentEnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentEnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentEnrollmentMaxAggregateInputType
  }

  export type GetStudentEnrollmentAggregateType<T extends StudentEnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentEnrollment[P]>
      : GetScalarType<T[P], AggregateStudentEnrollment[P]>
  }




  export type StudentEnrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEnrollmentWhereInput
    orderBy?: StudentEnrollmentOrderByWithAggregationInput | StudentEnrollmentOrderByWithAggregationInput[]
    by: StudentEnrollmentScalarFieldEnum[] | StudentEnrollmentScalarFieldEnum
    having?: StudentEnrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentEnrollmentCountAggregateInputType | true
    _min?: StudentEnrollmentMinAggregateInputType
    _max?: StudentEnrollmentMaxAggregateInputType
  }

  export type StudentEnrollmentGroupByOutputType = {
    id: string
    studentId: string
    classId: string
    academicYearId: string
    semesterId: string | null
    enrollmentDate: Date
    _count: StudentEnrollmentCountAggregateOutputType | null
    _min: StudentEnrollmentMinAggregateOutputType | null
    _max: StudentEnrollmentMaxAggregateOutputType | null
  }

  type GetStudentEnrollmentGroupByPayload<T extends StudentEnrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentEnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentEnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentEnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentEnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type StudentEnrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    classId?: boolean
    academicYearId?: boolean
    semesterId?: boolean
    enrollmentDate?: boolean
    student?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
    semester?: boolean | StudentEnrollment$semesterArgs<ExtArgs>
  }, ExtArgs["result"]["studentEnrollment"]>

  export type StudentEnrollmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    classId?: boolean
    academicYearId?: boolean
    semesterId?: boolean
    enrollmentDate?: boolean
    student?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
    semester?: boolean | StudentEnrollment$semesterArgs<ExtArgs>
  }, ExtArgs["result"]["studentEnrollment"]>

  export type StudentEnrollmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    classId?: boolean
    academicYearId?: boolean
    semesterId?: boolean
    enrollmentDate?: boolean
    student?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
    semester?: boolean | StudentEnrollment$semesterArgs<ExtArgs>
  }, ExtArgs["result"]["studentEnrollment"]>

  export type StudentEnrollmentSelectScalar = {
    id?: boolean
    studentId?: boolean
    classId?: boolean
    academicYearId?: boolean
    semesterId?: boolean
    enrollmentDate?: boolean
  }

  export type StudentEnrollmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "classId" | "academicYearId" | "semesterId" | "enrollmentDate", ExtArgs["result"]["studentEnrollment"]>
  export type StudentEnrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
    semester?: boolean | StudentEnrollment$semesterArgs<ExtArgs>
  }
  export type StudentEnrollmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
    semester?: boolean | StudentEnrollment$semesterArgs<ExtArgs>
  }
  export type StudentEnrollmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
    semester?: boolean | StudentEnrollment$semesterArgs<ExtArgs>
  }

  export type $StudentEnrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentEnrollment"
    objects: {
      student: Prisma.$UserPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
      academicYear: Prisma.$AcademicYearPayload<ExtArgs>
      semester: Prisma.$SemesterPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      classId: string
      academicYearId: string
      semesterId: string | null
      enrollmentDate: Date
    }, ExtArgs["result"]["studentEnrollment"]>
    composites: {}
  }

  type StudentEnrollmentGetPayload<S extends boolean | null | undefined | StudentEnrollmentDefaultArgs> = $Result.GetResult<Prisma.$StudentEnrollmentPayload, S>

  type StudentEnrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentEnrollmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentEnrollmentCountAggregateInputType | true
    }

  export interface StudentEnrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentEnrollment'], meta: { name: 'StudentEnrollment' } }
    /**
     * Find zero or one StudentEnrollment that matches the filter.
     * @param {StudentEnrollmentFindUniqueArgs} args - Arguments to find a StudentEnrollment
     * @example
     * // Get one StudentEnrollment
     * const studentEnrollment = await prisma.studentEnrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentEnrollmentFindUniqueArgs>(args: SelectSubset<T, StudentEnrollmentFindUniqueArgs<ExtArgs>>): Prisma__StudentEnrollmentClient<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentEnrollment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentEnrollmentFindUniqueOrThrowArgs} args - Arguments to find a StudentEnrollment
     * @example
     * // Get one StudentEnrollment
     * const studentEnrollment = await prisma.studentEnrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentEnrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentEnrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentEnrollmentClient<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentEnrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrollmentFindFirstArgs} args - Arguments to find a StudentEnrollment
     * @example
     * // Get one StudentEnrollment
     * const studentEnrollment = await prisma.studentEnrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentEnrollmentFindFirstArgs>(args?: SelectSubset<T, StudentEnrollmentFindFirstArgs<ExtArgs>>): Prisma__StudentEnrollmentClient<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentEnrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrollmentFindFirstOrThrowArgs} args - Arguments to find a StudentEnrollment
     * @example
     * // Get one StudentEnrollment
     * const studentEnrollment = await prisma.studentEnrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentEnrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentEnrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentEnrollmentClient<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentEnrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentEnrollments
     * const studentEnrollments = await prisma.studentEnrollment.findMany()
     * 
     * // Get first 10 StudentEnrollments
     * const studentEnrollments = await prisma.studentEnrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentEnrollmentWithIdOnly = await prisma.studentEnrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentEnrollmentFindManyArgs>(args?: SelectSubset<T, StudentEnrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentEnrollment.
     * @param {StudentEnrollmentCreateArgs} args - Arguments to create a StudentEnrollment.
     * @example
     * // Create one StudentEnrollment
     * const StudentEnrollment = await prisma.studentEnrollment.create({
     *   data: {
     *     // ... data to create a StudentEnrollment
     *   }
     * })
     * 
     */
    create<T extends StudentEnrollmentCreateArgs>(args: SelectSubset<T, StudentEnrollmentCreateArgs<ExtArgs>>): Prisma__StudentEnrollmentClient<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentEnrollments.
     * @param {StudentEnrollmentCreateManyArgs} args - Arguments to create many StudentEnrollments.
     * @example
     * // Create many StudentEnrollments
     * const studentEnrollment = await prisma.studentEnrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentEnrollmentCreateManyArgs>(args?: SelectSubset<T, StudentEnrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentEnrollments and returns the data saved in the database.
     * @param {StudentEnrollmentCreateManyAndReturnArgs} args - Arguments to create many StudentEnrollments.
     * @example
     * // Create many StudentEnrollments
     * const studentEnrollment = await prisma.studentEnrollment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentEnrollments and only return the `id`
     * const studentEnrollmentWithIdOnly = await prisma.studentEnrollment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentEnrollmentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentEnrollmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentEnrollment.
     * @param {StudentEnrollmentDeleteArgs} args - Arguments to delete one StudentEnrollment.
     * @example
     * // Delete one StudentEnrollment
     * const StudentEnrollment = await prisma.studentEnrollment.delete({
     *   where: {
     *     // ... filter to delete one StudentEnrollment
     *   }
     * })
     * 
     */
    delete<T extends StudentEnrollmentDeleteArgs>(args: SelectSubset<T, StudentEnrollmentDeleteArgs<ExtArgs>>): Prisma__StudentEnrollmentClient<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentEnrollment.
     * @param {StudentEnrollmentUpdateArgs} args - Arguments to update one StudentEnrollment.
     * @example
     * // Update one StudentEnrollment
     * const studentEnrollment = await prisma.studentEnrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentEnrollmentUpdateArgs>(args: SelectSubset<T, StudentEnrollmentUpdateArgs<ExtArgs>>): Prisma__StudentEnrollmentClient<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentEnrollments.
     * @param {StudentEnrollmentDeleteManyArgs} args - Arguments to filter StudentEnrollments to delete.
     * @example
     * // Delete a few StudentEnrollments
     * const { count } = await prisma.studentEnrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentEnrollmentDeleteManyArgs>(args?: SelectSubset<T, StudentEnrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentEnrollments
     * const studentEnrollment = await prisma.studentEnrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentEnrollmentUpdateManyArgs>(args: SelectSubset<T, StudentEnrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentEnrollments and returns the data updated in the database.
     * @param {StudentEnrollmentUpdateManyAndReturnArgs} args - Arguments to update many StudentEnrollments.
     * @example
     * // Update many StudentEnrollments
     * const studentEnrollment = await prisma.studentEnrollment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentEnrollments and only return the `id`
     * const studentEnrollmentWithIdOnly = await prisma.studentEnrollment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentEnrollmentUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentEnrollmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentEnrollment.
     * @param {StudentEnrollmentUpsertArgs} args - Arguments to update or create a StudentEnrollment.
     * @example
     * // Update or create a StudentEnrollment
     * const studentEnrollment = await prisma.studentEnrollment.upsert({
     *   create: {
     *     // ... data to create a StudentEnrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentEnrollment we want to update
     *   }
     * })
     */
    upsert<T extends StudentEnrollmentUpsertArgs>(args: SelectSubset<T, StudentEnrollmentUpsertArgs<ExtArgs>>): Prisma__StudentEnrollmentClient<$Result.GetResult<Prisma.$StudentEnrollmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrollmentCountArgs} args - Arguments to filter StudentEnrollments to count.
     * @example
     * // Count the number of StudentEnrollments
     * const count = await prisma.studentEnrollment.count({
     *   where: {
     *     // ... the filter for the StudentEnrollments we want to count
     *   }
     * })
    **/
    count<T extends StudentEnrollmentCountArgs>(
      args?: Subset<T, StudentEnrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentEnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentEnrollmentAggregateArgs>(args: Subset<T, StudentEnrollmentAggregateArgs>): Prisma.PrismaPromise<GetStudentEnrollmentAggregateType<T>>

    /**
     * Group by StudentEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentEnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentEnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: StudentEnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentEnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentEnrollment model
   */
  readonly fields: StudentEnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentEnrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentEnrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicYear<T extends AcademicYearDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicYearDefaultArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    semester<T extends StudentEnrollment$semesterArgs<ExtArgs> = {}>(args?: Subset<T, StudentEnrollment$semesterArgs<ExtArgs>>): Prisma__SemesterClient<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentEnrollment model
   */
  interface StudentEnrollmentFieldRefs {
    readonly id: FieldRef<"StudentEnrollment", 'String'>
    readonly studentId: FieldRef<"StudentEnrollment", 'String'>
    readonly classId: FieldRef<"StudentEnrollment", 'String'>
    readonly academicYearId: FieldRef<"StudentEnrollment", 'String'>
    readonly semesterId: FieldRef<"StudentEnrollment", 'String'>
    readonly enrollmentDate: FieldRef<"StudentEnrollment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentEnrollment findUnique
   */
  export type StudentEnrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrollment to fetch.
     */
    where: StudentEnrollmentWhereUniqueInput
  }

  /**
   * StudentEnrollment findUniqueOrThrow
   */
  export type StudentEnrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrollment to fetch.
     */
    where: StudentEnrollmentWhereUniqueInput
  }

  /**
   * StudentEnrollment findFirst
   */
  export type StudentEnrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrollment to fetch.
     */
    where?: StudentEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrollments to fetch.
     */
    orderBy?: StudentEnrollmentOrderByWithRelationInput | StudentEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentEnrollments.
     */
    cursor?: StudentEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentEnrollments.
     */
    distinct?: StudentEnrollmentScalarFieldEnum | StudentEnrollmentScalarFieldEnum[]
  }

  /**
   * StudentEnrollment findFirstOrThrow
   */
  export type StudentEnrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrollment to fetch.
     */
    where?: StudentEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrollments to fetch.
     */
    orderBy?: StudentEnrollmentOrderByWithRelationInput | StudentEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentEnrollments.
     */
    cursor?: StudentEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentEnrollments.
     */
    distinct?: StudentEnrollmentScalarFieldEnum | StudentEnrollmentScalarFieldEnum[]
  }

  /**
   * StudentEnrollment findMany
   */
  export type StudentEnrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrollments to fetch.
     */
    where?: StudentEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrollments to fetch.
     */
    orderBy?: StudentEnrollmentOrderByWithRelationInput | StudentEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentEnrollments.
     */
    cursor?: StudentEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrollments.
     */
    skip?: number
    distinct?: StudentEnrollmentScalarFieldEnum | StudentEnrollmentScalarFieldEnum[]
  }

  /**
   * StudentEnrollment create
   */
  export type StudentEnrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentEnrollment.
     */
    data: XOR<StudentEnrollmentCreateInput, StudentEnrollmentUncheckedCreateInput>
  }

  /**
   * StudentEnrollment createMany
   */
  export type StudentEnrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentEnrollments.
     */
    data: StudentEnrollmentCreateManyInput | StudentEnrollmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentEnrollment createManyAndReturn
   */
  export type StudentEnrollmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * The data used to create many StudentEnrollments.
     */
    data: StudentEnrollmentCreateManyInput | StudentEnrollmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentEnrollment update
   */
  export type StudentEnrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentEnrollment.
     */
    data: XOR<StudentEnrollmentUpdateInput, StudentEnrollmentUncheckedUpdateInput>
    /**
     * Choose, which StudentEnrollment to update.
     */
    where: StudentEnrollmentWhereUniqueInput
  }

  /**
   * StudentEnrollment updateMany
   */
  export type StudentEnrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentEnrollments.
     */
    data: XOR<StudentEnrollmentUpdateManyMutationInput, StudentEnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which StudentEnrollments to update
     */
    where?: StudentEnrollmentWhereInput
    /**
     * Limit how many StudentEnrollments to update.
     */
    limit?: number
  }

  /**
   * StudentEnrollment updateManyAndReturn
   */
  export type StudentEnrollmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * The data used to update StudentEnrollments.
     */
    data: XOR<StudentEnrollmentUpdateManyMutationInput, StudentEnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which StudentEnrollments to update
     */
    where?: StudentEnrollmentWhereInput
    /**
     * Limit how many StudentEnrollments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentEnrollment upsert
   */
  export type StudentEnrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentEnrollment to update in case it exists.
     */
    where: StudentEnrollmentWhereUniqueInput
    /**
     * In case the StudentEnrollment found by the `where` argument doesn't exist, create a new StudentEnrollment with this data.
     */
    create: XOR<StudentEnrollmentCreateInput, StudentEnrollmentUncheckedCreateInput>
    /**
     * In case the StudentEnrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentEnrollmentUpdateInput, StudentEnrollmentUncheckedUpdateInput>
  }

  /**
   * StudentEnrollment delete
   */
  export type StudentEnrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
    /**
     * Filter which StudentEnrollment to delete.
     */
    where: StudentEnrollmentWhereUniqueInput
  }

  /**
   * StudentEnrollment deleteMany
   */
  export type StudentEnrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentEnrollments to delete
     */
    where?: StudentEnrollmentWhereInput
    /**
     * Limit how many StudentEnrollments to delete.
     */
    limit?: number
  }

  /**
   * StudentEnrollment.semester
   */
  export type StudentEnrollment$semesterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semester
     */
    select?: SemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Semester
     */
    omit?: SemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterInclude<ExtArgs> | null
    where?: SemesterWhereInput
  }

  /**
   * StudentEnrollment without action
   */
  export type StudentEnrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrollment
     */
    select?: StudentEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrollment
     */
    omit?: StudentEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrollmentInclude<ExtArgs> | null
  }


  /**
   * Model ClassSchedule
   */

  export type AggregateClassSchedule = {
    _count: ClassScheduleCountAggregateOutputType | null
    _avg: ClassScheduleAvgAggregateOutputType | null
    _sum: ClassScheduleSumAggregateOutputType | null
    _min: ClassScheduleMinAggregateOutputType | null
    _max: ClassScheduleMaxAggregateOutputType | null
  }

  export type ClassScheduleAvgAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type ClassScheduleSumAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type ClassScheduleMinAggregateOutputType = {
    id: string | null
    classId: string | null
    subjectId: string | null
    teacherId: string | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
  }

  export type ClassScheduleMaxAggregateOutputType = {
    id: string | null
    classId: string | null
    subjectId: string | null
    teacherId: string | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
  }

  export type ClassScheduleCountAggregateOutputType = {
    id: number
    classId: number
    subjectId: number
    teacherId: number
    dayOfWeek: number
    startTime: number
    endTime: number
    _all: number
  }


  export type ClassScheduleAvgAggregateInputType = {
    dayOfWeek?: true
  }

  export type ClassScheduleSumAggregateInputType = {
    dayOfWeek?: true
  }

  export type ClassScheduleMinAggregateInputType = {
    id?: true
    classId?: true
    subjectId?: true
    teacherId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
  }

  export type ClassScheduleMaxAggregateInputType = {
    id?: true
    classId?: true
    subjectId?: true
    teacherId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
  }

  export type ClassScheduleCountAggregateInputType = {
    id?: true
    classId?: true
    subjectId?: true
    teacherId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    _all?: true
  }

  export type ClassScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassSchedule to aggregate.
     */
    where?: ClassScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSchedules to fetch.
     */
    orderBy?: ClassScheduleOrderByWithRelationInput | ClassScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassSchedules
    **/
    _count?: true | ClassScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassScheduleMaxAggregateInputType
  }

  export type GetClassScheduleAggregateType<T extends ClassScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateClassSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassSchedule[P]>
      : GetScalarType<T[P], AggregateClassSchedule[P]>
  }




  export type ClassScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassScheduleWhereInput
    orderBy?: ClassScheduleOrderByWithAggregationInput | ClassScheduleOrderByWithAggregationInput[]
    by: ClassScheduleScalarFieldEnum[] | ClassScheduleScalarFieldEnum
    having?: ClassScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassScheduleCountAggregateInputType | true
    _avg?: ClassScheduleAvgAggregateInputType
    _sum?: ClassScheduleSumAggregateInputType
    _min?: ClassScheduleMinAggregateInputType
    _max?: ClassScheduleMaxAggregateInputType
  }

  export type ClassScheduleGroupByOutputType = {
    id: string
    classId: string
    subjectId: string
    teacherId: string
    dayOfWeek: number
    startTime: string
    endTime: string
    _count: ClassScheduleCountAggregateOutputType | null
    _avg: ClassScheduleAvgAggregateOutputType | null
    _sum: ClassScheduleSumAggregateOutputType | null
    _min: ClassScheduleMinAggregateOutputType | null
    _max: ClassScheduleMaxAggregateOutputType | null
  }

  type GetClassScheduleGroupByPayload<T extends ClassScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], ClassScheduleGroupByOutputType[P]>
        }
      >
    >


  export type ClassScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    subjectId?: boolean
    teacherId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    teacher?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classSchedule"]>

  export type ClassScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    subjectId?: boolean
    teacherId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    teacher?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classSchedule"]>

  export type ClassScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    subjectId?: boolean
    teacherId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    teacher?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classSchedule"]>

  export type ClassScheduleSelectScalar = {
    id?: boolean
    classId?: boolean
    subjectId?: boolean
    teacherId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
  }

  export type ClassScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "classId" | "subjectId" | "teacherId" | "dayOfWeek" | "startTime" | "endTime", ExtArgs["result"]["classSchedule"]>
  export type ClassScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    teacher?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClassScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    teacher?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClassScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    teacher?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClassSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassSchedule"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
      teacher: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      classId: string
      subjectId: string
      teacherId: string
      dayOfWeek: number
      startTime: string
      endTime: string
    }, ExtArgs["result"]["classSchedule"]>
    composites: {}
  }

  type ClassScheduleGetPayload<S extends boolean | null | undefined | ClassScheduleDefaultArgs> = $Result.GetResult<Prisma.$ClassSchedulePayload, S>

  type ClassScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassScheduleCountAggregateInputType | true
    }

  export interface ClassScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassSchedule'], meta: { name: 'ClassSchedule' } }
    /**
     * Find zero or one ClassSchedule that matches the filter.
     * @param {ClassScheduleFindUniqueArgs} args - Arguments to find a ClassSchedule
     * @example
     * // Get one ClassSchedule
     * const classSchedule = await prisma.classSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassScheduleFindUniqueArgs>(args: SelectSubset<T, ClassScheduleFindUniqueArgs<ExtArgs>>): Prisma__ClassScheduleClient<$Result.GetResult<Prisma.$ClassSchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClassSchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassScheduleFindUniqueOrThrowArgs} args - Arguments to find a ClassSchedule
     * @example
     * // Get one ClassSchedule
     * const classSchedule = await prisma.classSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassScheduleClient<$Result.GetResult<Prisma.$ClassSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassScheduleFindFirstArgs} args - Arguments to find a ClassSchedule
     * @example
     * // Get one ClassSchedule
     * const classSchedule = await prisma.classSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassScheduleFindFirstArgs>(args?: SelectSubset<T, ClassScheduleFindFirstArgs<ExtArgs>>): Prisma__ClassScheduleClient<$Result.GetResult<Prisma.$ClassSchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassScheduleFindFirstOrThrowArgs} args - Arguments to find a ClassSchedule
     * @example
     * // Get one ClassSchedule
     * const classSchedule = await prisma.classSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassScheduleClient<$Result.GetResult<Prisma.$ClassSchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClassSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassSchedules
     * const classSchedules = await prisma.classSchedule.findMany()
     * 
     * // Get first 10 ClassSchedules
     * const classSchedules = await prisma.classSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classScheduleWithIdOnly = await prisma.classSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassScheduleFindManyArgs>(args?: SelectSubset<T, ClassScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClassSchedule.
     * @param {ClassScheduleCreateArgs} args - Arguments to create a ClassSchedule.
     * @example
     * // Create one ClassSchedule
     * const ClassSchedule = await prisma.classSchedule.create({
     *   data: {
     *     // ... data to create a ClassSchedule
     *   }
     * })
     * 
     */
    create<T extends ClassScheduleCreateArgs>(args: SelectSubset<T, ClassScheduleCreateArgs<ExtArgs>>): Prisma__ClassScheduleClient<$Result.GetResult<Prisma.$ClassSchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClassSchedules.
     * @param {ClassScheduleCreateManyArgs} args - Arguments to create many ClassSchedules.
     * @example
     * // Create many ClassSchedules
     * const classSchedule = await prisma.classSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassScheduleCreateManyArgs>(args?: SelectSubset<T, ClassScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClassSchedules and returns the data saved in the database.
     * @param {ClassScheduleCreateManyAndReturnArgs} args - Arguments to create many ClassSchedules.
     * @example
     * // Create many ClassSchedules
     * const classSchedule = await prisma.classSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClassSchedules and only return the `id`
     * const classScheduleWithIdOnly = await prisma.classSchedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClassSchedule.
     * @param {ClassScheduleDeleteArgs} args - Arguments to delete one ClassSchedule.
     * @example
     * // Delete one ClassSchedule
     * const ClassSchedule = await prisma.classSchedule.delete({
     *   where: {
     *     // ... filter to delete one ClassSchedule
     *   }
     * })
     * 
     */
    delete<T extends ClassScheduleDeleteArgs>(args: SelectSubset<T, ClassScheduleDeleteArgs<ExtArgs>>): Prisma__ClassScheduleClient<$Result.GetResult<Prisma.$ClassSchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClassSchedule.
     * @param {ClassScheduleUpdateArgs} args - Arguments to update one ClassSchedule.
     * @example
     * // Update one ClassSchedule
     * const classSchedule = await prisma.classSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassScheduleUpdateArgs>(args: SelectSubset<T, ClassScheduleUpdateArgs<ExtArgs>>): Prisma__ClassScheduleClient<$Result.GetResult<Prisma.$ClassSchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClassSchedules.
     * @param {ClassScheduleDeleteManyArgs} args - Arguments to filter ClassSchedules to delete.
     * @example
     * // Delete a few ClassSchedules
     * const { count } = await prisma.classSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassScheduleDeleteManyArgs>(args?: SelectSubset<T, ClassScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassSchedules
     * const classSchedule = await prisma.classSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassScheduleUpdateManyArgs>(args: SelectSubset<T, ClassScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassSchedules and returns the data updated in the database.
     * @param {ClassScheduleUpdateManyAndReturnArgs} args - Arguments to update many ClassSchedules.
     * @example
     * // Update many ClassSchedules
     * const classSchedule = await prisma.classSchedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClassSchedules and only return the `id`
     * const classScheduleWithIdOnly = await prisma.classSchedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClassSchedule.
     * @param {ClassScheduleUpsertArgs} args - Arguments to update or create a ClassSchedule.
     * @example
     * // Update or create a ClassSchedule
     * const classSchedule = await prisma.classSchedule.upsert({
     *   create: {
     *     // ... data to create a ClassSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassSchedule we want to update
     *   }
     * })
     */
    upsert<T extends ClassScheduleUpsertArgs>(args: SelectSubset<T, ClassScheduleUpsertArgs<ExtArgs>>): Prisma__ClassScheduleClient<$Result.GetResult<Prisma.$ClassSchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClassSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassScheduleCountArgs} args - Arguments to filter ClassSchedules to count.
     * @example
     * // Count the number of ClassSchedules
     * const count = await prisma.classSchedule.count({
     *   where: {
     *     // ... the filter for the ClassSchedules we want to count
     *   }
     * })
    **/
    count<T extends ClassScheduleCountArgs>(
      args?: Subset<T, ClassScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassScheduleAggregateArgs>(args: Subset<T, ClassScheduleAggregateArgs>): Prisma.PrismaPromise<GetClassScheduleAggregateType<T>>

    /**
     * Group by ClassSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ClassScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassSchedule model
   */
  readonly fields: ClassScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teacher<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassSchedule model
   */
  interface ClassScheduleFieldRefs {
    readonly id: FieldRef<"ClassSchedule", 'String'>
    readonly classId: FieldRef<"ClassSchedule", 'String'>
    readonly subjectId: FieldRef<"ClassSchedule", 'String'>
    readonly teacherId: FieldRef<"ClassSchedule", 'String'>
    readonly dayOfWeek: FieldRef<"ClassSchedule", 'Int'>
    readonly startTime: FieldRef<"ClassSchedule", 'String'>
    readonly endTime: FieldRef<"ClassSchedule", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClassSchedule findUnique
   */
  export type ClassScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSchedule
     */
    omit?: ClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ClassSchedule to fetch.
     */
    where: ClassScheduleWhereUniqueInput
  }

  /**
   * ClassSchedule findUniqueOrThrow
   */
  export type ClassScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSchedule
     */
    omit?: ClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ClassSchedule to fetch.
     */
    where: ClassScheduleWhereUniqueInput
  }

  /**
   * ClassSchedule findFirst
   */
  export type ClassScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSchedule
     */
    omit?: ClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ClassSchedule to fetch.
     */
    where?: ClassScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSchedules to fetch.
     */
    orderBy?: ClassScheduleOrderByWithRelationInput | ClassScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassSchedules.
     */
    cursor?: ClassScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassSchedules.
     */
    distinct?: ClassScheduleScalarFieldEnum | ClassScheduleScalarFieldEnum[]
  }

  /**
   * ClassSchedule findFirstOrThrow
   */
  export type ClassScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSchedule
     */
    omit?: ClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ClassSchedule to fetch.
     */
    where?: ClassScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSchedules to fetch.
     */
    orderBy?: ClassScheduleOrderByWithRelationInput | ClassScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassSchedules.
     */
    cursor?: ClassScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassSchedules.
     */
    distinct?: ClassScheduleScalarFieldEnum | ClassScheduleScalarFieldEnum[]
  }

  /**
   * ClassSchedule findMany
   */
  export type ClassScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSchedule
     */
    omit?: ClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ClassSchedules to fetch.
     */
    where?: ClassScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSchedules to fetch.
     */
    orderBy?: ClassScheduleOrderByWithRelationInput | ClassScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassSchedules.
     */
    cursor?: ClassScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSchedules.
     */
    skip?: number
    distinct?: ClassScheduleScalarFieldEnum | ClassScheduleScalarFieldEnum[]
  }

  /**
   * ClassSchedule create
   */
  export type ClassScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSchedule
     */
    omit?: ClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassSchedule.
     */
    data: XOR<ClassScheduleCreateInput, ClassScheduleUncheckedCreateInput>
  }

  /**
   * ClassSchedule createMany
   */
  export type ClassScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassSchedules.
     */
    data: ClassScheduleCreateManyInput | ClassScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassSchedule createManyAndReturn
   */
  export type ClassScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSchedule
     */
    omit?: ClassScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many ClassSchedules.
     */
    data: ClassScheduleCreateManyInput | ClassScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassSchedule update
   */
  export type ClassScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSchedule
     */
    omit?: ClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassSchedule.
     */
    data: XOR<ClassScheduleUpdateInput, ClassScheduleUncheckedUpdateInput>
    /**
     * Choose, which ClassSchedule to update.
     */
    where: ClassScheduleWhereUniqueInput
  }

  /**
   * ClassSchedule updateMany
   */
  export type ClassScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassSchedules.
     */
    data: XOR<ClassScheduleUpdateManyMutationInput, ClassScheduleUncheckedUpdateManyInput>
    /**
     * Filter which ClassSchedules to update
     */
    where?: ClassScheduleWhereInput
    /**
     * Limit how many ClassSchedules to update.
     */
    limit?: number
  }

  /**
   * ClassSchedule updateManyAndReturn
   */
  export type ClassScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSchedule
     */
    omit?: ClassScheduleOmit<ExtArgs> | null
    /**
     * The data used to update ClassSchedules.
     */
    data: XOR<ClassScheduleUpdateManyMutationInput, ClassScheduleUncheckedUpdateManyInput>
    /**
     * Filter which ClassSchedules to update
     */
    where?: ClassScheduleWhereInput
    /**
     * Limit how many ClassSchedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassSchedule upsert
   */
  export type ClassScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSchedule
     */
    omit?: ClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassSchedule to update in case it exists.
     */
    where: ClassScheduleWhereUniqueInput
    /**
     * In case the ClassSchedule found by the `where` argument doesn't exist, create a new ClassSchedule with this data.
     */
    create: XOR<ClassScheduleCreateInput, ClassScheduleUncheckedCreateInput>
    /**
     * In case the ClassSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassScheduleUpdateInput, ClassScheduleUncheckedUpdateInput>
  }

  /**
   * ClassSchedule delete
   */
  export type ClassScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSchedule
     */
    omit?: ClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleInclude<ExtArgs> | null
    /**
     * Filter which ClassSchedule to delete.
     */
    where: ClassScheduleWhereUniqueInput
  }

  /**
   * ClassSchedule deleteMany
   */
  export type ClassScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassSchedules to delete
     */
    where?: ClassScheduleWhereInput
    /**
     * Limit how many ClassSchedules to delete.
     */
    limit?: number
  }

  /**
   * ClassSchedule without action
   */
  export type ClassScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSchedule
     */
    select?: ClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassSchedule
     */
    omit?: ClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassScheduleInclude<ExtArgs> | null
  }


  /**
   * Model AttendanceRecord
   */

  export type AggregateAttendanceRecord = {
    _count: AttendanceRecordCountAggregateOutputType | null
    _avg: AttendanceRecordAvgAggregateOutputType | null
    _sum: AttendanceRecordSumAggregateOutputType | null
    _min: AttendanceRecordMinAggregateOutputType | null
    _max: AttendanceRecordMaxAggregateOutputType | null
  }

  export type AttendanceRecordAvgAggregateOutputType = {
    period: number | null
  }

  export type AttendanceRecordSumAggregateOutputType = {
    period: number | null
  }

  export type AttendanceRecordMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    classId: string | null
    subjectId: string | null
    date: Date | null
    period: number | null
    status: $Enums.AttendanceStatus | null
    markedById: string | null
    markedAt: Date | null
    remarks: string | null
  }

  export type AttendanceRecordMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    classId: string | null
    subjectId: string | null
    date: Date | null
    period: number | null
    status: $Enums.AttendanceStatus | null
    markedById: string | null
    markedAt: Date | null
    remarks: string | null
  }

  export type AttendanceRecordCountAggregateOutputType = {
    id: number
    studentId: number
    classId: number
    subjectId: number
    date: number
    period: number
    status: number
    markedById: number
    markedAt: number
    remarks: number
    _all: number
  }


  export type AttendanceRecordAvgAggregateInputType = {
    period?: true
  }

  export type AttendanceRecordSumAggregateInputType = {
    period?: true
  }

  export type AttendanceRecordMinAggregateInputType = {
    id?: true
    studentId?: true
    classId?: true
    subjectId?: true
    date?: true
    period?: true
    status?: true
    markedById?: true
    markedAt?: true
    remarks?: true
  }

  export type AttendanceRecordMaxAggregateInputType = {
    id?: true
    studentId?: true
    classId?: true
    subjectId?: true
    date?: true
    period?: true
    status?: true
    markedById?: true
    markedAt?: true
    remarks?: true
  }

  export type AttendanceRecordCountAggregateInputType = {
    id?: true
    studentId?: true
    classId?: true
    subjectId?: true
    date?: true
    period?: true
    status?: true
    markedById?: true
    markedAt?: true
    remarks?: true
    _all?: true
  }

  export type AttendanceRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceRecord to aggregate.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceRecords
    **/
    _count?: true | AttendanceRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceRecordMaxAggregateInputType
  }

  export type GetAttendanceRecordAggregateType<T extends AttendanceRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceRecord[P]>
      : GetScalarType<T[P], AggregateAttendanceRecord[P]>
  }




  export type AttendanceRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceRecordWhereInput
    orderBy?: AttendanceRecordOrderByWithAggregationInput | AttendanceRecordOrderByWithAggregationInput[]
    by: AttendanceRecordScalarFieldEnum[] | AttendanceRecordScalarFieldEnum
    having?: AttendanceRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceRecordCountAggregateInputType | true
    _avg?: AttendanceRecordAvgAggregateInputType
    _sum?: AttendanceRecordSumAggregateInputType
    _min?: AttendanceRecordMinAggregateInputType
    _max?: AttendanceRecordMaxAggregateInputType
  }

  export type AttendanceRecordGroupByOutputType = {
    id: string
    studentId: string
    classId: string
    subjectId: string
    date: Date
    period: number | null
    status: $Enums.AttendanceStatus
    markedById: string
    markedAt: Date
    remarks: string | null
    _count: AttendanceRecordCountAggregateOutputType | null
    _avg: AttendanceRecordAvgAggregateOutputType | null
    _sum: AttendanceRecordSumAggregateOutputType | null
    _min: AttendanceRecordMinAggregateOutputType | null
    _max: AttendanceRecordMaxAggregateOutputType | null
  }

  type GetAttendanceRecordGroupByPayload<T extends AttendanceRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceRecordGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceRecordGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    classId?: boolean
    subjectId?: boolean
    date?: boolean
    period?: boolean
    status?: boolean
    markedById?: boolean
    markedAt?: boolean
    remarks?: boolean
    student?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    markedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceRecord"]>

  export type AttendanceRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    classId?: boolean
    subjectId?: boolean
    date?: boolean
    period?: boolean
    status?: boolean
    markedById?: boolean
    markedAt?: boolean
    remarks?: boolean
    student?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    markedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceRecord"]>

  export type AttendanceRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    classId?: boolean
    subjectId?: boolean
    date?: boolean
    period?: boolean
    status?: boolean
    markedById?: boolean
    markedAt?: boolean
    remarks?: boolean
    student?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    markedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceRecord"]>

  export type AttendanceRecordSelectScalar = {
    id?: boolean
    studentId?: boolean
    classId?: boolean
    subjectId?: boolean
    date?: boolean
    period?: boolean
    status?: boolean
    markedById?: boolean
    markedAt?: boolean
    remarks?: boolean
  }

  export type AttendanceRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "classId" | "subjectId" | "date" | "period" | "status" | "markedById" | "markedAt" | "remarks", ExtArgs["result"]["attendanceRecord"]>
  export type AttendanceRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    markedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AttendanceRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    markedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AttendanceRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    markedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AttendanceRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceRecord"
    objects: {
      student: Prisma.$UserPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
      markedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      classId: string
      subjectId: string
      date: Date
      period: number | null
      status: $Enums.AttendanceStatus
      markedById: string
      markedAt: Date
      remarks: string | null
    }, ExtArgs["result"]["attendanceRecord"]>
    composites: {}
  }

  type AttendanceRecordGetPayload<S extends boolean | null | undefined | AttendanceRecordDefaultArgs> = $Result.GetResult<Prisma.$AttendanceRecordPayload, S>

  type AttendanceRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceRecordCountAggregateInputType | true
    }

  export interface AttendanceRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceRecord'], meta: { name: 'AttendanceRecord' } }
    /**
     * Find zero or one AttendanceRecord that matches the filter.
     * @param {AttendanceRecordFindUniqueArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceRecordFindUniqueArgs>(args: SelectSubset<T, AttendanceRecordFindUniqueArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AttendanceRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceRecordFindUniqueOrThrowArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordFindFirstArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceRecordFindFirstArgs>(args?: SelectSubset<T, AttendanceRecordFindFirstArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordFindFirstOrThrowArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AttendanceRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceRecords
     * const attendanceRecords = await prisma.attendanceRecord.findMany()
     * 
     * // Get first 10 AttendanceRecords
     * const attendanceRecords = await prisma.attendanceRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceRecordWithIdOnly = await prisma.attendanceRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceRecordFindManyArgs>(args?: SelectSubset<T, AttendanceRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AttendanceRecord.
     * @param {AttendanceRecordCreateArgs} args - Arguments to create a AttendanceRecord.
     * @example
     * // Create one AttendanceRecord
     * const AttendanceRecord = await prisma.attendanceRecord.create({
     *   data: {
     *     // ... data to create a AttendanceRecord
     *   }
     * })
     * 
     */
    create<T extends AttendanceRecordCreateArgs>(args: SelectSubset<T, AttendanceRecordCreateArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AttendanceRecords.
     * @param {AttendanceRecordCreateManyArgs} args - Arguments to create many AttendanceRecords.
     * @example
     * // Create many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceRecordCreateManyArgs>(args?: SelectSubset<T, AttendanceRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttendanceRecords and returns the data saved in the database.
     * @param {AttendanceRecordCreateManyAndReturnArgs} args - Arguments to create many AttendanceRecords.
     * @example
     * // Create many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttendanceRecords and only return the `id`
     * const attendanceRecordWithIdOnly = await prisma.attendanceRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AttendanceRecord.
     * @param {AttendanceRecordDeleteArgs} args - Arguments to delete one AttendanceRecord.
     * @example
     * // Delete one AttendanceRecord
     * const AttendanceRecord = await prisma.attendanceRecord.delete({
     *   where: {
     *     // ... filter to delete one AttendanceRecord
     *   }
     * })
     * 
     */
    delete<T extends AttendanceRecordDeleteArgs>(args: SelectSubset<T, AttendanceRecordDeleteArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AttendanceRecord.
     * @param {AttendanceRecordUpdateArgs} args - Arguments to update one AttendanceRecord.
     * @example
     * // Update one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceRecordUpdateArgs>(args: SelectSubset<T, AttendanceRecordUpdateArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AttendanceRecords.
     * @param {AttendanceRecordDeleteManyArgs} args - Arguments to filter AttendanceRecords to delete.
     * @example
     * // Delete a few AttendanceRecords
     * const { count } = await prisma.attendanceRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceRecordDeleteManyArgs>(args?: SelectSubset<T, AttendanceRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceRecordUpdateManyArgs>(args: SelectSubset<T, AttendanceRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceRecords and returns the data updated in the database.
     * @param {AttendanceRecordUpdateManyAndReturnArgs} args - Arguments to update many AttendanceRecords.
     * @example
     * // Update many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AttendanceRecords and only return the `id`
     * const attendanceRecordWithIdOnly = await prisma.attendanceRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AttendanceRecord.
     * @param {AttendanceRecordUpsertArgs} args - Arguments to update or create a AttendanceRecord.
     * @example
     * // Update or create a AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.upsert({
     *   create: {
     *     // ... data to create a AttendanceRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceRecord we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceRecordUpsertArgs>(args: SelectSubset<T, AttendanceRecordUpsertArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AttendanceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordCountArgs} args - Arguments to filter AttendanceRecords to count.
     * @example
     * // Count the number of AttendanceRecords
     * const count = await prisma.attendanceRecord.count({
     *   where: {
     *     // ... the filter for the AttendanceRecords we want to count
     *   }
     * })
    **/
    count<T extends AttendanceRecordCountArgs>(
      args?: Subset<T, AttendanceRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceRecordAggregateArgs>(args: Subset<T, AttendanceRecordAggregateArgs>): Prisma.PrismaPromise<GetAttendanceRecordAggregateType<T>>

    /**
     * Group by AttendanceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceRecordGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceRecord model
   */
  readonly fields: AttendanceRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    markedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceRecord model
   */
  interface AttendanceRecordFieldRefs {
    readonly id: FieldRef<"AttendanceRecord", 'String'>
    readonly studentId: FieldRef<"AttendanceRecord", 'String'>
    readonly classId: FieldRef<"AttendanceRecord", 'String'>
    readonly subjectId: FieldRef<"AttendanceRecord", 'String'>
    readonly date: FieldRef<"AttendanceRecord", 'DateTime'>
    readonly period: FieldRef<"AttendanceRecord", 'Int'>
    readonly status: FieldRef<"AttendanceRecord", 'AttendanceStatus'>
    readonly markedById: FieldRef<"AttendanceRecord", 'String'>
    readonly markedAt: FieldRef<"AttendanceRecord", 'DateTime'>
    readonly remarks: FieldRef<"AttendanceRecord", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceRecord findUnique
   */
  export type AttendanceRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord findUniqueOrThrow
   */
  export type AttendanceRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord findFirst
   */
  export type AttendanceRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceRecords.
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceRecords.
     */
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * AttendanceRecord findFirstOrThrow
   */
  export type AttendanceRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceRecords.
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceRecords.
     */
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * AttendanceRecord findMany
   */
  export type AttendanceRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecords to fetch.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceRecords.
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * AttendanceRecord create
   */
  export type AttendanceRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceRecord.
     */
    data: XOR<AttendanceRecordCreateInput, AttendanceRecordUncheckedCreateInput>
  }

  /**
   * AttendanceRecord createMany
   */
  export type AttendanceRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceRecords.
     */
    data: AttendanceRecordCreateManyInput | AttendanceRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttendanceRecord createManyAndReturn
   */
  export type AttendanceRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * The data used to create many AttendanceRecords.
     */
    data: AttendanceRecordCreateManyInput | AttendanceRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceRecord update
   */
  export type AttendanceRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceRecord.
     */
    data: XOR<AttendanceRecordUpdateInput, AttendanceRecordUncheckedUpdateInput>
    /**
     * Choose, which AttendanceRecord to update.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord updateMany
   */
  export type AttendanceRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceRecords.
     */
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceRecords to update
     */
    where?: AttendanceRecordWhereInput
    /**
     * Limit how many AttendanceRecords to update.
     */
    limit?: number
  }

  /**
   * AttendanceRecord updateManyAndReturn
   */
  export type AttendanceRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * The data used to update AttendanceRecords.
     */
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceRecords to update
     */
    where?: AttendanceRecordWhereInput
    /**
     * Limit how many AttendanceRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceRecord upsert
   */
  export type AttendanceRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceRecord to update in case it exists.
     */
    where: AttendanceRecordWhereUniqueInput
    /**
     * In case the AttendanceRecord found by the `where` argument doesn't exist, create a new AttendanceRecord with this data.
     */
    create: XOR<AttendanceRecordCreateInput, AttendanceRecordUncheckedCreateInput>
    /**
     * In case the AttendanceRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceRecordUpdateInput, AttendanceRecordUncheckedUpdateInput>
  }

  /**
   * AttendanceRecord delete
   */
  export type AttendanceRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter which AttendanceRecord to delete.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord deleteMany
   */
  export type AttendanceRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceRecords to delete
     */
    where?: AttendanceRecordWhereInput
    /**
     * Limit how many AttendanceRecords to delete.
     */
    limit?: number
  }

  /**
   * AttendanceRecord without action
   */
  export type AttendanceRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
  }


  /**
   * Model AttendanceSummary
   */

  export type AggregateAttendanceSummary = {
    _count: AttendanceSummaryCountAggregateOutputType | null
    _avg: AttendanceSummaryAvgAggregateOutputType | null
    _sum: AttendanceSummarySumAggregateOutputType | null
    _min: AttendanceSummaryMinAggregateOutputType | null
    _max: AttendanceSummaryMaxAggregateOutputType | null
  }

  export type AttendanceSummaryAvgAggregateOutputType = {
    totalClasses: number | null
    presentCount: number | null
    absentCount: number | null
    lateCount: number | null
  }

  export type AttendanceSummarySumAggregateOutputType = {
    totalClasses: number | null
    presentCount: number | null
    absentCount: number | null
    lateCount: number | null
  }

  export type AttendanceSummaryMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    subjectId: string | null
    semesterId: string | null
    totalClasses: number | null
    presentCount: number | null
    absentCount: number | null
    lateCount: number | null
  }

  export type AttendanceSummaryMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    subjectId: string | null
    semesterId: string | null
    totalClasses: number | null
    presentCount: number | null
    absentCount: number | null
    lateCount: number | null
  }

  export type AttendanceSummaryCountAggregateOutputType = {
    id: number
    studentId: number
    subjectId: number
    semesterId: number
    totalClasses: number
    presentCount: number
    absentCount: number
    lateCount: number
    _all: number
  }


  export type AttendanceSummaryAvgAggregateInputType = {
    totalClasses?: true
    presentCount?: true
    absentCount?: true
    lateCount?: true
  }

  export type AttendanceSummarySumAggregateInputType = {
    totalClasses?: true
    presentCount?: true
    absentCount?: true
    lateCount?: true
  }

  export type AttendanceSummaryMinAggregateInputType = {
    id?: true
    studentId?: true
    subjectId?: true
    semesterId?: true
    totalClasses?: true
    presentCount?: true
    absentCount?: true
    lateCount?: true
  }

  export type AttendanceSummaryMaxAggregateInputType = {
    id?: true
    studentId?: true
    subjectId?: true
    semesterId?: true
    totalClasses?: true
    presentCount?: true
    absentCount?: true
    lateCount?: true
  }

  export type AttendanceSummaryCountAggregateInputType = {
    id?: true
    studentId?: true
    subjectId?: true
    semesterId?: true
    totalClasses?: true
    presentCount?: true
    absentCount?: true
    lateCount?: true
    _all?: true
  }

  export type AttendanceSummaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceSummary to aggregate.
     */
    where?: AttendanceSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceSummaries to fetch.
     */
    orderBy?: AttendanceSummaryOrderByWithRelationInput | AttendanceSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceSummaries
    **/
    _count?: true | AttendanceSummaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceSummaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceSummarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceSummaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceSummaryMaxAggregateInputType
  }

  export type GetAttendanceSummaryAggregateType<T extends AttendanceSummaryAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceSummary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceSummary[P]>
      : GetScalarType<T[P], AggregateAttendanceSummary[P]>
  }




  export type AttendanceSummaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceSummaryWhereInput
    orderBy?: AttendanceSummaryOrderByWithAggregationInput | AttendanceSummaryOrderByWithAggregationInput[]
    by: AttendanceSummaryScalarFieldEnum[] | AttendanceSummaryScalarFieldEnum
    having?: AttendanceSummaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceSummaryCountAggregateInputType | true
    _avg?: AttendanceSummaryAvgAggregateInputType
    _sum?: AttendanceSummarySumAggregateInputType
    _min?: AttendanceSummaryMinAggregateInputType
    _max?: AttendanceSummaryMaxAggregateInputType
  }

  export type AttendanceSummaryGroupByOutputType = {
    id: string
    studentId: string
    subjectId: string
    semesterId: string
    totalClasses: number
    presentCount: number
    absentCount: number
    lateCount: number
    _count: AttendanceSummaryCountAggregateOutputType | null
    _avg: AttendanceSummaryAvgAggregateOutputType | null
    _sum: AttendanceSummarySumAggregateOutputType | null
    _min: AttendanceSummaryMinAggregateOutputType | null
    _max: AttendanceSummaryMaxAggregateOutputType | null
  }

  type GetAttendanceSummaryGroupByPayload<T extends AttendanceSummaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceSummaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceSummaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceSummaryGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceSummaryGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSummarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    semesterId?: boolean
    totalClasses?: boolean
    presentCount?: boolean
    absentCount?: boolean
    lateCount?: boolean
    student?: boolean | UserDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceSummary"]>

  export type AttendanceSummarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    semesterId?: boolean
    totalClasses?: boolean
    presentCount?: boolean
    absentCount?: boolean
    lateCount?: boolean
    student?: boolean | UserDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceSummary"]>

  export type AttendanceSummarySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    semesterId?: boolean
    totalClasses?: boolean
    presentCount?: boolean
    absentCount?: boolean
    lateCount?: boolean
    student?: boolean | UserDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceSummary"]>

  export type AttendanceSummarySelectScalar = {
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    semesterId?: boolean
    totalClasses?: boolean
    presentCount?: boolean
    absentCount?: boolean
    lateCount?: boolean
  }

  export type AttendanceSummaryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "subjectId" | "semesterId" | "totalClasses" | "presentCount" | "absentCount" | "lateCount", ExtArgs["result"]["attendanceSummary"]>
  export type AttendanceSummaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | UserDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }
  export type AttendanceSummaryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | UserDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }
  export type AttendanceSummaryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | UserDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }

  export type $AttendanceSummaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceSummary"
    objects: {
      student: Prisma.$UserPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
      semester: Prisma.$SemesterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      subjectId: string
      semesterId: string
      totalClasses: number
      presentCount: number
      absentCount: number
      lateCount: number
    }, ExtArgs["result"]["attendanceSummary"]>
    composites: {}
  }

  type AttendanceSummaryGetPayload<S extends boolean | null | undefined | AttendanceSummaryDefaultArgs> = $Result.GetResult<Prisma.$AttendanceSummaryPayload, S>

  type AttendanceSummaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceSummaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceSummaryCountAggregateInputType | true
    }

  export interface AttendanceSummaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceSummary'], meta: { name: 'AttendanceSummary' } }
    /**
     * Find zero or one AttendanceSummary that matches the filter.
     * @param {AttendanceSummaryFindUniqueArgs} args - Arguments to find a AttendanceSummary
     * @example
     * // Get one AttendanceSummary
     * const attendanceSummary = await prisma.attendanceSummary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceSummaryFindUniqueArgs>(args: SelectSubset<T, AttendanceSummaryFindUniqueArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AttendanceSummary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceSummaryFindUniqueOrThrowArgs} args - Arguments to find a AttendanceSummary
     * @example
     * // Get one AttendanceSummary
     * const attendanceSummary = await prisma.attendanceSummary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceSummaryFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceSummaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceSummary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSummaryFindFirstArgs} args - Arguments to find a AttendanceSummary
     * @example
     * // Get one AttendanceSummary
     * const attendanceSummary = await prisma.attendanceSummary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceSummaryFindFirstArgs>(args?: SelectSubset<T, AttendanceSummaryFindFirstArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceSummary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSummaryFindFirstOrThrowArgs} args - Arguments to find a AttendanceSummary
     * @example
     * // Get one AttendanceSummary
     * const attendanceSummary = await prisma.attendanceSummary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceSummaryFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceSummaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AttendanceSummaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSummaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceSummaries
     * const attendanceSummaries = await prisma.attendanceSummary.findMany()
     * 
     * // Get first 10 AttendanceSummaries
     * const attendanceSummaries = await prisma.attendanceSummary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceSummaryWithIdOnly = await prisma.attendanceSummary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceSummaryFindManyArgs>(args?: SelectSubset<T, AttendanceSummaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AttendanceSummary.
     * @param {AttendanceSummaryCreateArgs} args - Arguments to create a AttendanceSummary.
     * @example
     * // Create one AttendanceSummary
     * const AttendanceSummary = await prisma.attendanceSummary.create({
     *   data: {
     *     // ... data to create a AttendanceSummary
     *   }
     * })
     * 
     */
    create<T extends AttendanceSummaryCreateArgs>(args: SelectSubset<T, AttendanceSummaryCreateArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AttendanceSummaries.
     * @param {AttendanceSummaryCreateManyArgs} args - Arguments to create many AttendanceSummaries.
     * @example
     * // Create many AttendanceSummaries
     * const attendanceSummary = await prisma.attendanceSummary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceSummaryCreateManyArgs>(args?: SelectSubset<T, AttendanceSummaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttendanceSummaries and returns the data saved in the database.
     * @param {AttendanceSummaryCreateManyAndReturnArgs} args - Arguments to create many AttendanceSummaries.
     * @example
     * // Create many AttendanceSummaries
     * const attendanceSummary = await prisma.attendanceSummary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttendanceSummaries and only return the `id`
     * const attendanceSummaryWithIdOnly = await prisma.attendanceSummary.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceSummaryCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceSummaryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AttendanceSummary.
     * @param {AttendanceSummaryDeleteArgs} args - Arguments to delete one AttendanceSummary.
     * @example
     * // Delete one AttendanceSummary
     * const AttendanceSummary = await prisma.attendanceSummary.delete({
     *   where: {
     *     // ... filter to delete one AttendanceSummary
     *   }
     * })
     * 
     */
    delete<T extends AttendanceSummaryDeleteArgs>(args: SelectSubset<T, AttendanceSummaryDeleteArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AttendanceSummary.
     * @param {AttendanceSummaryUpdateArgs} args - Arguments to update one AttendanceSummary.
     * @example
     * // Update one AttendanceSummary
     * const attendanceSummary = await prisma.attendanceSummary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceSummaryUpdateArgs>(args: SelectSubset<T, AttendanceSummaryUpdateArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AttendanceSummaries.
     * @param {AttendanceSummaryDeleteManyArgs} args - Arguments to filter AttendanceSummaries to delete.
     * @example
     * // Delete a few AttendanceSummaries
     * const { count } = await prisma.attendanceSummary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceSummaryDeleteManyArgs>(args?: SelectSubset<T, AttendanceSummaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSummaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceSummaries
     * const attendanceSummary = await prisma.attendanceSummary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceSummaryUpdateManyArgs>(args: SelectSubset<T, AttendanceSummaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceSummaries and returns the data updated in the database.
     * @param {AttendanceSummaryUpdateManyAndReturnArgs} args - Arguments to update many AttendanceSummaries.
     * @example
     * // Update many AttendanceSummaries
     * const attendanceSummary = await prisma.attendanceSummary.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AttendanceSummaries and only return the `id`
     * const attendanceSummaryWithIdOnly = await prisma.attendanceSummary.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceSummaryUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceSummaryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AttendanceSummary.
     * @param {AttendanceSummaryUpsertArgs} args - Arguments to update or create a AttendanceSummary.
     * @example
     * // Update or create a AttendanceSummary
     * const attendanceSummary = await prisma.attendanceSummary.upsert({
     *   create: {
     *     // ... data to create a AttendanceSummary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceSummary we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceSummaryUpsertArgs>(args: SelectSubset<T, AttendanceSummaryUpsertArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AttendanceSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSummaryCountArgs} args - Arguments to filter AttendanceSummaries to count.
     * @example
     * // Count the number of AttendanceSummaries
     * const count = await prisma.attendanceSummary.count({
     *   where: {
     *     // ... the filter for the AttendanceSummaries we want to count
     *   }
     * })
    **/
    count<T extends AttendanceSummaryCountArgs>(
      args?: Subset<T, AttendanceSummaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceSummaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSummaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceSummaryAggregateArgs>(args: Subset<T, AttendanceSummaryAggregateArgs>): Prisma.PrismaPromise<GetAttendanceSummaryAggregateType<T>>

    /**
     * Group by AttendanceSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSummaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceSummaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceSummaryGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceSummaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceSummaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceSummaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceSummary model
   */
  readonly fields: AttendanceSummaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceSummary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceSummaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    semester<T extends SemesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SemesterDefaultArgs<ExtArgs>>): Prisma__SemesterClient<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceSummary model
   */
  interface AttendanceSummaryFieldRefs {
    readonly id: FieldRef<"AttendanceSummary", 'String'>
    readonly studentId: FieldRef<"AttendanceSummary", 'String'>
    readonly subjectId: FieldRef<"AttendanceSummary", 'String'>
    readonly semesterId: FieldRef<"AttendanceSummary", 'String'>
    readonly totalClasses: FieldRef<"AttendanceSummary", 'Int'>
    readonly presentCount: FieldRef<"AttendanceSummary", 'Int'>
    readonly absentCount: FieldRef<"AttendanceSummary", 'Int'>
    readonly lateCount: FieldRef<"AttendanceSummary", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceSummary findUnique
   */
  export type AttendanceSummaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceSummary to fetch.
     */
    where: AttendanceSummaryWhereUniqueInput
  }

  /**
   * AttendanceSummary findUniqueOrThrow
   */
  export type AttendanceSummaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceSummary to fetch.
     */
    where: AttendanceSummaryWhereUniqueInput
  }

  /**
   * AttendanceSummary findFirst
   */
  export type AttendanceSummaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceSummary to fetch.
     */
    where?: AttendanceSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceSummaries to fetch.
     */
    orderBy?: AttendanceSummaryOrderByWithRelationInput | AttendanceSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceSummaries.
     */
    cursor?: AttendanceSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceSummaries.
     */
    distinct?: AttendanceSummaryScalarFieldEnum | AttendanceSummaryScalarFieldEnum[]
  }

  /**
   * AttendanceSummary findFirstOrThrow
   */
  export type AttendanceSummaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceSummary to fetch.
     */
    where?: AttendanceSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceSummaries to fetch.
     */
    orderBy?: AttendanceSummaryOrderByWithRelationInput | AttendanceSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceSummaries.
     */
    cursor?: AttendanceSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceSummaries.
     */
    distinct?: AttendanceSummaryScalarFieldEnum | AttendanceSummaryScalarFieldEnum[]
  }

  /**
   * AttendanceSummary findMany
   */
  export type AttendanceSummaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceSummaries to fetch.
     */
    where?: AttendanceSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceSummaries to fetch.
     */
    orderBy?: AttendanceSummaryOrderByWithRelationInput | AttendanceSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceSummaries.
     */
    cursor?: AttendanceSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceSummaries.
     */
    skip?: number
    distinct?: AttendanceSummaryScalarFieldEnum | AttendanceSummaryScalarFieldEnum[]
  }

  /**
   * AttendanceSummary create
   */
  export type AttendanceSummaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceSummary.
     */
    data: XOR<AttendanceSummaryCreateInput, AttendanceSummaryUncheckedCreateInput>
  }

  /**
   * AttendanceSummary createMany
   */
  export type AttendanceSummaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceSummaries.
     */
    data: AttendanceSummaryCreateManyInput | AttendanceSummaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttendanceSummary createManyAndReturn
   */
  export type AttendanceSummaryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * The data used to create many AttendanceSummaries.
     */
    data: AttendanceSummaryCreateManyInput | AttendanceSummaryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceSummary update
   */
  export type AttendanceSummaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceSummary.
     */
    data: XOR<AttendanceSummaryUpdateInput, AttendanceSummaryUncheckedUpdateInput>
    /**
     * Choose, which AttendanceSummary to update.
     */
    where: AttendanceSummaryWhereUniqueInput
  }

  /**
   * AttendanceSummary updateMany
   */
  export type AttendanceSummaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceSummaries.
     */
    data: XOR<AttendanceSummaryUpdateManyMutationInput, AttendanceSummaryUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceSummaries to update
     */
    where?: AttendanceSummaryWhereInput
    /**
     * Limit how many AttendanceSummaries to update.
     */
    limit?: number
  }

  /**
   * AttendanceSummary updateManyAndReturn
   */
  export type AttendanceSummaryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * The data used to update AttendanceSummaries.
     */
    data: XOR<AttendanceSummaryUpdateManyMutationInput, AttendanceSummaryUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceSummaries to update
     */
    where?: AttendanceSummaryWhereInput
    /**
     * Limit how many AttendanceSummaries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceSummary upsert
   */
  export type AttendanceSummaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceSummary to update in case it exists.
     */
    where: AttendanceSummaryWhereUniqueInput
    /**
     * In case the AttendanceSummary found by the `where` argument doesn't exist, create a new AttendanceSummary with this data.
     */
    create: XOR<AttendanceSummaryCreateInput, AttendanceSummaryUncheckedCreateInput>
    /**
     * In case the AttendanceSummary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceSummaryUpdateInput, AttendanceSummaryUncheckedUpdateInput>
  }

  /**
   * AttendanceSummary delete
   */
  export type AttendanceSummaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * Filter which AttendanceSummary to delete.
     */
    where: AttendanceSummaryWhereUniqueInput
  }

  /**
   * AttendanceSummary deleteMany
   */
  export type AttendanceSummaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceSummaries to delete
     */
    where?: AttendanceSummaryWhereInput
    /**
     * Limit how many AttendanceSummaries to delete.
     */
    limit?: number
  }

  /**
   * AttendanceSummary without action
   */
  export type AttendanceSummaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
  }


  /**
   * Model GradeCategory
   */

  export type AggregateGradeCategory = {
    _count: GradeCategoryCountAggregateOutputType | null
    _avg: GradeCategoryAvgAggregateOutputType | null
    _sum: GradeCategorySumAggregateOutputType | null
    _min: GradeCategoryMinAggregateOutputType | null
    _max: GradeCategoryMaxAggregateOutputType | null
  }

  export type GradeCategoryAvgAggregateOutputType = {
    weight: number | null
  }

  export type GradeCategorySumAggregateOutputType = {
    weight: number | null
  }

  export type GradeCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    weight: number | null
    classId: string | null
    subjectId: string | null
  }

  export type GradeCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    weight: number | null
    classId: string | null
    subjectId: string | null
  }

  export type GradeCategoryCountAggregateOutputType = {
    id: number
    name: number
    weight: number
    classId: number
    subjectId: number
    _all: number
  }


  export type GradeCategoryAvgAggregateInputType = {
    weight?: true
  }

  export type GradeCategorySumAggregateInputType = {
    weight?: true
  }

  export type GradeCategoryMinAggregateInputType = {
    id?: true
    name?: true
    weight?: true
    classId?: true
    subjectId?: true
  }

  export type GradeCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    weight?: true
    classId?: true
    subjectId?: true
  }

  export type GradeCategoryCountAggregateInputType = {
    id?: true
    name?: true
    weight?: true
    classId?: true
    subjectId?: true
    _all?: true
  }

  export type GradeCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GradeCategory to aggregate.
     */
    where?: GradeCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GradeCategories to fetch.
     */
    orderBy?: GradeCategoryOrderByWithRelationInput | GradeCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GradeCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GradeCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GradeCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GradeCategories
    **/
    _count?: true | GradeCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GradeCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GradeCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GradeCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GradeCategoryMaxAggregateInputType
  }

  export type GetGradeCategoryAggregateType<T extends GradeCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateGradeCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGradeCategory[P]>
      : GetScalarType<T[P], AggregateGradeCategory[P]>
  }




  export type GradeCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeCategoryWhereInput
    orderBy?: GradeCategoryOrderByWithAggregationInput | GradeCategoryOrderByWithAggregationInput[]
    by: GradeCategoryScalarFieldEnum[] | GradeCategoryScalarFieldEnum
    having?: GradeCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GradeCategoryCountAggregateInputType | true
    _avg?: GradeCategoryAvgAggregateInputType
    _sum?: GradeCategorySumAggregateInputType
    _min?: GradeCategoryMinAggregateInputType
    _max?: GradeCategoryMaxAggregateInputType
  }

  export type GradeCategoryGroupByOutputType = {
    id: string
    name: string
    weight: number
    classId: string
    subjectId: string
    _count: GradeCategoryCountAggregateOutputType | null
    _avg: GradeCategoryAvgAggregateOutputType | null
    _sum: GradeCategorySumAggregateOutputType | null
    _min: GradeCategoryMinAggregateOutputType | null
    _max: GradeCategoryMaxAggregateOutputType | null
  }

  type GetGradeCategoryGroupByPayload<T extends GradeCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GradeCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GradeCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GradeCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], GradeCategoryGroupByOutputType[P]>
        }
      >
    >


  export type GradeCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    weight?: boolean
    classId?: boolean
    subjectId?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    gradeEntries?: boolean | GradeCategory$gradeEntriesArgs<ExtArgs>
    _count?: boolean | GradeCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gradeCategory"]>

  export type GradeCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    weight?: boolean
    classId?: boolean
    subjectId?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gradeCategory"]>

  export type GradeCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    weight?: boolean
    classId?: boolean
    subjectId?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gradeCategory"]>

  export type GradeCategorySelectScalar = {
    id?: boolean
    name?: boolean
    weight?: boolean
    classId?: boolean
    subjectId?: boolean
  }

  export type GradeCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "weight" | "classId" | "subjectId", ExtArgs["result"]["gradeCategory"]>
  export type GradeCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    gradeEntries?: boolean | GradeCategory$gradeEntriesArgs<ExtArgs>
    _count?: boolean | GradeCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GradeCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }
  export type GradeCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }

  export type $GradeCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GradeCategory"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
      gradeEntries: Prisma.$GradeEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      weight: number
      classId: string
      subjectId: string
    }, ExtArgs["result"]["gradeCategory"]>
    composites: {}
  }

  type GradeCategoryGetPayload<S extends boolean | null | undefined | GradeCategoryDefaultArgs> = $Result.GetResult<Prisma.$GradeCategoryPayload, S>

  type GradeCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GradeCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GradeCategoryCountAggregateInputType | true
    }

  export interface GradeCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GradeCategory'], meta: { name: 'GradeCategory' } }
    /**
     * Find zero or one GradeCategory that matches the filter.
     * @param {GradeCategoryFindUniqueArgs} args - Arguments to find a GradeCategory
     * @example
     * // Get one GradeCategory
     * const gradeCategory = await prisma.gradeCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GradeCategoryFindUniqueArgs>(args: SelectSubset<T, GradeCategoryFindUniqueArgs<ExtArgs>>): Prisma__GradeCategoryClient<$Result.GetResult<Prisma.$GradeCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GradeCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GradeCategoryFindUniqueOrThrowArgs} args - Arguments to find a GradeCategory
     * @example
     * // Get one GradeCategory
     * const gradeCategory = await prisma.gradeCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GradeCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, GradeCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GradeCategoryClient<$Result.GetResult<Prisma.$GradeCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GradeCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeCategoryFindFirstArgs} args - Arguments to find a GradeCategory
     * @example
     * // Get one GradeCategory
     * const gradeCategory = await prisma.gradeCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GradeCategoryFindFirstArgs>(args?: SelectSubset<T, GradeCategoryFindFirstArgs<ExtArgs>>): Prisma__GradeCategoryClient<$Result.GetResult<Prisma.$GradeCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GradeCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeCategoryFindFirstOrThrowArgs} args - Arguments to find a GradeCategory
     * @example
     * // Get one GradeCategory
     * const gradeCategory = await prisma.gradeCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GradeCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, GradeCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__GradeCategoryClient<$Result.GetResult<Prisma.$GradeCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GradeCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GradeCategories
     * const gradeCategories = await prisma.gradeCategory.findMany()
     * 
     * // Get first 10 GradeCategories
     * const gradeCategories = await prisma.gradeCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gradeCategoryWithIdOnly = await prisma.gradeCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GradeCategoryFindManyArgs>(args?: SelectSubset<T, GradeCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradeCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GradeCategory.
     * @param {GradeCategoryCreateArgs} args - Arguments to create a GradeCategory.
     * @example
     * // Create one GradeCategory
     * const GradeCategory = await prisma.gradeCategory.create({
     *   data: {
     *     // ... data to create a GradeCategory
     *   }
     * })
     * 
     */
    create<T extends GradeCategoryCreateArgs>(args: SelectSubset<T, GradeCategoryCreateArgs<ExtArgs>>): Prisma__GradeCategoryClient<$Result.GetResult<Prisma.$GradeCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GradeCategories.
     * @param {GradeCategoryCreateManyArgs} args - Arguments to create many GradeCategories.
     * @example
     * // Create many GradeCategories
     * const gradeCategory = await prisma.gradeCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GradeCategoryCreateManyArgs>(args?: SelectSubset<T, GradeCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GradeCategories and returns the data saved in the database.
     * @param {GradeCategoryCreateManyAndReturnArgs} args - Arguments to create many GradeCategories.
     * @example
     * // Create many GradeCategories
     * const gradeCategory = await prisma.gradeCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GradeCategories and only return the `id`
     * const gradeCategoryWithIdOnly = await prisma.gradeCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GradeCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, GradeCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradeCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GradeCategory.
     * @param {GradeCategoryDeleteArgs} args - Arguments to delete one GradeCategory.
     * @example
     * // Delete one GradeCategory
     * const GradeCategory = await prisma.gradeCategory.delete({
     *   where: {
     *     // ... filter to delete one GradeCategory
     *   }
     * })
     * 
     */
    delete<T extends GradeCategoryDeleteArgs>(args: SelectSubset<T, GradeCategoryDeleteArgs<ExtArgs>>): Prisma__GradeCategoryClient<$Result.GetResult<Prisma.$GradeCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GradeCategory.
     * @param {GradeCategoryUpdateArgs} args - Arguments to update one GradeCategory.
     * @example
     * // Update one GradeCategory
     * const gradeCategory = await prisma.gradeCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GradeCategoryUpdateArgs>(args: SelectSubset<T, GradeCategoryUpdateArgs<ExtArgs>>): Prisma__GradeCategoryClient<$Result.GetResult<Prisma.$GradeCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GradeCategories.
     * @param {GradeCategoryDeleteManyArgs} args - Arguments to filter GradeCategories to delete.
     * @example
     * // Delete a few GradeCategories
     * const { count } = await prisma.gradeCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GradeCategoryDeleteManyArgs>(args?: SelectSubset<T, GradeCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GradeCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GradeCategories
     * const gradeCategory = await prisma.gradeCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GradeCategoryUpdateManyArgs>(args: SelectSubset<T, GradeCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GradeCategories and returns the data updated in the database.
     * @param {GradeCategoryUpdateManyAndReturnArgs} args - Arguments to update many GradeCategories.
     * @example
     * // Update many GradeCategories
     * const gradeCategory = await prisma.gradeCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GradeCategories and only return the `id`
     * const gradeCategoryWithIdOnly = await prisma.gradeCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GradeCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, GradeCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradeCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GradeCategory.
     * @param {GradeCategoryUpsertArgs} args - Arguments to update or create a GradeCategory.
     * @example
     * // Update or create a GradeCategory
     * const gradeCategory = await prisma.gradeCategory.upsert({
     *   create: {
     *     // ... data to create a GradeCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GradeCategory we want to update
     *   }
     * })
     */
    upsert<T extends GradeCategoryUpsertArgs>(args: SelectSubset<T, GradeCategoryUpsertArgs<ExtArgs>>): Prisma__GradeCategoryClient<$Result.GetResult<Prisma.$GradeCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GradeCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeCategoryCountArgs} args - Arguments to filter GradeCategories to count.
     * @example
     * // Count the number of GradeCategories
     * const count = await prisma.gradeCategory.count({
     *   where: {
     *     // ... the filter for the GradeCategories we want to count
     *   }
     * })
    **/
    count<T extends GradeCategoryCountArgs>(
      args?: Subset<T, GradeCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GradeCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GradeCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GradeCategoryAggregateArgs>(args: Subset<T, GradeCategoryAggregateArgs>): Prisma.PrismaPromise<GetGradeCategoryAggregateType<T>>

    /**
     * Group by GradeCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GradeCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GradeCategoryGroupByArgs['orderBy'] }
        : { orderBy?: GradeCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GradeCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGradeCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GradeCategory model
   */
  readonly fields: GradeCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GradeCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GradeCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    gradeEntries<T extends GradeCategory$gradeEntriesArgs<ExtArgs> = {}>(args?: Subset<T, GradeCategory$gradeEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradeEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GradeCategory model
   */
  interface GradeCategoryFieldRefs {
    readonly id: FieldRef<"GradeCategory", 'String'>
    readonly name: FieldRef<"GradeCategory", 'String'>
    readonly weight: FieldRef<"GradeCategory", 'Float'>
    readonly classId: FieldRef<"GradeCategory", 'String'>
    readonly subjectId: FieldRef<"GradeCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GradeCategory findUnique
   */
  export type GradeCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeCategory
     */
    select?: GradeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeCategory
     */
    omit?: GradeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeCategoryInclude<ExtArgs> | null
    /**
     * Filter, which GradeCategory to fetch.
     */
    where: GradeCategoryWhereUniqueInput
  }

  /**
   * GradeCategory findUniqueOrThrow
   */
  export type GradeCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeCategory
     */
    select?: GradeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeCategory
     */
    omit?: GradeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeCategoryInclude<ExtArgs> | null
    /**
     * Filter, which GradeCategory to fetch.
     */
    where: GradeCategoryWhereUniqueInput
  }

  /**
   * GradeCategory findFirst
   */
  export type GradeCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeCategory
     */
    select?: GradeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeCategory
     */
    omit?: GradeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeCategoryInclude<ExtArgs> | null
    /**
     * Filter, which GradeCategory to fetch.
     */
    where?: GradeCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GradeCategories to fetch.
     */
    orderBy?: GradeCategoryOrderByWithRelationInput | GradeCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GradeCategories.
     */
    cursor?: GradeCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GradeCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GradeCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GradeCategories.
     */
    distinct?: GradeCategoryScalarFieldEnum | GradeCategoryScalarFieldEnum[]
  }

  /**
   * GradeCategory findFirstOrThrow
   */
  export type GradeCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeCategory
     */
    select?: GradeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeCategory
     */
    omit?: GradeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeCategoryInclude<ExtArgs> | null
    /**
     * Filter, which GradeCategory to fetch.
     */
    where?: GradeCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GradeCategories to fetch.
     */
    orderBy?: GradeCategoryOrderByWithRelationInput | GradeCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GradeCategories.
     */
    cursor?: GradeCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GradeCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GradeCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GradeCategories.
     */
    distinct?: GradeCategoryScalarFieldEnum | GradeCategoryScalarFieldEnum[]
  }

  /**
   * GradeCategory findMany
   */
  export type GradeCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeCategory
     */
    select?: GradeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeCategory
     */
    omit?: GradeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeCategoryInclude<ExtArgs> | null
    /**
     * Filter, which GradeCategories to fetch.
     */
    where?: GradeCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GradeCategories to fetch.
     */
    orderBy?: GradeCategoryOrderByWithRelationInput | GradeCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GradeCategories.
     */
    cursor?: GradeCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GradeCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GradeCategories.
     */
    skip?: number
    distinct?: GradeCategoryScalarFieldEnum | GradeCategoryScalarFieldEnum[]
  }

  /**
   * GradeCategory create
   */
  export type GradeCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeCategory
     */
    select?: GradeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeCategory
     */
    omit?: GradeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a GradeCategory.
     */
    data: XOR<GradeCategoryCreateInput, GradeCategoryUncheckedCreateInput>
  }

  /**
   * GradeCategory createMany
   */
  export type GradeCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GradeCategories.
     */
    data: GradeCategoryCreateManyInput | GradeCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GradeCategory createManyAndReturn
   */
  export type GradeCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeCategory
     */
    select?: GradeCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GradeCategory
     */
    omit?: GradeCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many GradeCategories.
     */
    data: GradeCategoryCreateManyInput | GradeCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GradeCategory update
   */
  export type GradeCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeCategory
     */
    select?: GradeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeCategory
     */
    omit?: GradeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a GradeCategory.
     */
    data: XOR<GradeCategoryUpdateInput, GradeCategoryUncheckedUpdateInput>
    /**
     * Choose, which GradeCategory to update.
     */
    where: GradeCategoryWhereUniqueInput
  }

  /**
   * GradeCategory updateMany
   */
  export type GradeCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GradeCategories.
     */
    data: XOR<GradeCategoryUpdateManyMutationInput, GradeCategoryUncheckedUpdateManyInput>
    /**
     * Filter which GradeCategories to update
     */
    where?: GradeCategoryWhereInput
    /**
     * Limit how many GradeCategories to update.
     */
    limit?: number
  }

  /**
   * GradeCategory updateManyAndReturn
   */
  export type GradeCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeCategory
     */
    select?: GradeCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GradeCategory
     */
    omit?: GradeCategoryOmit<ExtArgs> | null
    /**
     * The data used to update GradeCategories.
     */
    data: XOR<GradeCategoryUpdateManyMutationInput, GradeCategoryUncheckedUpdateManyInput>
    /**
     * Filter which GradeCategories to update
     */
    where?: GradeCategoryWhereInput
    /**
     * Limit how many GradeCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GradeCategory upsert
   */
  export type GradeCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeCategory
     */
    select?: GradeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeCategory
     */
    omit?: GradeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the GradeCategory to update in case it exists.
     */
    where: GradeCategoryWhereUniqueInput
    /**
     * In case the GradeCategory found by the `where` argument doesn't exist, create a new GradeCategory with this data.
     */
    create: XOR<GradeCategoryCreateInput, GradeCategoryUncheckedCreateInput>
    /**
     * In case the GradeCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GradeCategoryUpdateInput, GradeCategoryUncheckedUpdateInput>
  }

  /**
   * GradeCategory delete
   */
  export type GradeCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeCategory
     */
    select?: GradeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeCategory
     */
    omit?: GradeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeCategoryInclude<ExtArgs> | null
    /**
     * Filter which GradeCategory to delete.
     */
    where: GradeCategoryWhereUniqueInput
  }

  /**
   * GradeCategory deleteMany
   */
  export type GradeCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GradeCategories to delete
     */
    where?: GradeCategoryWhereInput
    /**
     * Limit how many GradeCategories to delete.
     */
    limit?: number
  }

  /**
   * GradeCategory.gradeEntries
   */
  export type GradeCategory$gradeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeEntry
     */
    select?: GradeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeEntry
     */
    omit?: GradeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeEntryInclude<ExtArgs> | null
    where?: GradeEntryWhereInput
    orderBy?: GradeEntryOrderByWithRelationInput | GradeEntryOrderByWithRelationInput[]
    cursor?: GradeEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeEntryScalarFieldEnum | GradeEntryScalarFieldEnum[]
  }

  /**
   * GradeCategory without action
   */
  export type GradeCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeCategory
     */
    select?: GradeCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeCategory
     */
    omit?: GradeCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeCategoryInclude<ExtArgs> | null
  }


  /**
   * Model GradeEntry
   */

  export type AggregateGradeEntry = {
    _count: GradeEntryCountAggregateOutputType | null
    _avg: GradeEntryAvgAggregateOutputType | null
    _sum: GradeEntrySumAggregateOutputType | null
    _min: GradeEntryMinAggregateOutputType | null
    _max: GradeEntryMaxAggregateOutputType | null
  }

  export type GradeEntryAvgAggregateOutputType = {
    pointsEarned: number | null
    totalPoints: number | null
  }

  export type GradeEntrySumAggregateOutputType = {
    pointsEarned: number | null
    totalPoints: number | null
  }

  export type GradeEntryMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    subjectId: string | null
    categoryId: string | null
    classId: string | null
    academicYearId: string | null
    pointsEarned: number | null
    totalPoints: number | null
    date: Date | null
    semesterId: string | null
    createdById: string | null
  }

  export type GradeEntryMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    subjectId: string | null
    categoryId: string | null
    classId: string | null
    academicYearId: string | null
    pointsEarned: number | null
    totalPoints: number | null
    date: Date | null
    semesterId: string | null
    createdById: string | null
  }

  export type GradeEntryCountAggregateOutputType = {
    id: number
    studentId: number
    subjectId: number
    categoryId: number
    classId: number
    academicYearId: number
    pointsEarned: number
    totalPoints: number
    date: number
    semesterId: number
    createdById: number
    _all: number
  }


  export type GradeEntryAvgAggregateInputType = {
    pointsEarned?: true
    totalPoints?: true
  }

  export type GradeEntrySumAggregateInputType = {
    pointsEarned?: true
    totalPoints?: true
  }

  export type GradeEntryMinAggregateInputType = {
    id?: true
    studentId?: true
    subjectId?: true
    categoryId?: true
    classId?: true
    academicYearId?: true
    pointsEarned?: true
    totalPoints?: true
    date?: true
    semesterId?: true
    createdById?: true
  }

  export type GradeEntryMaxAggregateInputType = {
    id?: true
    studentId?: true
    subjectId?: true
    categoryId?: true
    classId?: true
    academicYearId?: true
    pointsEarned?: true
    totalPoints?: true
    date?: true
    semesterId?: true
    createdById?: true
  }

  export type GradeEntryCountAggregateInputType = {
    id?: true
    studentId?: true
    subjectId?: true
    categoryId?: true
    classId?: true
    academicYearId?: true
    pointsEarned?: true
    totalPoints?: true
    date?: true
    semesterId?: true
    createdById?: true
    _all?: true
  }

  export type GradeEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GradeEntry to aggregate.
     */
    where?: GradeEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GradeEntries to fetch.
     */
    orderBy?: GradeEntryOrderByWithRelationInput | GradeEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GradeEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GradeEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GradeEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GradeEntries
    **/
    _count?: true | GradeEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GradeEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GradeEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GradeEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GradeEntryMaxAggregateInputType
  }

  export type GetGradeEntryAggregateType<T extends GradeEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateGradeEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGradeEntry[P]>
      : GetScalarType<T[P], AggregateGradeEntry[P]>
  }




  export type GradeEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeEntryWhereInput
    orderBy?: GradeEntryOrderByWithAggregationInput | GradeEntryOrderByWithAggregationInput[]
    by: GradeEntryScalarFieldEnum[] | GradeEntryScalarFieldEnum
    having?: GradeEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GradeEntryCountAggregateInputType | true
    _avg?: GradeEntryAvgAggregateInputType
    _sum?: GradeEntrySumAggregateInputType
    _min?: GradeEntryMinAggregateInputType
    _max?: GradeEntryMaxAggregateInputType
  }

  export type GradeEntryGroupByOutputType = {
    id: string
    studentId: string
    subjectId: string
    categoryId: string
    classId: string
    academicYearId: string
    pointsEarned: number
    totalPoints: number
    date: Date
    semesterId: string
    createdById: string
    _count: GradeEntryCountAggregateOutputType | null
    _avg: GradeEntryAvgAggregateOutputType | null
    _sum: GradeEntrySumAggregateOutputType | null
    _min: GradeEntryMinAggregateOutputType | null
    _max: GradeEntryMaxAggregateOutputType | null
  }

  type GetGradeEntryGroupByPayload<T extends GradeEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GradeEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GradeEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GradeEntryGroupByOutputType[P]>
            : GetScalarType<T[P], GradeEntryGroupByOutputType[P]>
        }
      >
    >


  export type GradeEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    categoryId?: boolean
    classId?: boolean
    academicYearId?: boolean
    pointsEarned?: boolean
    totalPoints?: boolean
    date?: boolean
    semesterId?: boolean
    createdById?: boolean
    student?: boolean | UserDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    category?: boolean | GradeCategoryDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gradeEntry"]>

  export type GradeEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    categoryId?: boolean
    classId?: boolean
    academicYearId?: boolean
    pointsEarned?: boolean
    totalPoints?: boolean
    date?: boolean
    semesterId?: boolean
    createdById?: boolean
    student?: boolean | UserDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    category?: boolean | GradeCategoryDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gradeEntry"]>

  export type GradeEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    categoryId?: boolean
    classId?: boolean
    academicYearId?: boolean
    pointsEarned?: boolean
    totalPoints?: boolean
    date?: boolean
    semesterId?: boolean
    createdById?: boolean
    student?: boolean | UserDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    category?: boolean | GradeCategoryDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gradeEntry"]>

  export type GradeEntrySelectScalar = {
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    categoryId?: boolean
    classId?: boolean
    academicYearId?: boolean
    pointsEarned?: boolean
    totalPoints?: boolean
    date?: boolean
    semesterId?: boolean
    createdById?: boolean
  }

  export type GradeEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "subjectId" | "categoryId" | "classId" | "academicYearId" | "pointsEarned" | "totalPoints" | "date" | "semesterId" | "createdById", ExtArgs["result"]["gradeEntry"]>
  export type GradeEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | UserDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    category?: boolean | GradeCategoryDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GradeEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | UserDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    category?: boolean | GradeCategoryDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GradeEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | UserDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    category?: boolean | GradeCategoryDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicYear?: boolean | AcademicYearDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GradeEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GradeEntry"
    objects: {
      student: Prisma.$UserPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
      category: Prisma.$GradeCategoryPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
      academicYear: Prisma.$AcademicYearPayload<ExtArgs>
      semester: Prisma.$SemesterPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      subjectId: string
      categoryId: string
      classId: string
      academicYearId: string
      pointsEarned: number
      totalPoints: number
      date: Date
      semesterId: string
      createdById: string
    }, ExtArgs["result"]["gradeEntry"]>
    composites: {}
  }

  type GradeEntryGetPayload<S extends boolean | null | undefined | GradeEntryDefaultArgs> = $Result.GetResult<Prisma.$GradeEntryPayload, S>

  type GradeEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GradeEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GradeEntryCountAggregateInputType | true
    }

  export interface GradeEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GradeEntry'], meta: { name: 'GradeEntry' } }
    /**
     * Find zero or one GradeEntry that matches the filter.
     * @param {GradeEntryFindUniqueArgs} args - Arguments to find a GradeEntry
     * @example
     * // Get one GradeEntry
     * const gradeEntry = await prisma.gradeEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GradeEntryFindUniqueArgs>(args: SelectSubset<T, GradeEntryFindUniqueArgs<ExtArgs>>): Prisma__GradeEntryClient<$Result.GetResult<Prisma.$GradeEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GradeEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GradeEntryFindUniqueOrThrowArgs} args - Arguments to find a GradeEntry
     * @example
     * // Get one GradeEntry
     * const gradeEntry = await prisma.gradeEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GradeEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, GradeEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GradeEntryClient<$Result.GetResult<Prisma.$GradeEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GradeEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeEntryFindFirstArgs} args - Arguments to find a GradeEntry
     * @example
     * // Get one GradeEntry
     * const gradeEntry = await prisma.gradeEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GradeEntryFindFirstArgs>(args?: SelectSubset<T, GradeEntryFindFirstArgs<ExtArgs>>): Prisma__GradeEntryClient<$Result.GetResult<Prisma.$GradeEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GradeEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeEntryFindFirstOrThrowArgs} args - Arguments to find a GradeEntry
     * @example
     * // Get one GradeEntry
     * const gradeEntry = await prisma.gradeEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GradeEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, GradeEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__GradeEntryClient<$Result.GetResult<Prisma.$GradeEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GradeEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GradeEntries
     * const gradeEntries = await prisma.gradeEntry.findMany()
     * 
     * // Get first 10 GradeEntries
     * const gradeEntries = await prisma.gradeEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gradeEntryWithIdOnly = await prisma.gradeEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GradeEntryFindManyArgs>(args?: SelectSubset<T, GradeEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradeEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GradeEntry.
     * @param {GradeEntryCreateArgs} args - Arguments to create a GradeEntry.
     * @example
     * // Create one GradeEntry
     * const GradeEntry = await prisma.gradeEntry.create({
     *   data: {
     *     // ... data to create a GradeEntry
     *   }
     * })
     * 
     */
    create<T extends GradeEntryCreateArgs>(args: SelectSubset<T, GradeEntryCreateArgs<ExtArgs>>): Prisma__GradeEntryClient<$Result.GetResult<Prisma.$GradeEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GradeEntries.
     * @param {GradeEntryCreateManyArgs} args - Arguments to create many GradeEntries.
     * @example
     * // Create many GradeEntries
     * const gradeEntry = await prisma.gradeEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GradeEntryCreateManyArgs>(args?: SelectSubset<T, GradeEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GradeEntries and returns the data saved in the database.
     * @param {GradeEntryCreateManyAndReturnArgs} args - Arguments to create many GradeEntries.
     * @example
     * // Create many GradeEntries
     * const gradeEntry = await prisma.gradeEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GradeEntries and only return the `id`
     * const gradeEntryWithIdOnly = await prisma.gradeEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GradeEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, GradeEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradeEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GradeEntry.
     * @param {GradeEntryDeleteArgs} args - Arguments to delete one GradeEntry.
     * @example
     * // Delete one GradeEntry
     * const GradeEntry = await prisma.gradeEntry.delete({
     *   where: {
     *     // ... filter to delete one GradeEntry
     *   }
     * })
     * 
     */
    delete<T extends GradeEntryDeleteArgs>(args: SelectSubset<T, GradeEntryDeleteArgs<ExtArgs>>): Prisma__GradeEntryClient<$Result.GetResult<Prisma.$GradeEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GradeEntry.
     * @param {GradeEntryUpdateArgs} args - Arguments to update one GradeEntry.
     * @example
     * // Update one GradeEntry
     * const gradeEntry = await prisma.gradeEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GradeEntryUpdateArgs>(args: SelectSubset<T, GradeEntryUpdateArgs<ExtArgs>>): Prisma__GradeEntryClient<$Result.GetResult<Prisma.$GradeEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GradeEntries.
     * @param {GradeEntryDeleteManyArgs} args - Arguments to filter GradeEntries to delete.
     * @example
     * // Delete a few GradeEntries
     * const { count } = await prisma.gradeEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GradeEntryDeleteManyArgs>(args?: SelectSubset<T, GradeEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GradeEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GradeEntries
     * const gradeEntry = await prisma.gradeEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GradeEntryUpdateManyArgs>(args: SelectSubset<T, GradeEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GradeEntries and returns the data updated in the database.
     * @param {GradeEntryUpdateManyAndReturnArgs} args - Arguments to update many GradeEntries.
     * @example
     * // Update many GradeEntries
     * const gradeEntry = await prisma.gradeEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GradeEntries and only return the `id`
     * const gradeEntryWithIdOnly = await prisma.gradeEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GradeEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, GradeEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradeEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GradeEntry.
     * @param {GradeEntryUpsertArgs} args - Arguments to update or create a GradeEntry.
     * @example
     * // Update or create a GradeEntry
     * const gradeEntry = await prisma.gradeEntry.upsert({
     *   create: {
     *     // ... data to create a GradeEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GradeEntry we want to update
     *   }
     * })
     */
    upsert<T extends GradeEntryUpsertArgs>(args: SelectSubset<T, GradeEntryUpsertArgs<ExtArgs>>): Prisma__GradeEntryClient<$Result.GetResult<Prisma.$GradeEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GradeEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeEntryCountArgs} args - Arguments to filter GradeEntries to count.
     * @example
     * // Count the number of GradeEntries
     * const count = await prisma.gradeEntry.count({
     *   where: {
     *     // ... the filter for the GradeEntries we want to count
     *   }
     * })
    **/
    count<T extends GradeEntryCountArgs>(
      args?: Subset<T, GradeEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GradeEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GradeEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GradeEntryAggregateArgs>(args: Subset<T, GradeEntryAggregateArgs>): Prisma.PrismaPromise<GetGradeEntryAggregateType<T>>

    /**
     * Group by GradeEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GradeEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GradeEntryGroupByArgs['orderBy'] }
        : { orderBy?: GradeEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GradeEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGradeEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GradeEntry model
   */
  readonly fields: GradeEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GradeEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GradeEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends GradeCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GradeCategoryDefaultArgs<ExtArgs>>): Prisma__GradeCategoryClient<$Result.GetResult<Prisma.$GradeCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicYear<T extends AcademicYearDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicYearDefaultArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    semester<T extends SemesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SemesterDefaultArgs<ExtArgs>>): Prisma__SemesterClient<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GradeEntry model
   */
  interface GradeEntryFieldRefs {
    readonly id: FieldRef<"GradeEntry", 'String'>
    readonly studentId: FieldRef<"GradeEntry", 'String'>
    readonly subjectId: FieldRef<"GradeEntry", 'String'>
    readonly categoryId: FieldRef<"GradeEntry", 'String'>
    readonly classId: FieldRef<"GradeEntry", 'String'>
    readonly academicYearId: FieldRef<"GradeEntry", 'String'>
    readonly pointsEarned: FieldRef<"GradeEntry", 'Float'>
    readonly totalPoints: FieldRef<"GradeEntry", 'Float'>
    readonly date: FieldRef<"GradeEntry", 'DateTime'>
    readonly semesterId: FieldRef<"GradeEntry", 'String'>
    readonly createdById: FieldRef<"GradeEntry", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GradeEntry findUnique
   */
  export type GradeEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeEntry
     */
    select?: GradeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeEntry
     */
    omit?: GradeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeEntryInclude<ExtArgs> | null
    /**
     * Filter, which GradeEntry to fetch.
     */
    where: GradeEntryWhereUniqueInput
  }

  /**
   * GradeEntry findUniqueOrThrow
   */
  export type GradeEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeEntry
     */
    select?: GradeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeEntry
     */
    omit?: GradeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeEntryInclude<ExtArgs> | null
    /**
     * Filter, which GradeEntry to fetch.
     */
    where: GradeEntryWhereUniqueInput
  }

  /**
   * GradeEntry findFirst
   */
  export type GradeEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeEntry
     */
    select?: GradeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeEntry
     */
    omit?: GradeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeEntryInclude<ExtArgs> | null
    /**
     * Filter, which GradeEntry to fetch.
     */
    where?: GradeEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GradeEntries to fetch.
     */
    orderBy?: GradeEntryOrderByWithRelationInput | GradeEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GradeEntries.
     */
    cursor?: GradeEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GradeEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GradeEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GradeEntries.
     */
    distinct?: GradeEntryScalarFieldEnum | GradeEntryScalarFieldEnum[]
  }

  /**
   * GradeEntry findFirstOrThrow
   */
  export type GradeEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeEntry
     */
    select?: GradeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeEntry
     */
    omit?: GradeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeEntryInclude<ExtArgs> | null
    /**
     * Filter, which GradeEntry to fetch.
     */
    where?: GradeEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GradeEntries to fetch.
     */
    orderBy?: GradeEntryOrderByWithRelationInput | GradeEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GradeEntries.
     */
    cursor?: GradeEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GradeEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GradeEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GradeEntries.
     */
    distinct?: GradeEntryScalarFieldEnum | GradeEntryScalarFieldEnum[]
  }

  /**
   * GradeEntry findMany
   */
  export type GradeEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeEntry
     */
    select?: GradeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeEntry
     */
    omit?: GradeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeEntryInclude<ExtArgs> | null
    /**
     * Filter, which GradeEntries to fetch.
     */
    where?: GradeEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GradeEntries to fetch.
     */
    orderBy?: GradeEntryOrderByWithRelationInput | GradeEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GradeEntries.
     */
    cursor?: GradeEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GradeEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GradeEntries.
     */
    skip?: number
    distinct?: GradeEntryScalarFieldEnum | GradeEntryScalarFieldEnum[]
  }

  /**
   * GradeEntry create
   */
  export type GradeEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeEntry
     */
    select?: GradeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeEntry
     */
    omit?: GradeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a GradeEntry.
     */
    data: XOR<GradeEntryCreateInput, GradeEntryUncheckedCreateInput>
  }

  /**
   * GradeEntry createMany
   */
  export type GradeEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GradeEntries.
     */
    data: GradeEntryCreateManyInput | GradeEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GradeEntry createManyAndReturn
   */
  export type GradeEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeEntry
     */
    select?: GradeEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GradeEntry
     */
    omit?: GradeEntryOmit<ExtArgs> | null
    /**
     * The data used to create many GradeEntries.
     */
    data: GradeEntryCreateManyInput | GradeEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GradeEntry update
   */
  export type GradeEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeEntry
     */
    select?: GradeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeEntry
     */
    omit?: GradeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a GradeEntry.
     */
    data: XOR<GradeEntryUpdateInput, GradeEntryUncheckedUpdateInput>
    /**
     * Choose, which GradeEntry to update.
     */
    where: GradeEntryWhereUniqueInput
  }

  /**
   * GradeEntry updateMany
   */
  export type GradeEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GradeEntries.
     */
    data: XOR<GradeEntryUpdateManyMutationInput, GradeEntryUncheckedUpdateManyInput>
    /**
     * Filter which GradeEntries to update
     */
    where?: GradeEntryWhereInput
    /**
     * Limit how many GradeEntries to update.
     */
    limit?: number
  }

  /**
   * GradeEntry updateManyAndReturn
   */
  export type GradeEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeEntry
     */
    select?: GradeEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GradeEntry
     */
    omit?: GradeEntryOmit<ExtArgs> | null
    /**
     * The data used to update GradeEntries.
     */
    data: XOR<GradeEntryUpdateManyMutationInput, GradeEntryUncheckedUpdateManyInput>
    /**
     * Filter which GradeEntries to update
     */
    where?: GradeEntryWhereInput
    /**
     * Limit how many GradeEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GradeEntry upsert
   */
  export type GradeEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeEntry
     */
    select?: GradeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeEntry
     */
    omit?: GradeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the GradeEntry to update in case it exists.
     */
    where: GradeEntryWhereUniqueInput
    /**
     * In case the GradeEntry found by the `where` argument doesn't exist, create a new GradeEntry with this data.
     */
    create: XOR<GradeEntryCreateInput, GradeEntryUncheckedCreateInput>
    /**
     * In case the GradeEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GradeEntryUpdateInput, GradeEntryUncheckedUpdateInput>
  }

  /**
   * GradeEntry delete
   */
  export type GradeEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeEntry
     */
    select?: GradeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeEntry
     */
    omit?: GradeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeEntryInclude<ExtArgs> | null
    /**
     * Filter which GradeEntry to delete.
     */
    where: GradeEntryWhereUniqueInput
  }

  /**
   * GradeEntry deleteMany
   */
  export type GradeEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GradeEntries to delete
     */
    where?: GradeEntryWhereInput
    /**
     * Limit how many GradeEntries to delete.
     */
    limit?: number
  }

  /**
   * GradeEntry without action
   */
  export type GradeEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeEntry
     */
    select?: GradeEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeEntry
     */
    omit?: GradeEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeEntryInclude<ExtArgs> | null
  }


  /**
   * Model GradeReport
   */

  export type AggregateGradeReport = {
    _count: GradeReportCountAggregateOutputType | null
    _avg: GradeReportAvgAggregateOutputType | null
    _sum: GradeReportSumAggregateOutputType | null
    _min: GradeReportMinAggregateOutputType | null
    _max: GradeReportMaxAggregateOutputType | null
  }

  export type GradeReportAvgAggregateOutputType = {
    overallGpa: number | null
  }

  export type GradeReportSumAggregateOutputType = {
    overallGpa: number | null
  }

  export type GradeReportMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    semesterId: string | null
    overallGpa: number | null
    generatedAt: Date | null
  }

  export type GradeReportMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    semesterId: string | null
    overallGpa: number | null
    generatedAt: Date | null
  }

  export type GradeReportCountAggregateOutputType = {
    id: number
    studentId: number
    semesterId: number
    overallGpa: number
    generatedAt: number
    _all: number
  }


  export type GradeReportAvgAggregateInputType = {
    overallGpa?: true
  }

  export type GradeReportSumAggregateInputType = {
    overallGpa?: true
  }

  export type GradeReportMinAggregateInputType = {
    id?: true
    studentId?: true
    semesterId?: true
    overallGpa?: true
    generatedAt?: true
  }

  export type GradeReportMaxAggregateInputType = {
    id?: true
    studentId?: true
    semesterId?: true
    overallGpa?: true
    generatedAt?: true
  }

  export type GradeReportCountAggregateInputType = {
    id?: true
    studentId?: true
    semesterId?: true
    overallGpa?: true
    generatedAt?: true
    _all?: true
  }

  export type GradeReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GradeReport to aggregate.
     */
    where?: GradeReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GradeReports to fetch.
     */
    orderBy?: GradeReportOrderByWithRelationInput | GradeReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GradeReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GradeReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GradeReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GradeReports
    **/
    _count?: true | GradeReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GradeReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GradeReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GradeReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GradeReportMaxAggregateInputType
  }

  export type GetGradeReportAggregateType<T extends GradeReportAggregateArgs> = {
        [P in keyof T & keyof AggregateGradeReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGradeReport[P]>
      : GetScalarType<T[P], AggregateGradeReport[P]>
  }




  export type GradeReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeReportWhereInput
    orderBy?: GradeReportOrderByWithAggregationInput | GradeReportOrderByWithAggregationInput[]
    by: GradeReportScalarFieldEnum[] | GradeReportScalarFieldEnum
    having?: GradeReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GradeReportCountAggregateInputType | true
    _avg?: GradeReportAvgAggregateInputType
    _sum?: GradeReportSumAggregateInputType
    _min?: GradeReportMinAggregateInputType
    _max?: GradeReportMaxAggregateInputType
  }

  export type GradeReportGroupByOutputType = {
    id: string
    studentId: string
    semesterId: string
    overallGpa: number
    generatedAt: Date
    _count: GradeReportCountAggregateOutputType | null
    _avg: GradeReportAvgAggregateOutputType | null
    _sum: GradeReportSumAggregateOutputType | null
    _min: GradeReportMinAggregateOutputType | null
    _max: GradeReportMaxAggregateOutputType | null
  }

  type GetGradeReportGroupByPayload<T extends GradeReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GradeReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GradeReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GradeReportGroupByOutputType[P]>
            : GetScalarType<T[P], GradeReportGroupByOutputType[P]>
        }
      >
    >


  export type GradeReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    semesterId?: boolean
    overallGpa?: boolean
    generatedAt?: boolean
    student?: boolean | UserDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gradeReport"]>

  export type GradeReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    semesterId?: boolean
    overallGpa?: boolean
    generatedAt?: boolean
    student?: boolean | UserDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gradeReport"]>

  export type GradeReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    semesterId?: boolean
    overallGpa?: boolean
    generatedAt?: boolean
    student?: boolean | UserDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gradeReport"]>

  export type GradeReportSelectScalar = {
    id?: boolean
    studentId?: boolean
    semesterId?: boolean
    overallGpa?: boolean
    generatedAt?: boolean
  }

  export type GradeReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "semesterId" | "overallGpa" | "generatedAt", ExtArgs["result"]["gradeReport"]>
  export type GradeReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | UserDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }
  export type GradeReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | UserDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }
  export type GradeReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | UserDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }

  export type $GradeReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GradeReport"
    objects: {
      student: Prisma.$UserPayload<ExtArgs>
      semester: Prisma.$SemesterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      semesterId: string
      overallGpa: number
      generatedAt: Date
    }, ExtArgs["result"]["gradeReport"]>
    composites: {}
  }

  type GradeReportGetPayload<S extends boolean | null | undefined | GradeReportDefaultArgs> = $Result.GetResult<Prisma.$GradeReportPayload, S>

  type GradeReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GradeReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GradeReportCountAggregateInputType | true
    }

  export interface GradeReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GradeReport'], meta: { name: 'GradeReport' } }
    /**
     * Find zero or one GradeReport that matches the filter.
     * @param {GradeReportFindUniqueArgs} args - Arguments to find a GradeReport
     * @example
     * // Get one GradeReport
     * const gradeReport = await prisma.gradeReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GradeReportFindUniqueArgs>(args: SelectSubset<T, GradeReportFindUniqueArgs<ExtArgs>>): Prisma__GradeReportClient<$Result.GetResult<Prisma.$GradeReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GradeReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GradeReportFindUniqueOrThrowArgs} args - Arguments to find a GradeReport
     * @example
     * // Get one GradeReport
     * const gradeReport = await prisma.gradeReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GradeReportFindUniqueOrThrowArgs>(args: SelectSubset<T, GradeReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GradeReportClient<$Result.GetResult<Prisma.$GradeReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GradeReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeReportFindFirstArgs} args - Arguments to find a GradeReport
     * @example
     * // Get one GradeReport
     * const gradeReport = await prisma.gradeReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GradeReportFindFirstArgs>(args?: SelectSubset<T, GradeReportFindFirstArgs<ExtArgs>>): Prisma__GradeReportClient<$Result.GetResult<Prisma.$GradeReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GradeReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeReportFindFirstOrThrowArgs} args - Arguments to find a GradeReport
     * @example
     * // Get one GradeReport
     * const gradeReport = await prisma.gradeReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GradeReportFindFirstOrThrowArgs>(args?: SelectSubset<T, GradeReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__GradeReportClient<$Result.GetResult<Prisma.$GradeReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GradeReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GradeReports
     * const gradeReports = await prisma.gradeReport.findMany()
     * 
     * // Get first 10 GradeReports
     * const gradeReports = await prisma.gradeReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gradeReportWithIdOnly = await prisma.gradeReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GradeReportFindManyArgs>(args?: SelectSubset<T, GradeReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradeReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GradeReport.
     * @param {GradeReportCreateArgs} args - Arguments to create a GradeReport.
     * @example
     * // Create one GradeReport
     * const GradeReport = await prisma.gradeReport.create({
     *   data: {
     *     // ... data to create a GradeReport
     *   }
     * })
     * 
     */
    create<T extends GradeReportCreateArgs>(args: SelectSubset<T, GradeReportCreateArgs<ExtArgs>>): Prisma__GradeReportClient<$Result.GetResult<Prisma.$GradeReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GradeReports.
     * @param {GradeReportCreateManyArgs} args - Arguments to create many GradeReports.
     * @example
     * // Create many GradeReports
     * const gradeReport = await prisma.gradeReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GradeReportCreateManyArgs>(args?: SelectSubset<T, GradeReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GradeReports and returns the data saved in the database.
     * @param {GradeReportCreateManyAndReturnArgs} args - Arguments to create many GradeReports.
     * @example
     * // Create many GradeReports
     * const gradeReport = await prisma.gradeReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GradeReports and only return the `id`
     * const gradeReportWithIdOnly = await prisma.gradeReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GradeReportCreateManyAndReturnArgs>(args?: SelectSubset<T, GradeReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradeReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GradeReport.
     * @param {GradeReportDeleteArgs} args - Arguments to delete one GradeReport.
     * @example
     * // Delete one GradeReport
     * const GradeReport = await prisma.gradeReport.delete({
     *   where: {
     *     // ... filter to delete one GradeReport
     *   }
     * })
     * 
     */
    delete<T extends GradeReportDeleteArgs>(args: SelectSubset<T, GradeReportDeleteArgs<ExtArgs>>): Prisma__GradeReportClient<$Result.GetResult<Prisma.$GradeReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GradeReport.
     * @param {GradeReportUpdateArgs} args - Arguments to update one GradeReport.
     * @example
     * // Update one GradeReport
     * const gradeReport = await prisma.gradeReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GradeReportUpdateArgs>(args: SelectSubset<T, GradeReportUpdateArgs<ExtArgs>>): Prisma__GradeReportClient<$Result.GetResult<Prisma.$GradeReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GradeReports.
     * @param {GradeReportDeleteManyArgs} args - Arguments to filter GradeReports to delete.
     * @example
     * // Delete a few GradeReports
     * const { count } = await prisma.gradeReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GradeReportDeleteManyArgs>(args?: SelectSubset<T, GradeReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GradeReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GradeReports
     * const gradeReport = await prisma.gradeReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GradeReportUpdateManyArgs>(args: SelectSubset<T, GradeReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GradeReports and returns the data updated in the database.
     * @param {GradeReportUpdateManyAndReturnArgs} args - Arguments to update many GradeReports.
     * @example
     * // Update many GradeReports
     * const gradeReport = await prisma.gradeReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GradeReports and only return the `id`
     * const gradeReportWithIdOnly = await prisma.gradeReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GradeReportUpdateManyAndReturnArgs>(args: SelectSubset<T, GradeReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradeReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GradeReport.
     * @param {GradeReportUpsertArgs} args - Arguments to update or create a GradeReport.
     * @example
     * // Update or create a GradeReport
     * const gradeReport = await prisma.gradeReport.upsert({
     *   create: {
     *     // ... data to create a GradeReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GradeReport we want to update
     *   }
     * })
     */
    upsert<T extends GradeReportUpsertArgs>(args: SelectSubset<T, GradeReportUpsertArgs<ExtArgs>>): Prisma__GradeReportClient<$Result.GetResult<Prisma.$GradeReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GradeReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeReportCountArgs} args - Arguments to filter GradeReports to count.
     * @example
     * // Count the number of GradeReports
     * const count = await prisma.gradeReport.count({
     *   where: {
     *     // ... the filter for the GradeReports we want to count
     *   }
     * })
    **/
    count<T extends GradeReportCountArgs>(
      args?: Subset<T, GradeReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GradeReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GradeReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GradeReportAggregateArgs>(args: Subset<T, GradeReportAggregateArgs>): Prisma.PrismaPromise<GetGradeReportAggregateType<T>>

    /**
     * Group by GradeReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GradeReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GradeReportGroupByArgs['orderBy'] }
        : { orderBy?: GradeReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GradeReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGradeReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GradeReport model
   */
  readonly fields: GradeReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GradeReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GradeReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    semester<T extends SemesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SemesterDefaultArgs<ExtArgs>>): Prisma__SemesterClient<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GradeReport model
   */
  interface GradeReportFieldRefs {
    readonly id: FieldRef<"GradeReport", 'String'>
    readonly studentId: FieldRef<"GradeReport", 'String'>
    readonly semesterId: FieldRef<"GradeReport", 'String'>
    readonly overallGpa: FieldRef<"GradeReport", 'Float'>
    readonly generatedAt: FieldRef<"GradeReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GradeReport findUnique
   */
  export type GradeReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeReport
     */
    select?: GradeReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeReport
     */
    omit?: GradeReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeReportInclude<ExtArgs> | null
    /**
     * Filter, which GradeReport to fetch.
     */
    where: GradeReportWhereUniqueInput
  }

  /**
   * GradeReport findUniqueOrThrow
   */
  export type GradeReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeReport
     */
    select?: GradeReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeReport
     */
    omit?: GradeReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeReportInclude<ExtArgs> | null
    /**
     * Filter, which GradeReport to fetch.
     */
    where: GradeReportWhereUniqueInput
  }

  /**
   * GradeReport findFirst
   */
  export type GradeReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeReport
     */
    select?: GradeReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeReport
     */
    omit?: GradeReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeReportInclude<ExtArgs> | null
    /**
     * Filter, which GradeReport to fetch.
     */
    where?: GradeReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GradeReports to fetch.
     */
    orderBy?: GradeReportOrderByWithRelationInput | GradeReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GradeReports.
     */
    cursor?: GradeReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GradeReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GradeReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GradeReports.
     */
    distinct?: GradeReportScalarFieldEnum | GradeReportScalarFieldEnum[]
  }

  /**
   * GradeReport findFirstOrThrow
   */
  export type GradeReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeReport
     */
    select?: GradeReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeReport
     */
    omit?: GradeReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeReportInclude<ExtArgs> | null
    /**
     * Filter, which GradeReport to fetch.
     */
    where?: GradeReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GradeReports to fetch.
     */
    orderBy?: GradeReportOrderByWithRelationInput | GradeReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GradeReports.
     */
    cursor?: GradeReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GradeReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GradeReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GradeReports.
     */
    distinct?: GradeReportScalarFieldEnum | GradeReportScalarFieldEnum[]
  }

  /**
   * GradeReport findMany
   */
  export type GradeReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeReport
     */
    select?: GradeReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeReport
     */
    omit?: GradeReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeReportInclude<ExtArgs> | null
    /**
     * Filter, which GradeReports to fetch.
     */
    where?: GradeReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GradeReports to fetch.
     */
    orderBy?: GradeReportOrderByWithRelationInput | GradeReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GradeReports.
     */
    cursor?: GradeReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GradeReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GradeReports.
     */
    skip?: number
    distinct?: GradeReportScalarFieldEnum | GradeReportScalarFieldEnum[]
  }

  /**
   * GradeReport create
   */
  export type GradeReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeReport
     */
    select?: GradeReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeReport
     */
    omit?: GradeReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeReportInclude<ExtArgs> | null
    /**
     * The data needed to create a GradeReport.
     */
    data: XOR<GradeReportCreateInput, GradeReportUncheckedCreateInput>
  }

  /**
   * GradeReport createMany
   */
  export type GradeReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GradeReports.
     */
    data: GradeReportCreateManyInput | GradeReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GradeReport createManyAndReturn
   */
  export type GradeReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeReport
     */
    select?: GradeReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GradeReport
     */
    omit?: GradeReportOmit<ExtArgs> | null
    /**
     * The data used to create many GradeReports.
     */
    data: GradeReportCreateManyInput | GradeReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GradeReport update
   */
  export type GradeReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeReport
     */
    select?: GradeReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeReport
     */
    omit?: GradeReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeReportInclude<ExtArgs> | null
    /**
     * The data needed to update a GradeReport.
     */
    data: XOR<GradeReportUpdateInput, GradeReportUncheckedUpdateInput>
    /**
     * Choose, which GradeReport to update.
     */
    where: GradeReportWhereUniqueInput
  }

  /**
   * GradeReport updateMany
   */
  export type GradeReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GradeReports.
     */
    data: XOR<GradeReportUpdateManyMutationInput, GradeReportUncheckedUpdateManyInput>
    /**
     * Filter which GradeReports to update
     */
    where?: GradeReportWhereInput
    /**
     * Limit how many GradeReports to update.
     */
    limit?: number
  }

  /**
   * GradeReport updateManyAndReturn
   */
  export type GradeReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeReport
     */
    select?: GradeReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GradeReport
     */
    omit?: GradeReportOmit<ExtArgs> | null
    /**
     * The data used to update GradeReports.
     */
    data: XOR<GradeReportUpdateManyMutationInput, GradeReportUncheckedUpdateManyInput>
    /**
     * Filter which GradeReports to update
     */
    where?: GradeReportWhereInput
    /**
     * Limit how many GradeReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GradeReport upsert
   */
  export type GradeReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeReport
     */
    select?: GradeReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeReport
     */
    omit?: GradeReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeReportInclude<ExtArgs> | null
    /**
     * The filter to search for the GradeReport to update in case it exists.
     */
    where: GradeReportWhereUniqueInput
    /**
     * In case the GradeReport found by the `where` argument doesn't exist, create a new GradeReport with this data.
     */
    create: XOR<GradeReportCreateInput, GradeReportUncheckedCreateInput>
    /**
     * In case the GradeReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GradeReportUpdateInput, GradeReportUncheckedUpdateInput>
  }

  /**
   * GradeReport delete
   */
  export type GradeReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeReport
     */
    select?: GradeReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeReport
     */
    omit?: GradeReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeReportInclude<ExtArgs> | null
    /**
     * Filter which GradeReport to delete.
     */
    where: GradeReportWhereUniqueInput
  }

  /**
   * GradeReport deleteMany
   */
  export type GradeReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GradeReports to delete
     */
    where?: GradeReportWhereInput
    /**
     * Limit how many GradeReports to delete.
     */
    limit?: number
  }

  /**
   * GradeReport without action
   */
  export type GradeReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeReport
     */
    select?: GradeReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GradeReport
     */
    omit?: GradeReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeReportInclude<ExtArgs> | null
  }


  /**
   * Model Announcement
   */

  export type AggregateAnnouncement = {
    _count: AnnouncementCountAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  export type AnnouncementMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    authorId: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type AnnouncementMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    authorId: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type AnnouncementCountAggregateOutputType = {
    id: number
    title: number
    content: number
    authorId: number
    targetRoles: number
    targetClasses: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type AnnouncementMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    authorId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type AnnouncementMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    authorId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type AnnouncementCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    authorId?: true
    targetRoles?: true
    targetClasses?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type AnnouncementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcement to aggregate.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Announcements
    **/
    _count?: true | AnnouncementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnouncementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnouncementMaxAggregateInputType
  }

  export type GetAnnouncementAggregateType<T extends AnnouncementAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnouncement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncement[P]>
      : GetScalarType<T[P], AggregateAnnouncement[P]>
  }




  export type AnnouncementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithAggregationInput | AnnouncementOrderByWithAggregationInput[]
    by: AnnouncementScalarFieldEnum[] | AnnouncementScalarFieldEnum
    having?: AnnouncementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnouncementCountAggregateInputType | true
    _min?: AnnouncementMinAggregateInputType
    _max?: AnnouncementMaxAggregateInputType
  }

  export type AnnouncementGroupByOutputType = {
    id: string
    title: string
    content: string
    authorId: string
    targetRoles: string[]
    targetClasses: string[]
    createdAt: Date
    expiresAt: Date | null
    _count: AnnouncementCountAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  type GetAnnouncementGroupByPayload<T extends AnnouncementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnouncementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnouncementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
            : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
        }
      >
    >


  export type AnnouncementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    authorId?: boolean
    targetRoles?: boolean
    targetClasses?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    authorId?: boolean
    targetRoles?: boolean
    targetClasses?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    authorId?: boolean
    targetRoles?: boolean
    targetClasses?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    authorId?: boolean
    targetRoles?: boolean
    targetClasses?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type AnnouncementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "authorId" | "targetRoles" | "targetClasses" | "createdAt" | "expiresAt", ExtArgs["result"]["announcement"]>
  export type AnnouncementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AnnouncementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AnnouncementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AnnouncementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Announcement"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      authorId: string
      targetRoles: string[]
      targetClasses: string[]
      createdAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["announcement"]>
    composites: {}
  }

  type AnnouncementGetPayload<S extends boolean | null | undefined | AnnouncementDefaultArgs> = $Result.GetResult<Prisma.$AnnouncementPayload, S>

  type AnnouncementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnnouncementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnnouncementCountAggregateInputType | true
    }

  export interface AnnouncementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Announcement'], meta: { name: 'Announcement' } }
    /**
     * Find zero or one Announcement that matches the filter.
     * @param {AnnouncementFindUniqueArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnnouncementFindUniqueArgs>(args: SelectSubset<T, AnnouncementFindUniqueArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Announcement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnnouncementFindUniqueOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnnouncementFindUniqueOrThrowArgs>(args: SelectSubset<T, AnnouncementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnnouncementFindFirstArgs>(args?: SelectSubset<T, AnnouncementFindFirstArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnnouncementFindFirstOrThrowArgs>(args?: SelectSubset<T, AnnouncementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Announcements
     * const announcements = await prisma.announcement.findMany()
     * 
     * // Get first 10 Announcements
     * const announcements = await prisma.announcement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const announcementWithIdOnly = await prisma.announcement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnnouncementFindManyArgs>(args?: SelectSubset<T, AnnouncementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Announcement.
     * @param {AnnouncementCreateArgs} args - Arguments to create a Announcement.
     * @example
     * // Create one Announcement
     * const Announcement = await prisma.announcement.create({
     *   data: {
     *     // ... data to create a Announcement
     *   }
     * })
     * 
     */
    create<T extends AnnouncementCreateArgs>(args: SelectSubset<T, AnnouncementCreateArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Announcements.
     * @param {AnnouncementCreateManyArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnnouncementCreateManyArgs>(args?: SelectSubset<T, AnnouncementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Announcements and returns the data saved in the database.
     * @param {AnnouncementCreateManyAndReturnArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Announcements and only return the `id`
     * const announcementWithIdOnly = await prisma.announcement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnnouncementCreateManyAndReturnArgs>(args?: SelectSubset<T, AnnouncementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Announcement.
     * @param {AnnouncementDeleteArgs} args - Arguments to delete one Announcement.
     * @example
     * // Delete one Announcement
     * const Announcement = await prisma.announcement.delete({
     *   where: {
     *     // ... filter to delete one Announcement
     *   }
     * })
     * 
     */
    delete<T extends AnnouncementDeleteArgs>(args: SelectSubset<T, AnnouncementDeleteArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Announcement.
     * @param {AnnouncementUpdateArgs} args - Arguments to update one Announcement.
     * @example
     * // Update one Announcement
     * const announcement = await prisma.announcement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnnouncementUpdateArgs>(args: SelectSubset<T, AnnouncementUpdateArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Announcements.
     * @param {AnnouncementDeleteManyArgs} args - Arguments to filter Announcements to delete.
     * @example
     * // Delete a few Announcements
     * const { count } = await prisma.announcement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnnouncementDeleteManyArgs>(args?: SelectSubset<T, AnnouncementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnnouncementUpdateManyArgs>(args: SelectSubset<T, AnnouncementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements and returns the data updated in the database.
     * @param {AnnouncementUpdateManyAndReturnArgs} args - Arguments to update many Announcements.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Announcements and only return the `id`
     * const announcementWithIdOnly = await prisma.announcement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnnouncementUpdateManyAndReturnArgs>(args: SelectSubset<T, AnnouncementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Announcement.
     * @param {AnnouncementUpsertArgs} args - Arguments to update or create a Announcement.
     * @example
     * // Update or create a Announcement
     * const announcement = await prisma.announcement.upsert({
     *   create: {
     *     // ... data to create a Announcement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Announcement we want to update
     *   }
     * })
     */
    upsert<T extends AnnouncementUpsertArgs>(args: SelectSubset<T, AnnouncementUpsertArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementCountArgs} args - Arguments to filter Announcements to count.
     * @example
     * // Count the number of Announcements
     * const count = await prisma.announcement.count({
     *   where: {
     *     // ... the filter for the Announcements we want to count
     *   }
     * })
    **/
    count<T extends AnnouncementCountArgs>(
      args?: Subset<T, AnnouncementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnouncementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnouncementAggregateArgs>(args: Subset<T, AnnouncementAggregateArgs>): Prisma.PrismaPromise<GetAnnouncementAggregateType<T>>

    /**
     * Group by Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnouncementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnouncementGroupByArgs['orderBy'] }
        : { orderBy?: AnnouncementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnouncementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnouncementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Announcement model
   */
  readonly fields: AnnouncementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Announcement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnouncementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Announcement model
   */
  interface AnnouncementFieldRefs {
    readonly id: FieldRef<"Announcement", 'String'>
    readonly title: FieldRef<"Announcement", 'String'>
    readonly content: FieldRef<"Announcement", 'String'>
    readonly authorId: FieldRef<"Announcement", 'String'>
    readonly targetRoles: FieldRef<"Announcement", 'String[]'>
    readonly targetClasses: FieldRef<"Announcement", 'String[]'>
    readonly createdAt: FieldRef<"Announcement", 'DateTime'>
    readonly expiresAt: FieldRef<"Announcement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Announcement findUnique
   */
  export type AnnouncementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement findUniqueOrThrow
   */
  export type AnnouncementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement findFirst
   */
  export type AnnouncementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement findFirstOrThrow
   */
  export type AnnouncementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement findMany
   */
  export type AnnouncementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcements to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement create
   */
  export type AnnouncementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to create a Announcement.
     */
    data: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
  }

  /**
   * Announcement createMany
   */
  export type AnnouncementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Announcement createManyAndReturn
   */
  export type AnnouncementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Announcement update
   */
  export type AnnouncementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to update a Announcement.
     */
    data: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
    /**
     * Choose, which Announcement to update.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement updateMany
   */
  export type AnnouncementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to update.
     */
    limit?: number
  }

  /**
   * Announcement updateManyAndReturn
   */
  export type AnnouncementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Announcement upsert
   */
  export type AnnouncementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The filter to search for the Announcement to update in case it exists.
     */
    where: AnnouncementWhereUniqueInput
    /**
     * In case the Announcement found by the `where` argument doesn't exist, create a new Announcement with this data.
     */
    create: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
    /**
     * In case the Announcement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
  }

  /**
   * Announcement delete
   */
  export type AnnouncementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter which Announcement to delete.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement deleteMany
   */
  export type AnnouncementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcements to delete
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to delete.
     */
    limit?: number
  }

  /**
   * Announcement without action
   */
  export type AnnouncementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    senderId: string | null
    recipientId: string | null
    subject: string | null
    content: string | null
    isRead: boolean | null
    sentAt: Date | null
    parentMessageId: string | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    senderId: string | null
    recipientId: string | null
    subject: string | null
    content: string | null
    isRead: boolean | null
    sentAt: Date | null
    parentMessageId: string | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    senderId: number
    recipientId: number
    subject: number
    content: number
    isRead: number
    sentAt: number
    parentMessageId: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    senderId?: true
    recipientId?: true
    subject?: true
    content?: true
    isRead?: true
    sentAt?: true
    parentMessageId?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    senderId?: true
    recipientId?: true
    subject?: true
    content?: true
    isRead?: true
    sentAt?: true
    parentMessageId?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    senderId?: true
    recipientId?: true
    subject?: true
    content?: true
    isRead?: true
    sentAt?: true
    parentMessageId?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    senderId: string
    recipientId: string
    subject: string
    content: string
    isRead: boolean
    sentAt: Date
    parentMessageId: string | null
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    recipientId?: boolean
    subject?: boolean
    content?: boolean
    isRead?: boolean
    sentAt?: boolean
    parentMessageId?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    parentMessage?: boolean | Message$parentMessageArgs<ExtArgs>
    childMessages?: boolean | Message$childMessagesArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    recipientId?: boolean
    subject?: boolean
    content?: boolean
    isRead?: boolean
    sentAt?: boolean
    parentMessageId?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    parentMessage?: boolean | Message$parentMessageArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    recipientId?: boolean
    subject?: boolean
    content?: boolean
    isRead?: boolean
    sentAt?: boolean
    parentMessageId?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    parentMessage?: boolean | Message$parentMessageArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    senderId?: boolean
    recipientId?: boolean
    subject?: boolean
    content?: boolean
    isRead?: boolean
    sentAt?: boolean
    parentMessageId?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "senderId" | "recipientId" | "subject" | "content" | "isRead" | "sentAt" | "parentMessageId", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    parentMessage?: boolean | Message$parentMessageArgs<ExtArgs>
    childMessages?: boolean | Message$childMessagesArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    parentMessage?: boolean | Message$parentMessageArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    parentMessage?: boolean | Message$parentMessageArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      recipient: Prisma.$UserPayload<ExtArgs>
      parentMessage: Prisma.$MessagePayload<ExtArgs> | null
      childMessages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      senderId: string
      recipientId: string
      subject: string
      content: string
      isRead: boolean
      sentAt: Date
      parentMessageId: string | null
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    recipient<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parentMessage<T extends Message$parentMessageArgs<ExtArgs> = {}>(args?: Subset<T, Message$parentMessageArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    childMessages<T extends Message$childMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Message$childMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly recipientId: FieldRef<"Message", 'String'>
    readonly subject: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly isRead: FieldRef<"Message", 'Boolean'>
    readonly sentAt: FieldRef<"Message", 'DateTime'>
    readonly parentMessageId: FieldRef<"Message", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.parentMessage
   */
  export type Message$parentMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
  }

  /**
   * Message.childMessages
   */
  export type Message$childMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    content: string | null
    type: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    content: string | null
    type: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    content: number
    type: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    type?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    type?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    type?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    title: string
    content: string
    type: string
    isRead: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "content" | "type" | "isRead" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      content: string
      type: string
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly content: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    title: string | null
    fileName: string | null
    filePath: string | null
    fileSize: number | null
    mimeType: string | null
    uploadedById: string | null
    category: string | null
    classId: string | null
    subjectId: string | null
    uploadedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    title: string | null
    fileName: string | null
    filePath: string | null
    fileSize: number | null
    mimeType: string | null
    uploadedById: string | null
    category: string | null
    classId: string | null
    subjectId: string | null
    uploadedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    title: number
    fileName: number
    filePath: number
    fileSize: number
    mimeType: number
    uploadedById: number
    category: number
    classId: number
    subjectId: number
    uploadedAt: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    fileSize?: true
  }

  export type DocumentSumAggregateInputType = {
    fileSize?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    title?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    uploadedById?: true
    category?: true
    classId?: true
    subjectId?: true
    uploadedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    title?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    uploadedById?: true
    category?: true
    classId?: true
    subjectId?: true
    uploadedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    title?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    uploadedById?: true
    category?: true
    classId?: true
    subjectId?: true
    uploadedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    title: string
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedById: string
    category: string
    classId: string | null
    subjectId: string | null
    uploadedAt: Date
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadedById?: boolean
    category?: boolean
    classId?: boolean
    subjectId?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | Document$classArgs<ExtArgs>
    subject?: boolean | Document$subjectArgs<ExtArgs>
    permissions?: boolean | Document$permissionsArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadedById?: boolean
    category?: boolean
    classId?: boolean
    subjectId?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | Document$classArgs<ExtArgs>
    subject?: boolean | Document$subjectArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadedById?: boolean
    category?: boolean
    classId?: boolean
    subjectId?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | Document$classArgs<ExtArgs>
    subject?: boolean | Document$subjectArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    title?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadedById?: boolean
    category?: boolean
    classId?: boolean
    subjectId?: boolean
    uploadedAt?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "fileName" | "filePath" | "fileSize" | "mimeType" | "uploadedById" | "category" | "classId" | "subjectId" | "uploadedAt", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | Document$classArgs<ExtArgs>
    subject?: boolean | Document$subjectArgs<ExtArgs>
    permissions?: boolean | Document$permissionsArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | Document$classArgs<ExtArgs>
    subject?: boolean | Document$subjectArgs<ExtArgs>
  }
  export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | Document$classArgs<ExtArgs>
    subject?: boolean | Document$subjectArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      uploadedBy: Prisma.$UserPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs> | null
      subject: Prisma.$SubjectPayload<ExtArgs> | null
      permissions: Prisma.$DocumentPermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      fileName: string
      filePath: string
      fileSize: number
      mimeType: string
      uploadedById: string
      category: string
      classId: string | null
      subjectId: string | null
      uploadedAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    uploadedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    class<T extends Document$classArgs<ExtArgs> = {}>(args?: Subset<T, Document$classArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subject<T extends Document$subjectArgs<ExtArgs> = {}>(args?: Subset<T, Document$subjectArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    permissions<T extends Document$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Document$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly title: FieldRef<"Document", 'String'>
    readonly fileName: FieldRef<"Document", 'String'>
    readonly filePath: FieldRef<"Document", 'String'>
    readonly fileSize: FieldRef<"Document", 'Int'>
    readonly mimeType: FieldRef<"Document", 'String'>
    readonly uploadedById: FieldRef<"Document", 'String'>
    readonly category: FieldRef<"Document", 'String'>
    readonly classId: FieldRef<"Document", 'String'>
    readonly subjectId: FieldRef<"Document", 'String'>
    readonly uploadedAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document.class
   */
  export type Document$classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
  }

  /**
   * Document.subject
   */
  export type Document$subjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
  }

  /**
   * Document.permissions
   */
  export type Document$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPermission
     */
    select?: DocumentPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPermission
     */
    omit?: DocumentPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPermissionInclude<ExtArgs> | null
    where?: DocumentPermissionWhereInput
    orderBy?: DocumentPermissionOrderByWithRelationInput | DocumentPermissionOrderByWithRelationInput[]
    cursor?: DocumentPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentPermissionScalarFieldEnum | DocumentPermissionScalarFieldEnum[]
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model DocumentPermission
   */

  export type AggregateDocumentPermission = {
    _count: DocumentPermissionCountAggregateOutputType | null
    _min: DocumentPermissionMinAggregateOutputType | null
    _max: DocumentPermissionMaxAggregateOutputType | null
  }

  export type DocumentPermissionMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    userId: string | null
    permissionType: string | null
  }

  export type DocumentPermissionMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    userId: string | null
    permissionType: string | null
  }

  export type DocumentPermissionCountAggregateOutputType = {
    id: number
    documentId: number
    userId: number
    permissionType: number
    _all: number
  }


  export type DocumentPermissionMinAggregateInputType = {
    id?: true
    documentId?: true
    userId?: true
    permissionType?: true
  }

  export type DocumentPermissionMaxAggregateInputType = {
    id?: true
    documentId?: true
    userId?: true
    permissionType?: true
  }

  export type DocumentPermissionCountAggregateInputType = {
    id?: true
    documentId?: true
    userId?: true
    permissionType?: true
    _all?: true
  }

  export type DocumentPermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentPermission to aggregate.
     */
    where?: DocumentPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentPermissions to fetch.
     */
    orderBy?: DocumentPermissionOrderByWithRelationInput | DocumentPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentPermissions
    **/
    _count?: true | DocumentPermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentPermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentPermissionMaxAggregateInputType
  }

  export type GetDocumentPermissionAggregateType<T extends DocumentPermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentPermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentPermission[P]>
      : GetScalarType<T[P], AggregateDocumentPermission[P]>
  }




  export type DocumentPermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentPermissionWhereInput
    orderBy?: DocumentPermissionOrderByWithAggregationInput | DocumentPermissionOrderByWithAggregationInput[]
    by: DocumentPermissionScalarFieldEnum[] | DocumentPermissionScalarFieldEnum
    having?: DocumentPermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentPermissionCountAggregateInputType | true
    _min?: DocumentPermissionMinAggregateInputType
    _max?: DocumentPermissionMaxAggregateInputType
  }

  export type DocumentPermissionGroupByOutputType = {
    id: string
    documentId: string
    userId: string
    permissionType: string
    _count: DocumentPermissionCountAggregateOutputType | null
    _min: DocumentPermissionMinAggregateOutputType | null
    _max: DocumentPermissionMaxAggregateOutputType | null
  }

  type GetDocumentPermissionGroupByPayload<T extends DocumentPermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentPermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentPermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentPermissionGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentPermissionGroupByOutputType[P]>
        }
      >
    >


  export type DocumentPermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    userId?: boolean
    permissionType?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentPermission"]>

  export type DocumentPermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    userId?: boolean
    permissionType?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentPermission"]>

  export type DocumentPermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    userId?: boolean
    permissionType?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentPermission"]>

  export type DocumentPermissionSelectScalar = {
    id?: boolean
    documentId?: boolean
    userId?: boolean
    permissionType?: boolean
  }

  export type DocumentPermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "documentId" | "userId" | "permissionType", ExtArgs["result"]["documentPermission"]>
  export type DocumentPermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DocumentPermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DocumentPermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DocumentPermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentPermission"
    objects: {
      document: Prisma.$DocumentPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentId: string
      userId: string
      permissionType: string
    }, ExtArgs["result"]["documentPermission"]>
    composites: {}
  }

  type DocumentPermissionGetPayload<S extends boolean | null | undefined | DocumentPermissionDefaultArgs> = $Result.GetResult<Prisma.$DocumentPermissionPayload, S>

  type DocumentPermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentPermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentPermissionCountAggregateInputType | true
    }

  export interface DocumentPermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentPermission'], meta: { name: 'DocumentPermission' } }
    /**
     * Find zero or one DocumentPermission that matches the filter.
     * @param {DocumentPermissionFindUniqueArgs} args - Arguments to find a DocumentPermission
     * @example
     * // Get one DocumentPermission
     * const documentPermission = await prisma.documentPermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentPermissionFindUniqueArgs>(args: SelectSubset<T, DocumentPermissionFindUniqueArgs<ExtArgs>>): Prisma__DocumentPermissionClient<$Result.GetResult<Prisma.$DocumentPermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentPermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentPermissionFindUniqueOrThrowArgs} args - Arguments to find a DocumentPermission
     * @example
     * // Get one DocumentPermission
     * const documentPermission = await prisma.documentPermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentPermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentPermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentPermissionClient<$Result.GetResult<Prisma.$DocumentPermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentPermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentPermissionFindFirstArgs} args - Arguments to find a DocumentPermission
     * @example
     * // Get one DocumentPermission
     * const documentPermission = await prisma.documentPermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentPermissionFindFirstArgs>(args?: SelectSubset<T, DocumentPermissionFindFirstArgs<ExtArgs>>): Prisma__DocumentPermissionClient<$Result.GetResult<Prisma.$DocumentPermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentPermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentPermissionFindFirstOrThrowArgs} args - Arguments to find a DocumentPermission
     * @example
     * // Get one DocumentPermission
     * const documentPermission = await prisma.documentPermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentPermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentPermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentPermissionClient<$Result.GetResult<Prisma.$DocumentPermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentPermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentPermissions
     * const documentPermissions = await prisma.documentPermission.findMany()
     * 
     * // Get first 10 DocumentPermissions
     * const documentPermissions = await prisma.documentPermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentPermissionWithIdOnly = await prisma.documentPermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentPermissionFindManyArgs>(args?: SelectSubset<T, DocumentPermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentPermission.
     * @param {DocumentPermissionCreateArgs} args - Arguments to create a DocumentPermission.
     * @example
     * // Create one DocumentPermission
     * const DocumentPermission = await prisma.documentPermission.create({
     *   data: {
     *     // ... data to create a DocumentPermission
     *   }
     * })
     * 
     */
    create<T extends DocumentPermissionCreateArgs>(args: SelectSubset<T, DocumentPermissionCreateArgs<ExtArgs>>): Prisma__DocumentPermissionClient<$Result.GetResult<Prisma.$DocumentPermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentPermissions.
     * @param {DocumentPermissionCreateManyArgs} args - Arguments to create many DocumentPermissions.
     * @example
     * // Create many DocumentPermissions
     * const documentPermission = await prisma.documentPermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentPermissionCreateManyArgs>(args?: SelectSubset<T, DocumentPermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentPermissions and returns the data saved in the database.
     * @param {DocumentPermissionCreateManyAndReturnArgs} args - Arguments to create many DocumentPermissions.
     * @example
     * // Create many DocumentPermissions
     * const documentPermission = await prisma.documentPermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentPermissions and only return the `id`
     * const documentPermissionWithIdOnly = await prisma.documentPermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentPermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentPermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DocumentPermission.
     * @param {DocumentPermissionDeleteArgs} args - Arguments to delete one DocumentPermission.
     * @example
     * // Delete one DocumentPermission
     * const DocumentPermission = await prisma.documentPermission.delete({
     *   where: {
     *     // ... filter to delete one DocumentPermission
     *   }
     * })
     * 
     */
    delete<T extends DocumentPermissionDeleteArgs>(args: SelectSubset<T, DocumentPermissionDeleteArgs<ExtArgs>>): Prisma__DocumentPermissionClient<$Result.GetResult<Prisma.$DocumentPermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentPermission.
     * @param {DocumentPermissionUpdateArgs} args - Arguments to update one DocumentPermission.
     * @example
     * // Update one DocumentPermission
     * const documentPermission = await prisma.documentPermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentPermissionUpdateArgs>(args: SelectSubset<T, DocumentPermissionUpdateArgs<ExtArgs>>): Prisma__DocumentPermissionClient<$Result.GetResult<Prisma.$DocumentPermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentPermissions.
     * @param {DocumentPermissionDeleteManyArgs} args - Arguments to filter DocumentPermissions to delete.
     * @example
     * // Delete a few DocumentPermissions
     * const { count } = await prisma.documentPermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentPermissionDeleteManyArgs>(args?: SelectSubset<T, DocumentPermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentPermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentPermissions
     * const documentPermission = await prisma.documentPermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentPermissionUpdateManyArgs>(args: SelectSubset<T, DocumentPermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentPermissions and returns the data updated in the database.
     * @param {DocumentPermissionUpdateManyAndReturnArgs} args - Arguments to update many DocumentPermissions.
     * @example
     * // Update many DocumentPermissions
     * const documentPermission = await prisma.documentPermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DocumentPermissions and only return the `id`
     * const documentPermissionWithIdOnly = await prisma.documentPermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentPermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentPermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DocumentPermission.
     * @param {DocumentPermissionUpsertArgs} args - Arguments to update or create a DocumentPermission.
     * @example
     * // Update or create a DocumentPermission
     * const documentPermission = await prisma.documentPermission.upsert({
     *   create: {
     *     // ... data to create a DocumentPermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentPermission we want to update
     *   }
     * })
     */
    upsert<T extends DocumentPermissionUpsertArgs>(args: SelectSubset<T, DocumentPermissionUpsertArgs<ExtArgs>>): Prisma__DocumentPermissionClient<$Result.GetResult<Prisma.$DocumentPermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentPermissionCountArgs} args - Arguments to filter DocumentPermissions to count.
     * @example
     * // Count the number of DocumentPermissions
     * const count = await prisma.documentPermission.count({
     *   where: {
     *     // ... the filter for the DocumentPermissions we want to count
     *   }
     * })
    **/
    count<T extends DocumentPermissionCountArgs>(
      args?: Subset<T, DocumentPermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentPermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentPermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentPermissionAggregateArgs>(args: Subset<T, DocumentPermissionAggregateArgs>): Prisma.PrismaPromise<GetDocumentPermissionAggregateType<T>>

    /**
     * Group by DocumentPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentPermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentPermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentPermissionGroupByArgs['orderBy'] }
        : { orderBy?: DocumentPermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentPermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentPermission model
   */
  readonly fields: DocumentPermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentPermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentPermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentPermission model
   */
  interface DocumentPermissionFieldRefs {
    readonly id: FieldRef<"DocumentPermission", 'String'>
    readonly documentId: FieldRef<"DocumentPermission", 'String'>
    readonly userId: FieldRef<"DocumentPermission", 'String'>
    readonly permissionType: FieldRef<"DocumentPermission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DocumentPermission findUnique
   */
  export type DocumentPermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPermission
     */
    select?: DocumentPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPermission
     */
    omit?: DocumentPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPermissionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentPermission to fetch.
     */
    where: DocumentPermissionWhereUniqueInput
  }

  /**
   * DocumentPermission findUniqueOrThrow
   */
  export type DocumentPermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPermission
     */
    select?: DocumentPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPermission
     */
    omit?: DocumentPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPermissionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentPermission to fetch.
     */
    where: DocumentPermissionWhereUniqueInput
  }

  /**
   * DocumentPermission findFirst
   */
  export type DocumentPermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPermission
     */
    select?: DocumentPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPermission
     */
    omit?: DocumentPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPermissionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentPermission to fetch.
     */
    where?: DocumentPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentPermissions to fetch.
     */
    orderBy?: DocumentPermissionOrderByWithRelationInput | DocumentPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentPermissions.
     */
    cursor?: DocumentPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentPermissions.
     */
    distinct?: DocumentPermissionScalarFieldEnum | DocumentPermissionScalarFieldEnum[]
  }

  /**
   * DocumentPermission findFirstOrThrow
   */
  export type DocumentPermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPermission
     */
    select?: DocumentPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPermission
     */
    omit?: DocumentPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPermissionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentPermission to fetch.
     */
    where?: DocumentPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentPermissions to fetch.
     */
    orderBy?: DocumentPermissionOrderByWithRelationInput | DocumentPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentPermissions.
     */
    cursor?: DocumentPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentPermissions.
     */
    distinct?: DocumentPermissionScalarFieldEnum | DocumentPermissionScalarFieldEnum[]
  }

  /**
   * DocumentPermission findMany
   */
  export type DocumentPermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPermission
     */
    select?: DocumentPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPermission
     */
    omit?: DocumentPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPermissionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentPermissions to fetch.
     */
    where?: DocumentPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentPermissions to fetch.
     */
    orderBy?: DocumentPermissionOrderByWithRelationInput | DocumentPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentPermissions.
     */
    cursor?: DocumentPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentPermissions.
     */
    skip?: number
    distinct?: DocumentPermissionScalarFieldEnum | DocumentPermissionScalarFieldEnum[]
  }

  /**
   * DocumentPermission create
   */
  export type DocumentPermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPermission
     */
    select?: DocumentPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPermission
     */
    omit?: DocumentPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentPermission.
     */
    data: XOR<DocumentPermissionCreateInput, DocumentPermissionUncheckedCreateInput>
  }

  /**
   * DocumentPermission createMany
   */
  export type DocumentPermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentPermissions.
     */
    data: DocumentPermissionCreateManyInput | DocumentPermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentPermission createManyAndReturn
   */
  export type DocumentPermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPermission
     */
    select?: DocumentPermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPermission
     */
    omit?: DocumentPermissionOmit<ExtArgs> | null
    /**
     * The data used to create many DocumentPermissions.
     */
    data: DocumentPermissionCreateManyInput | DocumentPermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentPermission update
   */
  export type DocumentPermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPermission
     */
    select?: DocumentPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPermission
     */
    omit?: DocumentPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentPermission.
     */
    data: XOR<DocumentPermissionUpdateInput, DocumentPermissionUncheckedUpdateInput>
    /**
     * Choose, which DocumentPermission to update.
     */
    where: DocumentPermissionWhereUniqueInput
  }

  /**
   * DocumentPermission updateMany
   */
  export type DocumentPermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentPermissions.
     */
    data: XOR<DocumentPermissionUpdateManyMutationInput, DocumentPermissionUncheckedUpdateManyInput>
    /**
     * Filter which DocumentPermissions to update
     */
    where?: DocumentPermissionWhereInput
    /**
     * Limit how many DocumentPermissions to update.
     */
    limit?: number
  }

  /**
   * DocumentPermission updateManyAndReturn
   */
  export type DocumentPermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPermission
     */
    select?: DocumentPermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPermission
     */
    omit?: DocumentPermissionOmit<ExtArgs> | null
    /**
     * The data used to update DocumentPermissions.
     */
    data: XOR<DocumentPermissionUpdateManyMutationInput, DocumentPermissionUncheckedUpdateManyInput>
    /**
     * Filter which DocumentPermissions to update
     */
    where?: DocumentPermissionWhereInput
    /**
     * Limit how many DocumentPermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentPermission upsert
   */
  export type DocumentPermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPermission
     */
    select?: DocumentPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPermission
     */
    omit?: DocumentPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentPermission to update in case it exists.
     */
    where: DocumentPermissionWhereUniqueInput
    /**
     * In case the DocumentPermission found by the `where` argument doesn't exist, create a new DocumentPermission with this data.
     */
    create: XOR<DocumentPermissionCreateInput, DocumentPermissionUncheckedCreateInput>
    /**
     * In case the DocumentPermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentPermissionUpdateInput, DocumentPermissionUncheckedUpdateInput>
  }

  /**
   * DocumentPermission delete
   */
  export type DocumentPermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPermission
     */
    select?: DocumentPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPermission
     */
    omit?: DocumentPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPermissionInclude<ExtArgs> | null
    /**
     * Filter which DocumentPermission to delete.
     */
    where: DocumentPermissionWhereUniqueInput
  }

  /**
   * DocumentPermission deleteMany
   */
  export type DocumentPermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentPermissions to delete
     */
    where?: DocumentPermissionWhereInput
    /**
     * Limit how many DocumentPermissions to delete.
     */
    limit?: number
  }

  /**
   * DocumentPermission without action
   */
  export type DocumentPermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPermission
     */
    select?: DocumentPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPermission
     */
    omit?: DocumentPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPermissionInclude<ExtArgs> | null
  }


  /**
   * Model Exam
   */

  export type AggregateExam = {
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  export type ExamAvgAggregateOutputType = {
    duration: number | null
    maxScore: number | null
  }

  export type ExamSumAggregateOutputType = {
    duration: number | null
    maxScore: number | null
  }

  export type ExamMinAggregateOutputType = {
    id: string | null
    title: string | null
    subjectId: string | null
    classId: string | null
    type: string | null
    date: Date | null
    duration: number | null
    maxScore: number | null
    status: string | null
    instructions: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamMaxAggregateOutputType = {
    id: string | null
    title: string | null
    subjectId: string | null
    classId: string | null
    type: string | null
    date: Date | null
    duration: number | null
    maxScore: number | null
    status: string | null
    instructions: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamCountAggregateOutputType = {
    id: number
    title: number
    subjectId: number
    classId: number
    type: number
    date: number
    duration: number
    maxScore: number
    status: number
    instructions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExamAvgAggregateInputType = {
    duration?: true
    maxScore?: true
  }

  export type ExamSumAggregateInputType = {
    duration?: true
    maxScore?: true
  }

  export type ExamMinAggregateInputType = {
    id?: true
    title?: true
    subjectId?: true
    classId?: true
    type?: true
    date?: true
    duration?: true
    maxScore?: true
    status?: true
    instructions?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamMaxAggregateInputType = {
    id?: true
    title?: true
    subjectId?: true
    classId?: true
    type?: true
    date?: true
    duration?: true
    maxScore?: true
    status?: true
    instructions?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamCountAggregateInputType = {
    id?: true
    title?: true
    subjectId?: true
    classId?: true
    type?: true
    date?: true
    duration?: true
    maxScore?: true
    status?: true
    instructions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exam to aggregate.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exams
    **/
    _count?: true | ExamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamMaxAggregateInputType
  }

  export type GetExamAggregateType<T extends ExamAggregateArgs> = {
        [P in keyof T & keyof AggregateExam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExam[P]>
      : GetScalarType<T[P], AggregateExam[P]>
  }




  export type ExamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithAggregationInput | ExamOrderByWithAggregationInput[]
    by: ExamScalarFieldEnum[] | ExamScalarFieldEnum
    having?: ExamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamCountAggregateInputType | true
    _avg?: ExamAvgAggregateInputType
    _sum?: ExamSumAggregateInputType
    _min?: ExamMinAggregateInputType
    _max?: ExamMaxAggregateInputType
  }

  export type ExamGroupByOutputType = {
    id: string
    title: string
    subjectId: string
    classId: string
    type: string
    date: Date
    duration: number
    maxScore: number
    status: string
    instructions: string | null
    createdAt: Date
    updatedAt: Date
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  type GetExamGroupByPayload<T extends ExamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamGroupByOutputType[P]>
            : GetScalarType<T[P], ExamGroupByOutputType[P]>
        }
      >
    >


  export type ExamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subjectId?: boolean
    classId?: boolean
    type?: boolean
    date?: boolean
    duration?: boolean
    maxScore?: boolean
    status?: boolean
    instructions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subjectId?: boolean
    classId?: boolean
    type?: boolean
    date?: boolean
    duration?: boolean
    maxScore?: boolean
    status?: boolean
    instructions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subjectId?: boolean
    classId?: boolean
    type?: boolean
    date?: boolean
    duration?: boolean
    maxScore?: boolean
    status?: boolean
    instructions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectScalar = {
    id?: boolean
    title?: boolean
    subjectId?: boolean
    classId?: boolean
    type?: boolean
    date?: boolean
    duration?: boolean
    maxScore?: boolean
    status?: boolean
    instructions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "subjectId" | "classId" | "type" | "date" | "duration" | "maxScore" | "status" | "instructions" | "createdAt" | "updatedAt", ExtArgs["result"]["exam"]>

  export type $ExamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exam"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      subjectId: string
      classId: string
      type: string
      date: Date
      duration: number
      maxScore: number
      status: string
      instructions: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["exam"]>
    composites: {}
  }

  type ExamGetPayload<S extends boolean | null | undefined | ExamDefaultArgs> = $Result.GetResult<Prisma.$ExamPayload, S>

  type ExamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamCountAggregateInputType | true
    }

  export interface ExamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exam'], meta: { name: 'Exam' } }
    /**
     * Find zero or one Exam that matches the filter.
     * @param {ExamFindUniqueArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamFindUniqueArgs>(args: SelectSubset<T, ExamFindUniqueArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Exam that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamFindUniqueOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamFindFirstArgs>(args?: SelectSubset<T, ExamFindFirstArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exams
     * const exams = await prisma.exam.findMany()
     * 
     * // Get first 10 Exams
     * const exams = await prisma.exam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examWithIdOnly = await prisma.exam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamFindManyArgs>(args?: SelectSubset<T, ExamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Exam.
     * @param {ExamCreateArgs} args - Arguments to create a Exam.
     * @example
     * // Create one Exam
     * const Exam = await prisma.exam.create({
     *   data: {
     *     // ... data to create a Exam
     *   }
     * })
     * 
     */
    create<T extends ExamCreateArgs>(args: SelectSubset<T, ExamCreateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Exams.
     * @param {ExamCreateManyArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamCreateManyArgs>(args?: SelectSubset<T, ExamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exams and returns the data saved in the database.
     * @param {ExamCreateManyAndReturnArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exams and only return the `id`
     * const examWithIdOnly = await prisma.exam.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Exam.
     * @param {ExamDeleteArgs} args - Arguments to delete one Exam.
     * @example
     * // Delete one Exam
     * const Exam = await prisma.exam.delete({
     *   where: {
     *     // ... filter to delete one Exam
     *   }
     * })
     * 
     */
    delete<T extends ExamDeleteArgs>(args: SelectSubset<T, ExamDeleteArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Exam.
     * @param {ExamUpdateArgs} args - Arguments to update one Exam.
     * @example
     * // Update one Exam
     * const exam = await prisma.exam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamUpdateArgs>(args: SelectSubset<T, ExamUpdateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Exams.
     * @param {ExamDeleteManyArgs} args - Arguments to filter Exams to delete.
     * @example
     * // Delete a few Exams
     * const { count } = await prisma.exam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamDeleteManyArgs>(args?: SelectSubset<T, ExamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exams
     * const exam = await prisma.exam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamUpdateManyArgs>(args: SelectSubset<T, ExamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams and returns the data updated in the database.
     * @param {ExamUpdateManyAndReturnArgs} args - Arguments to update many Exams.
     * @example
     * // Update many Exams
     * const exam = await prisma.exam.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Exams and only return the `id`
     * const examWithIdOnly = await prisma.exam.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExamUpdateManyAndReturnArgs>(args: SelectSubset<T, ExamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Exam.
     * @param {ExamUpsertArgs} args - Arguments to update or create a Exam.
     * @example
     * // Update or create a Exam
     * const exam = await prisma.exam.upsert({
     *   create: {
     *     // ... data to create a Exam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exam we want to update
     *   }
     * })
     */
    upsert<T extends ExamUpsertArgs>(args: SelectSubset<T, ExamUpsertArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCountArgs} args - Arguments to filter Exams to count.
     * @example
     * // Count the number of Exams
     * const count = await prisma.exam.count({
     *   where: {
     *     // ... the filter for the Exams we want to count
     *   }
     * })
    **/
    count<T extends ExamCountArgs>(
      args?: Subset<T, ExamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamAggregateArgs>(args: Subset<T, ExamAggregateArgs>): Prisma.PrismaPromise<GetExamAggregateType<T>>

    /**
     * Group by Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamGroupByArgs['orderBy'] }
        : { orderBy?: ExamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exam model
   */
  readonly fields: ExamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exam model
   */
  interface ExamFieldRefs {
    readonly id: FieldRef<"Exam", 'String'>
    readonly title: FieldRef<"Exam", 'String'>
    readonly subjectId: FieldRef<"Exam", 'String'>
    readonly classId: FieldRef<"Exam", 'String'>
    readonly type: FieldRef<"Exam", 'String'>
    readonly date: FieldRef<"Exam", 'DateTime'>
    readonly duration: FieldRef<"Exam", 'Int'>
    readonly maxScore: FieldRef<"Exam", 'Int'>
    readonly status: FieldRef<"Exam", 'String'>
    readonly instructions: FieldRef<"Exam", 'String'>
    readonly createdAt: FieldRef<"Exam", 'DateTime'>
    readonly updatedAt: FieldRef<"Exam", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Exam findUnique
   */
  export type ExamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findUniqueOrThrow
   */
  export type ExamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findFirst
   */
  export type ExamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findFirstOrThrow
   */
  export type ExamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findMany
   */
  export type ExamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Filter, which Exams to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam create
   */
  export type ExamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * The data needed to create a Exam.
     */
    data: XOR<ExamCreateInput, ExamUncheckedCreateInput>
  }

  /**
   * Exam createMany
   */
  export type ExamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exam createManyAndReturn
   */
  export type ExamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exam update
   */
  export type ExamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * The data needed to update a Exam.
     */
    data: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
    /**
     * Choose, which Exam to update.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam updateMany
   */
  export type ExamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exams.
     */
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyInput>
    /**
     * Filter which Exams to update
     */
    where?: ExamWhereInput
    /**
     * Limit how many Exams to update.
     */
    limit?: number
  }

  /**
   * Exam updateManyAndReturn
   */
  export type ExamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * The data used to update Exams.
     */
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyInput>
    /**
     * Filter which Exams to update
     */
    where?: ExamWhereInput
    /**
     * Limit how many Exams to update.
     */
    limit?: number
  }

  /**
   * Exam upsert
   */
  export type ExamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * The filter to search for the Exam to update in case it exists.
     */
    where: ExamWhereUniqueInput
    /**
     * In case the Exam found by the `where` argument doesn't exist, create a new Exam with this data.
     */
    create: XOR<ExamCreateInput, ExamUncheckedCreateInput>
    /**
     * In case the Exam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
  }

  /**
   * Exam delete
   */
  export type ExamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Filter which Exam to delete.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam deleteMany
   */
  export type ExamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exams to delete
     */
    where?: ExamWhereInput
    /**
     * Limit how many Exams to delete.
     */
    limit?: number
  }

  /**
   * Exam without action
   */
  export type ExamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
  }


  /**
   * Model StudentRegistrationRequest
   */

  export type AggregateStudentRegistrationRequest = {
    _count: StudentRegistrationRequestCountAggregateOutputType | null
    _min: StudentRegistrationRequestMinAggregateOutputType | null
    _max: StudentRegistrationRequestMaxAggregateOutputType | null
  }

  export type StudentRegistrationRequestMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    semesterId: string | null
    status: string | null
    createdAt: Date | null
    approvedAt: Date | null
    adminId: string | null
  }

  export type StudentRegistrationRequestMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    semesterId: string | null
    status: string | null
    createdAt: Date | null
    approvedAt: Date | null
    adminId: string | null
  }

  export type StudentRegistrationRequestCountAggregateOutputType = {
    id: number
    studentId: number
    semesterId: number
    status: number
    createdAt: number
    approvedAt: number
    adminId: number
    _all: number
  }


  export type StudentRegistrationRequestMinAggregateInputType = {
    id?: true
    studentId?: true
    semesterId?: true
    status?: true
    createdAt?: true
    approvedAt?: true
    adminId?: true
  }

  export type StudentRegistrationRequestMaxAggregateInputType = {
    id?: true
    studentId?: true
    semesterId?: true
    status?: true
    createdAt?: true
    approvedAt?: true
    adminId?: true
  }

  export type StudentRegistrationRequestCountAggregateInputType = {
    id?: true
    studentId?: true
    semesterId?: true
    status?: true
    createdAt?: true
    approvedAt?: true
    adminId?: true
    _all?: true
  }

  export type StudentRegistrationRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentRegistrationRequest to aggregate.
     */
    where?: StudentRegistrationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentRegistrationRequests to fetch.
     */
    orderBy?: StudentRegistrationRequestOrderByWithRelationInput | StudentRegistrationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentRegistrationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentRegistrationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentRegistrationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentRegistrationRequests
    **/
    _count?: true | StudentRegistrationRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentRegistrationRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentRegistrationRequestMaxAggregateInputType
  }

  export type GetStudentRegistrationRequestAggregateType<T extends StudentRegistrationRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentRegistrationRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentRegistrationRequest[P]>
      : GetScalarType<T[P], AggregateStudentRegistrationRequest[P]>
  }




  export type StudentRegistrationRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentRegistrationRequestWhereInput
    orderBy?: StudentRegistrationRequestOrderByWithAggregationInput | StudentRegistrationRequestOrderByWithAggregationInput[]
    by: StudentRegistrationRequestScalarFieldEnum[] | StudentRegistrationRequestScalarFieldEnum
    having?: StudentRegistrationRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentRegistrationRequestCountAggregateInputType | true
    _min?: StudentRegistrationRequestMinAggregateInputType
    _max?: StudentRegistrationRequestMaxAggregateInputType
  }

  export type StudentRegistrationRequestGroupByOutputType = {
    id: string
    studentId: string
    semesterId: string
    status: string
    createdAt: Date
    approvedAt: Date | null
    adminId: string | null
    _count: StudentRegistrationRequestCountAggregateOutputType | null
    _min: StudentRegistrationRequestMinAggregateOutputType | null
    _max: StudentRegistrationRequestMaxAggregateOutputType | null
  }

  type GetStudentRegistrationRequestGroupByPayload<T extends StudentRegistrationRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentRegistrationRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentRegistrationRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentRegistrationRequestGroupByOutputType[P]>
            : GetScalarType<T[P], StudentRegistrationRequestGroupByOutputType[P]>
        }
      >
    >


  export type StudentRegistrationRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    semesterId?: boolean
    status?: boolean
    createdAt?: boolean
    approvedAt?: boolean
    adminId?: boolean
    student?: boolean | UserDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentRegistrationRequest"]>

  export type StudentRegistrationRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    semesterId?: boolean
    status?: boolean
    createdAt?: boolean
    approvedAt?: boolean
    adminId?: boolean
    student?: boolean | UserDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentRegistrationRequest"]>

  export type StudentRegistrationRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    semesterId?: boolean
    status?: boolean
    createdAt?: boolean
    approvedAt?: boolean
    adminId?: boolean
    student?: boolean | UserDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentRegistrationRequest"]>

  export type StudentRegistrationRequestSelectScalar = {
    id?: boolean
    studentId?: boolean
    semesterId?: boolean
    status?: boolean
    createdAt?: boolean
    approvedAt?: boolean
    adminId?: boolean
  }

  export type StudentRegistrationRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "semesterId" | "status" | "createdAt" | "approvedAt" | "adminId", ExtArgs["result"]["studentRegistrationRequest"]>
  export type StudentRegistrationRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | UserDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }
  export type StudentRegistrationRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | UserDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }
  export type StudentRegistrationRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | UserDefaultArgs<ExtArgs>
    semester?: boolean | SemesterDefaultArgs<ExtArgs>
  }

  export type $StudentRegistrationRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentRegistrationRequest"
    objects: {
      student: Prisma.$UserPayload<ExtArgs>
      semester: Prisma.$SemesterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      semesterId: string
      status: string
      createdAt: Date
      approvedAt: Date | null
      adminId: string | null
    }, ExtArgs["result"]["studentRegistrationRequest"]>
    composites: {}
  }

  type StudentRegistrationRequestGetPayload<S extends boolean | null | undefined | StudentRegistrationRequestDefaultArgs> = $Result.GetResult<Prisma.$StudentRegistrationRequestPayload, S>

  type StudentRegistrationRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentRegistrationRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentRegistrationRequestCountAggregateInputType | true
    }

  export interface StudentRegistrationRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentRegistrationRequest'], meta: { name: 'StudentRegistrationRequest' } }
    /**
     * Find zero or one StudentRegistrationRequest that matches the filter.
     * @param {StudentRegistrationRequestFindUniqueArgs} args - Arguments to find a StudentRegistrationRequest
     * @example
     * // Get one StudentRegistrationRequest
     * const studentRegistrationRequest = await prisma.studentRegistrationRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentRegistrationRequestFindUniqueArgs>(args: SelectSubset<T, StudentRegistrationRequestFindUniqueArgs<ExtArgs>>): Prisma__StudentRegistrationRequestClient<$Result.GetResult<Prisma.$StudentRegistrationRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentRegistrationRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentRegistrationRequestFindUniqueOrThrowArgs} args - Arguments to find a StudentRegistrationRequest
     * @example
     * // Get one StudentRegistrationRequest
     * const studentRegistrationRequest = await prisma.studentRegistrationRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentRegistrationRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentRegistrationRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentRegistrationRequestClient<$Result.GetResult<Prisma.$StudentRegistrationRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentRegistrationRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentRegistrationRequestFindFirstArgs} args - Arguments to find a StudentRegistrationRequest
     * @example
     * // Get one StudentRegistrationRequest
     * const studentRegistrationRequest = await prisma.studentRegistrationRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentRegistrationRequestFindFirstArgs>(args?: SelectSubset<T, StudentRegistrationRequestFindFirstArgs<ExtArgs>>): Prisma__StudentRegistrationRequestClient<$Result.GetResult<Prisma.$StudentRegistrationRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentRegistrationRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentRegistrationRequestFindFirstOrThrowArgs} args - Arguments to find a StudentRegistrationRequest
     * @example
     * // Get one StudentRegistrationRequest
     * const studentRegistrationRequest = await prisma.studentRegistrationRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentRegistrationRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentRegistrationRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentRegistrationRequestClient<$Result.GetResult<Prisma.$StudentRegistrationRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentRegistrationRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentRegistrationRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentRegistrationRequests
     * const studentRegistrationRequests = await prisma.studentRegistrationRequest.findMany()
     * 
     * // Get first 10 StudentRegistrationRequests
     * const studentRegistrationRequests = await prisma.studentRegistrationRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentRegistrationRequestWithIdOnly = await prisma.studentRegistrationRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentRegistrationRequestFindManyArgs>(args?: SelectSubset<T, StudentRegistrationRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentRegistrationRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentRegistrationRequest.
     * @param {StudentRegistrationRequestCreateArgs} args - Arguments to create a StudentRegistrationRequest.
     * @example
     * // Create one StudentRegistrationRequest
     * const StudentRegistrationRequest = await prisma.studentRegistrationRequest.create({
     *   data: {
     *     // ... data to create a StudentRegistrationRequest
     *   }
     * })
     * 
     */
    create<T extends StudentRegistrationRequestCreateArgs>(args: SelectSubset<T, StudentRegistrationRequestCreateArgs<ExtArgs>>): Prisma__StudentRegistrationRequestClient<$Result.GetResult<Prisma.$StudentRegistrationRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentRegistrationRequests.
     * @param {StudentRegistrationRequestCreateManyArgs} args - Arguments to create many StudentRegistrationRequests.
     * @example
     * // Create many StudentRegistrationRequests
     * const studentRegistrationRequest = await prisma.studentRegistrationRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentRegistrationRequestCreateManyArgs>(args?: SelectSubset<T, StudentRegistrationRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentRegistrationRequests and returns the data saved in the database.
     * @param {StudentRegistrationRequestCreateManyAndReturnArgs} args - Arguments to create many StudentRegistrationRequests.
     * @example
     * // Create many StudentRegistrationRequests
     * const studentRegistrationRequest = await prisma.studentRegistrationRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentRegistrationRequests and only return the `id`
     * const studentRegistrationRequestWithIdOnly = await prisma.studentRegistrationRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentRegistrationRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentRegistrationRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentRegistrationRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentRegistrationRequest.
     * @param {StudentRegistrationRequestDeleteArgs} args - Arguments to delete one StudentRegistrationRequest.
     * @example
     * // Delete one StudentRegistrationRequest
     * const StudentRegistrationRequest = await prisma.studentRegistrationRequest.delete({
     *   where: {
     *     // ... filter to delete one StudentRegistrationRequest
     *   }
     * })
     * 
     */
    delete<T extends StudentRegistrationRequestDeleteArgs>(args: SelectSubset<T, StudentRegistrationRequestDeleteArgs<ExtArgs>>): Prisma__StudentRegistrationRequestClient<$Result.GetResult<Prisma.$StudentRegistrationRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentRegistrationRequest.
     * @param {StudentRegistrationRequestUpdateArgs} args - Arguments to update one StudentRegistrationRequest.
     * @example
     * // Update one StudentRegistrationRequest
     * const studentRegistrationRequest = await prisma.studentRegistrationRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentRegistrationRequestUpdateArgs>(args: SelectSubset<T, StudentRegistrationRequestUpdateArgs<ExtArgs>>): Prisma__StudentRegistrationRequestClient<$Result.GetResult<Prisma.$StudentRegistrationRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentRegistrationRequests.
     * @param {StudentRegistrationRequestDeleteManyArgs} args - Arguments to filter StudentRegistrationRequests to delete.
     * @example
     * // Delete a few StudentRegistrationRequests
     * const { count } = await prisma.studentRegistrationRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentRegistrationRequestDeleteManyArgs>(args?: SelectSubset<T, StudentRegistrationRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentRegistrationRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentRegistrationRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentRegistrationRequests
     * const studentRegistrationRequest = await prisma.studentRegistrationRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentRegistrationRequestUpdateManyArgs>(args: SelectSubset<T, StudentRegistrationRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentRegistrationRequests and returns the data updated in the database.
     * @param {StudentRegistrationRequestUpdateManyAndReturnArgs} args - Arguments to update many StudentRegistrationRequests.
     * @example
     * // Update many StudentRegistrationRequests
     * const studentRegistrationRequest = await prisma.studentRegistrationRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentRegistrationRequests and only return the `id`
     * const studentRegistrationRequestWithIdOnly = await prisma.studentRegistrationRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentRegistrationRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentRegistrationRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentRegistrationRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentRegistrationRequest.
     * @param {StudentRegistrationRequestUpsertArgs} args - Arguments to update or create a StudentRegistrationRequest.
     * @example
     * // Update or create a StudentRegistrationRequest
     * const studentRegistrationRequest = await prisma.studentRegistrationRequest.upsert({
     *   create: {
     *     // ... data to create a StudentRegistrationRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentRegistrationRequest we want to update
     *   }
     * })
     */
    upsert<T extends StudentRegistrationRequestUpsertArgs>(args: SelectSubset<T, StudentRegistrationRequestUpsertArgs<ExtArgs>>): Prisma__StudentRegistrationRequestClient<$Result.GetResult<Prisma.$StudentRegistrationRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentRegistrationRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentRegistrationRequestCountArgs} args - Arguments to filter StudentRegistrationRequests to count.
     * @example
     * // Count the number of StudentRegistrationRequests
     * const count = await prisma.studentRegistrationRequest.count({
     *   where: {
     *     // ... the filter for the StudentRegistrationRequests we want to count
     *   }
     * })
    **/
    count<T extends StudentRegistrationRequestCountArgs>(
      args?: Subset<T, StudentRegistrationRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentRegistrationRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentRegistrationRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentRegistrationRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentRegistrationRequestAggregateArgs>(args: Subset<T, StudentRegistrationRequestAggregateArgs>): Prisma.PrismaPromise<GetStudentRegistrationRequestAggregateType<T>>

    /**
     * Group by StudentRegistrationRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentRegistrationRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentRegistrationRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentRegistrationRequestGroupByArgs['orderBy'] }
        : { orderBy?: StudentRegistrationRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentRegistrationRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentRegistrationRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentRegistrationRequest model
   */
  readonly fields: StudentRegistrationRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentRegistrationRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentRegistrationRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    semester<T extends SemesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SemesterDefaultArgs<ExtArgs>>): Prisma__SemesterClient<$Result.GetResult<Prisma.$SemesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentRegistrationRequest model
   */
  interface StudentRegistrationRequestFieldRefs {
    readonly id: FieldRef<"StudentRegistrationRequest", 'String'>
    readonly studentId: FieldRef<"StudentRegistrationRequest", 'String'>
    readonly semesterId: FieldRef<"StudentRegistrationRequest", 'String'>
    readonly status: FieldRef<"StudentRegistrationRequest", 'String'>
    readonly createdAt: FieldRef<"StudentRegistrationRequest", 'DateTime'>
    readonly approvedAt: FieldRef<"StudentRegistrationRequest", 'DateTime'>
    readonly adminId: FieldRef<"StudentRegistrationRequest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StudentRegistrationRequest findUnique
   */
  export type StudentRegistrationRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRegistrationRequest
     */
    select?: StudentRegistrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentRegistrationRequest
     */
    omit?: StudentRegistrationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRegistrationRequestInclude<ExtArgs> | null
    /**
     * Filter, which StudentRegistrationRequest to fetch.
     */
    where: StudentRegistrationRequestWhereUniqueInput
  }

  /**
   * StudentRegistrationRequest findUniqueOrThrow
   */
  export type StudentRegistrationRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRegistrationRequest
     */
    select?: StudentRegistrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentRegistrationRequest
     */
    omit?: StudentRegistrationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRegistrationRequestInclude<ExtArgs> | null
    /**
     * Filter, which StudentRegistrationRequest to fetch.
     */
    where: StudentRegistrationRequestWhereUniqueInput
  }

  /**
   * StudentRegistrationRequest findFirst
   */
  export type StudentRegistrationRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRegistrationRequest
     */
    select?: StudentRegistrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentRegistrationRequest
     */
    omit?: StudentRegistrationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRegistrationRequestInclude<ExtArgs> | null
    /**
     * Filter, which StudentRegistrationRequest to fetch.
     */
    where?: StudentRegistrationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentRegistrationRequests to fetch.
     */
    orderBy?: StudentRegistrationRequestOrderByWithRelationInput | StudentRegistrationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentRegistrationRequests.
     */
    cursor?: StudentRegistrationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentRegistrationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentRegistrationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentRegistrationRequests.
     */
    distinct?: StudentRegistrationRequestScalarFieldEnum | StudentRegistrationRequestScalarFieldEnum[]
  }

  /**
   * StudentRegistrationRequest findFirstOrThrow
   */
  export type StudentRegistrationRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRegistrationRequest
     */
    select?: StudentRegistrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentRegistrationRequest
     */
    omit?: StudentRegistrationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRegistrationRequestInclude<ExtArgs> | null
    /**
     * Filter, which StudentRegistrationRequest to fetch.
     */
    where?: StudentRegistrationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentRegistrationRequests to fetch.
     */
    orderBy?: StudentRegistrationRequestOrderByWithRelationInput | StudentRegistrationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentRegistrationRequests.
     */
    cursor?: StudentRegistrationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentRegistrationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentRegistrationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentRegistrationRequests.
     */
    distinct?: StudentRegistrationRequestScalarFieldEnum | StudentRegistrationRequestScalarFieldEnum[]
  }

  /**
   * StudentRegistrationRequest findMany
   */
  export type StudentRegistrationRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRegistrationRequest
     */
    select?: StudentRegistrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentRegistrationRequest
     */
    omit?: StudentRegistrationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRegistrationRequestInclude<ExtArgs> | null
    /**
     * Filter, which StudentRegistrationRequests to fetch.
     */
    where?: StudentRegistrationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentRegistrationRequests to fetch.
     */
    orderBy?: StudentRegistrationRequestOrderByWithRelationInput | StudentRegistrationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentRegistrationRequests.
     */
    cursor?: StudentRegistrationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentRegistrationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentRegistrationRequests.
     */
    skip?: number
    distinct?: StudentRegistrationRequestScalarFieldEnum | StudentRegistrationRequestScalarFieldEnum[]
  }

  /**
   * StudentRegistrationRequest create
   */
  export type StudentRegistrationRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRegistrationRequest
     */
    select?: StudentRegistrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentRegistrationRequest
     */
    omit?: StudentRegistrationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRegistrationRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentRegistrationRequest.
     */
    data: XOR<StudentRegistrationRequestCreateInput, StudentRegistrationRequestUncheckedCreateInput>
  }

  /**
   * StudentRegistrationRequest createMany
   */
  export type StudentRegistrationRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentRegistrationRequests.
     */
    data: StudentRegistrationRequestCreateManyInput | StudentRegistrationRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentRegistrationRequest createManyAndReturn
   */
  export type StudentRegistrationRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRegistrationRequest
     */
    select?: StudentRegistrationRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentRegistrationRequest
     */
    omit?: StudentRegistrationRequestOmit<ExtArgs> | null
    /**
     * The data used to create many StudentRegistrationRequests.
     */
    data: StudentRegistrationRequestCreateManyInput | StudentRegistrationRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRegistrationRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentRegistrationRequest update
   */
  export type StudentRegistrationRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRegistrationRequest
     */
    select?: StudentRegistrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentRegistrationRequest
     */
    omit?: StudentRegistrationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRegistrationRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentRegistrationRequest.
     */
    data: XOR<StudentRegistrationRequestUpdateInput, StudentRegistrationRequestUncheckedUpdateInput>
    /**
     * Choose, which StudentRegistrationRequest to update.
     */
    where: StudentRegistrationRequestWhereUniqueInput
  }

  /**
   * StudentRegistrationRequest updateMany
   */
  export type StudentRegistrationRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentRegistrationRequests.
     */
    data: XOR<StudentRegistrationRequestUpdateManyMutationInput, StudentRegistrationRequestUncheckedUpdateManyInput>
    /**
     * Filter which StudentRegistrationRequests to update
     */
    where?: StudentRegistrationRequestWhereInput
    /**
     * Limit how many StudentRegistrationRequests to update.
     */
    limit?: number
  }

  /**
   * StudentRegistrationRequest updateManyAndReturn
   */
  export type StudentRegistrationRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRegistrationRequest
     */
    select?: StudentRegistrationRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentRegistrationRequest
     */
    omit?: StudentRegistrationRequestOmit<ExtArgs> | null
    /**
     * The data used to update StudentRegistrationRequests.
     */
    data: XOR<StudentRegistrationRequestUpdateManyMutationInput, StudentRegistrationRequestUncheckedUpdateManyInput>
    /**
     * Filter which StudentRegistrationRequests to update
     */
    where?: StudentRegistrationRequestWhereInput
    /**
     * Limit how many StudentRegistrationRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRegistrationRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentRegistrationRequest upsert
   */
  export type StudentRegistrationRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRegistrationRequest
     */
    select?: StudentRegistrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentRegistrationRequest
     */
    omit?: StudentRegistrationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRegistrationRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentRegistrationRequest to update in case it exists.
     */
    where: StudentRegistrationRequestWhereUniqueInput
    /**
     * In case the StudentRegistrationRequest found by the `where` argument doesn't exist, create a new StudentRegistrationRequest with this data.
     */
    create: XOR<StudentRegistrationRequestCreateInput, StudentRegistrationRequestUncheckedCreateInput>
    /**
     * In case the StudentRegistrationRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentRegistrationRequestUpdateInput, StudentRegistrationRequestUncheckedUpdateInput>
  }

  /**
   * StudentRegistrationRequest delete
   */
  export type StudentRegistrationRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRegistrationRequest
     */
    select?: StudentRegistrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentRegistrationRequest
     */
    omit?: StudentRegistrationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRegistrationRequestInclude<ExtArgs> | null
    /**
     * Filter which StudentRegistrationRequest to delete.
     */
    where: StudentRegistrationRequestWhereUniqueInput
  }

  /**
   * StudentRegistrationRequest deleteMany
   */
  export type StudentRegistrationRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentRegistrationRequests to delete
     */
    where?: StudentRegistrationRequestWhereInput
    /**
     * Limit how many StudentRegistrationRequests to delete.
     */
    limit?: number
  }

  /**
   * StudentRegistrationRequest without action
   */
  export type StudentRegistrationRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentRegistrationRequest
     */
    select?: StudentRegistrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentRegistrationRequest
     */
    omit?: StudentRegistrationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentRegistrationRequestInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    lastName: 'lastName',
    gender: 'gender',
    role: 'role',
    phone: 'phone',
    address: 'address',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserSessionScalarFieldEnum: {
    sessionId: 'sessionId',
    userId: 'userId',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type UserSessionScalarFieldEnum = (typeof UserSessionScalarFieldEnum)[keyof typeof UserSessionScalarFieldEnum]


  export const AcademicYearScalarFieldEnum: {
    id: 'id',
    name: 'name',
    startDate: 'startDate',
    endDate: 'endDate',
    isCurrent: 'isCurrent',
    createdBy: 'createdBy'
  };

  export type AcademicYearScalarFieldEnum = (typeof AcademicYearScalarFieldEnum)[keyof typeof AcademicYearScalarFieldEnum]


  export const SemesterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    academicYearId: 'academicYearId',
    startDate: 'startDate',
    endDate: 'endDate',
    isCurrent: 'isCurrent',
    registrationOpen: 'registrationOpen',
    minAverage: 'minAverage',
    noFailedSubjects: 'noFailedSubjects'
  };

  export type SemesterScalarFieldEnum = (typeof SemesterScalarFieldEnum)[keyof typeof SemesterScalarFieldEnum]


  export const ClassSectionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    gradeId: 'gradeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClassSectionScalarFieldEnum = (typeof ClassSectionScalarFieldEnum)[keyof typeof ClassSectionScalarFieldEnum]


  export const GradeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    level: 'level'
  };

  export type GradeScalarFieldEnum = (typeof GradeScalarFieldEnum)[keyof typeof GradeScalarFieldEnum]


  export const SubjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    gradeId: 'gradeId'
  };

  export type SubjectScalarFieldEnum = (typeof SubjectScalarFieldEnum)[keyof typeof SubjectScalarFieldEnum]


  export const ClassScalarFieldEnum: {
    id: 'id',
    gradeId: 'gradeId',
    classSectionId: 'classSectionId',
    academicYearId: 'academicYearId'
  };

  export type ClassScalarFieldEnum = (typeof ClassScalarFieldEnum)[keyof typeof ClassScalarFieldEnum]


  export const TeacherSubjectScalarFieldEnum: {
    id: 'id',
    teacherId: 'teacherId',
    subjectId: 'subjectId',
    classId: 'classId',
    academicYearId: 'academicYearId'
  };

  export type TeacherSubjectScalarFieldEnum = (typeof TeacherSubjectScalarFieldEnum)[keyof typeof TeacherSubjectScalarFieldEnum]


  export const StudentEnrollmentScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    classId: 'classId',
    academicYearId: 'academicYearId',
    semesterId: 'semesterId',
    enrollmentDate: 'enrollmentDate'
  };

  export type StudentEnrollmentScalarFieldEnum = (typeof StudentEnrollmentScalarFieldEnum)[keyof typeof StudentEnrollmentScalarFieldEnum]


  export const ClassScheduleScalarFieldEnum: {
    id: 'id',
    classId: 'classId',
    subjectId: 'subjectId',
    teacherId: 'teacherId',
    dayOfWeek: 'dayOfWeek',
    startTime: 'startTime',
    endTime: 'endTime'
  };

  export type ClassScheduleScalarFieldEnum = (typeof ClassScheduleScalarFieldEnum)[keyof typeof ClassScheduleScalarFieldEnum]


  export const AttendanceRecordScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    classId: 'classId',
    subjectId: 'subjectId',
    date: 'date',
    period: 'period',
    status: 'status',
    markedById: 'markedById',
    markedAt: 'markedAt',
    remarks: 'remarks'
  };

  export type AttendanceRecordScalarFieldEnum = (typeof AttendanceRecordScalarFieldEnum)[keyof typeof AttendanceRecordScalarFieldEnum]


  export const AttendanceSummaryScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    subjectId: 'subjectId',
    semesterId: 'semesterId',
    totalClasses: 'totalClasses',
    presentCount: 'presentCount',
    absentCount: 'absentCount',
    lateCount: 'lateCount'
  };

  export type AttendanceSummaryScalarFieldEnum = (typeof AttendanceSummaryScalarFieldEnum)[keyof typeof AttendanceSummaryScalarFieldEnum]


  export const GradeCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    weight: 'weight',
    classId: 'classId',
    subjectId: 'subjectId'
  };

  export type GradeCategoryScalarFieldEnum = (typeof GradeCategoryScalarFieldEnum)[keyof typeof GradeCategoryScalarFieldEnum]


  export const GradeEntryScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    subjectId: 'subjectId',
    categoryId: 'categoryId',
    classId: 'classId',
    academicYearId: 'academicYearId',
    pointsEarned: 'pointsEarned',
    totalPoints: 'totalPoints',
    date: 'date',
    semesterId: 'semesterId',
    createdById: 'createdById'
  };

  export type GradeEntryScalarFieldEnum = (typeof GradeEntryScalarFieldEnum)[keyof typeof GradeEntryScalarFieldEnum]


  export const GradeReportScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    semesterId: 'semesterId',
    overallGpa: 'overallGpa',
    generatedAt: 'generatedAt'
  };

  export type GradeReportScalarFieldEnum = (typeof GradeReportScalarFieldEnum)[keyof typeof GradeReportScalarFieldEnum]


  export const AnnouncementScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    authorId: 'authorId',
    targetRoles: 'targetRoles',
    targetClasses: 'targetClasses',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type AnnouncementScalarFieldEnum = (typeof AnnouncementScalarFieldEnum)[keyof typeof AnnouncementScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    recipientId: 'recipientId',
    subject: 'subject',
    content: 'content',
    isRead: 'isRead',
    sentAt: 'sentAt',
    parentMessageId: 'parentMessageId'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    content: 'content',
    type: 'type',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    fileName: 'fileName',
    filePath: 'filePath',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    uploadedById: 'uploadedById',
    category: 'category',
    classId: 'classId',
    subjectId: 'subjectId',
    uploadedAt: 'uploadedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const DocumentPermissionScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    userId: 'userId',
    permissionType: 'permissionType'
  };

  export type DocumentPermissionScalarFieldEnum = (typeof DocumentPermissionScalarFieldEnum)[keyof typeof DocumentPermissionScalarFieldEnum]


  export const ExamScalarFieldEnum: {
    id: 'id',
    title: 'title',
    subjectId: 'subjectId',
    classId: 'classId',
    type: 'type',
    date: 'date',
    duration: 'duration',
    maxScore: 'maxScore',
    status: 'status',
    instructions: 'instructions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExamScalarFieldEnum = (typeof ExamScalarFieldEnum)[keyof typeof ExamScalarFieldEnum]


  export const StudentRegistrationRequestScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    semesterId: 'semesterId',
    status: 'status',
    createdAt: 'createdAt',
    approvedAt: 'approvedAt',
    adminId: 'adminId'
  };

  export type StudentRegistrationRequestScalarFieldEnum = (typeof StudentRegistrationRequestScalarFieldEnum)[keyof typeof StudentRegistrationRequestScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'AttendanceStatus'
   */
  export type EnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus'>
    


  /**
   * Reference to a field of type 'AttendanceStatus[]'
   */
  export type ListEnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    gender?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    phone?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    status?: EnumStatusFilter<"User"> | $Enums.Status
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: UserSessionListRelationFilter
    announcements?: AnnouncementListRelationFilter
    messagesSent?: MessageListRelationFilter
    messagesReceived?: MessageListRelationFilter
    notifications?: NotificationListRelationFilter
    documents?: DocumentListRelationFilter
    documentPermissions?: DocumentPermissionListRelationFilter
    teacherSubjects?: TeacherSubjectListRelationFilter
    studentEnrollments?: StudentEnrollmentListRelationFilter
    classSchedules?: ClassScheduleListRelationFilter
    attendanceRecordsAsStudent?: AttendanceRecordListRelationFilter
    attendanceRecordsMarked?: AttendanceRecordListRelationFilter
    attendanceSummaries?: AttendanceSummaryListRelationFilter
    gradeEntriesAsStudent?: GradeEntryListRelationFilter
    gradeEntriesCreated?: GradeEntryListRelationFilter
    gradeReports?: GradeReportListRelationFilter
    registrationRequests?: StudentRegistrationRequestListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrderInput | SortOrder
    role?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: UserSessionOrderByRelationAggregateInput
    announcements?: AnnouncementOrderByRelationAggregateInput
    messagesSent?: MessageOrderByRelationAggregateInput
    messagesReceived?: MessageOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    documentPermissions?: DocumentPermissionOrderByRelationAggregateInput
    teacherSubjects?: TeacherSubjectOrderByRelationAggregateInput
    studentEnrollments?: StudentEnrollmentOrderByRelationAggregateInput
    classSchedules?: ClassScheduleOrderByRelationAggregateInput
    attendanceRecordsAsStudent?: AttendanceRecordOrderByRelationAggregateInput
    attendanceRecordsMarked?: AttendanceRecordOrderByRelationAggregateInput
    attendanceSummaries?: AttendanceSummaryOrderByRelationAggregateInput
    gradeEntriesAsStudent?: GradeEntryOrderByRelationAggregateInput
    gradeEntriesCreated?: GradeEntryOrderByRelationAggregateInput
    gradeReports?: GradeReportOrderByRelationAggregateInput
    registrationRequests?: StudentRegistrationRequestOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    gender?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    phone?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    status?: EnumStatusFilter<"User"> | $Enums.Status
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: UserSessionListRelationFilter
    announcements?: AnnouncementListRelationFilter
    messagesSent?: MessageListRelationFilter
    messagesReceived?: MessageListRelationFilter
    notifications?: NotificationListRelationFilter
    documents?: DocumentListRelationFilter
    documentPermissions?: DocumentPermissionListRelationFilter
    teacherSubjects?: TeacherSubjectListRelationFilter
    studentEnrollments?: StudentEnrollmentListRelationFilter
    classSchedules?: ClassScheduleListRelationFilter
    attendanceRecordsAsStudent?: AttendanceRecordListRelationFilter
    attendanceRecordsMarked?: AttendanceRecordListRelationFilter
    attendanceSummaries?: AttendanceSummaryListRelationFilter
    gradeEntriesAsStudent?: GradeEntryListRelationFilter
    gradeEntriesCreated?: GradeEntryListRelationFilter
    gradeReports?: GradeReportListRelationFilter
    registrationRequests?: StudentRegistrationRequestListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrderInput | SortOrder
    role?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    gender?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    status?: EnumStatusWithAggregatesFilter<"User"> | $Enums.Status
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserSessionWhereInput = {
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    sessionId?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSessionOrderByWithRelationInput = {
    sessionId?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSessionWhereUniqueInput = Prisma.AtLeast<{
    sessionId?: string
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    userId?: StringFilter<"UserSession"> | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "sessionId">

  export type UserSessionOrderByWithAggregationInput = {
    sessionId?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: UserSessionCountOrderByAggregateInput
    _max?: UserSessionMaxOrderByAggregateInput
    _min?: UserSessionMinOrderByAggregateInput
  }

  export type UserSessionScalarWhereWithAggregatesInput = {
    AND?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    OR?: UserSessionScalarWhereWithAggregatesInput[]
    NOT?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    sessionId?: StringWithAggregatesFilter<"UserSession"> | string
    userId?: StringWithAggregatesFilter<"UserSession"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
  }

  export type AcademicYearWhereInput = {
    AND?: AcademicYearWhereInput | AcademicYearWhereInput[]
    OR?: AcademicYearWhereInput[]
    NOT?: AcademicYearWhereInput | AcademicYearWhereInput[]
    id?: StringFilter<"AcademicYear"> | string
    name?: StringFilter<"AcademicYear"> | string
    startDate?: DateTimeFilter<"AcademicYear"> | Date | string
    endDate?: DateTimeFilter<"AcademicYear"> | Date | string
    isCurrent?: BoolFilter<"AcademicYear"> | boolean
    createdBy?: StringFilter<"AcademicYear"> | string
    semesters?: SemesterListRelationFilter
    classes?: ClassListRelationFilter
    teacherSubjects?: TeacherSubjectListRelationFilter
    studentEnrollments?: StudentEnrollmentListRelationFilter
    gradeEntries?: GradeEntryListRelationFilter
  }

  export type AcademicYearOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCurrent?: SortOrder
    createdBy?: SortOrder
    semesters?: SemesterOrderByRelationAggregateInput
    classes?: ClassOrderByRelationAggregateInput
    teacherSubjects?: TeacherSubjectOrderByRelationAggregateInput
    studentEnrollments?: StudentEnrollmentOrderByRelationAggregateInput
    gradeEntries?: GradeEntryOrderByRelationAggregateInput
  }

  export type AcademicYearWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AcademicYearWhereInput | AcademicYearWhereInput[]
    OR?: AcademicYearWhereInput[]
    NOT?: AcademicYearWhereInput | AcademicYearWhereInput[]
    name?: StringFilter<"AcademicYear"> | string
    startDate?: DateTimeFilter<"AcademicYear"> | Date | string
    endDate?: DateTimeFilter<"AcademicYear"> | Date | string
    isCurrent?: BoolFilter<"AcademicYear"> | boolean
    createdBy?: StringFilter<"AcademicYear"> | string
    semesters?: SemesterListRelationFilter
    classes?: ClassListRelationFilter
    teacherSubjects?: TeacherSubjectListRelationFilter
    studentEnrollments?: StudentEnrollmentListRelationFilter
    gradeEntries?: GradeEntryListRelationFilter
  }, "id">

  export type AcademicYearOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCurrent?: SortOrder
    createdBy?: SortOrder
    _count?: AcademicYearCountOrderByAggregateInput
    _max?: AcademicYearMaxOrderByAggregateInput
    _min?: AcademicYearMinOrderByAggregateInput
  }

  export type AcademicYearScalarWhereWithAggregatesInput = {
    AND?: AcademicYearScalarWhereWithAggregatesInput | AcademicYearScalarWhereWithAggregatesInput[]
    OR?: AcademicYearScalarWhereWithAggregatesInput[]
    NOT?: AcademicYearScalarWhereWithAggregatesInput | AcademicYearScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AcademicYear"> | string
    name?: StringWithAggregatesFilter<"AcademicYear"> | string
    startDate?: DateTimeWithAggregatesFilter<"AcademicYear"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"AcademicYear"> | Date | string
    isCurrent?: BoolWithAggregatesFilter<"AcademicYear"> | boolean
    createdBy?: StringWithAggregatesFilter<"AcademicYear"> | string
  }

  export type SemesterWhereInput = {
    AND?: SemesterWhereInput | SemesterWhereInput[]
    OR?: SemesterWhereInput[]
    NOT?: SemesterWhereInput | SemesterWhereInput[]
    id?: StringFilter<"Semester"> | string
    name?: StringFilter<"Semester"> | string
    academicYearId?: StringFilter<"Semester"> | string
    startDate?: DateTimeFilter<"Semester"> | Date | string
    endDate?: DateTimeFilter<"Semester"> | Date | string
    isCurrent?: BoolFilter<"Semester"> | boolean
    registrationOpen?: BoolFilter<"Semester"> | boolean
    minAverage?: FloatNullableFilter<"Semester"> | number | null
    noFailedSubjects?: BoolNullableFilter<"Semester"> | boolean | null
    academicYear?: XOR<AcademicYearScalarRelationFilter, AcademicYearWhereInput>
    attendanceSummaries?: AttendanceSummaryListRelationFilter
    gradeReports?: GradeReportListRelationFilter
    gradeEntries?: GradeEntryListRelationFilter
    studentEnrollments?: StudentEnrollmentListRelationFilter
    registrationRequests?: StudentRegistrationRequestListRelationFilter
  }

  export type SemesterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    academicYearId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCurrent?: SortOrder
    registrationOpen?: SortOrder
    minAverage?: SortOrderInput | SortOrder
    noFailedSubjects?: SortOrderInput | SortOrder
    academicYear?: AcademicYearOrderByWithRelationInput
    attendanceSummaries?: AttendanceSummaryOrderByRelationAggregateInput
    gradeReports?: GradeReportOrderByRelationAggregateInput
    gradeEntries?: GradeEntryOrderByRelationAggregateInput
    studentEnrollments?: StudentEnrollmentOrderByRelationAggregateInput
    registrationRequests?: StudentRegistrationRequestOrderByRelationAggregateInput
  }

  export type SemesterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SemesterWhereInput | SemesterWhereInput[]
    OR?: SemesterWhereInput[]
    NOT?: SemesterWhereInput | SemesterWhereInput[]
    name?: StringFilter<"Semester"> | string
    academicYearId?: StringFilter<"Semester"> | string
    startDate?: DateTimeFilter<"Semester"> | Date | string
    endDate?: DateTimeFilter<"Semester"> | Date | string
    isCurrent?: BoolFilter<"Semester"> | boolean
    registrationOpen?: BoolFilter<"Semester"> | boolean
    minAverage?: FloatNullableFilter<"Semester"> | number | null
    noFailedSubjects?: BoolNullableFilter<"Semester"> | boolean | null
    academicYear?: XOR<AcademicYearScalarRelationFilter, AcademicYearWhereInput>
    attendanceSummaries?: AttendanceSummaryListRelationFilter
    gradeReports?: GradeReportListRelationFilter
    gradeEntries?: GradeEntryListRelationFilter
    studentEnrollments?: StudentEnrollmentListRelationFilter
    registrationRequests?: StudentRegistrationRequestListRelationFilter
  }, "id">

  export type SemesterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    academicYearId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCurrent?: SortOrder
    registrationOpen?: SortOrder
    minAverage?: SortOrderInput | SortOrder
    noFailedSubjects?: SortOrderInput | SortOrder
    _count?: SemesterCountOrderByAggregateInput
    _avg?: SemesterAvgOrderByAggregateInput
    _max?: SemesterMaxOrderByAggregateInput
    _min?: SemesterMinOrderByAggregateInput
    _sum?: SemesterSumOrderByAggregateInput
  }

  export type SemesterScalarWhereWithAggregatesInput = {
    AND?: SemesterScalarWhereWithAggregatesInput | SemesterScalarWhereWithAggregatesInput[]
    OR?: SemesterScalarWhereWithAggregatesInput[]
    NOT?: SemesterScalarWhereWithAggregatesInput | SemesterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Semester"> | string
    name?: StringWithAggregatesFilter<"Semester"> | string
    academicYearId?: StringWithAggregatesFilter<"Semester"> | string
    startDate?: DateTimeWithAggregatesFilter<"Semester"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Semester"> | Date | string
    isCurrent?: BoolWithAggregatesFilter<"Semester"> | boolean
    registrationOpen?: BoolWithAggregatesFilter<"Semester"> | boolean
    minAverage?: FloatNullableWithAggregatesFilter<"Semester"> | number | null
    noFailedSubjects?: BoolNullableWithAggregatesFilter<"Semester"> | boolean | null
  }

  export type ClassSectionWhereInput = {
    AND?: ClassSectionWhereInput | ClassSectionWhereInput[]
    OR?: ClassSectionWhereInput[]
    NOT?: ClassSectionWhereInput | ClassSectionWhereInput[]
    id?: StringFilter<"ClassSection"> | string
    name?: StringFilter<"ClassSection"> | string
    gradeId?: StringFilter<"ClassSection"> | string
    createdAt?: DateTimeFilter<"ClassSection"> | Date | string
    updatedAt?: DateTimeFilter<"ClassSection"> | Date | string
    grade?: XOR<GradeScalarRelationFilter, GradeWhereInput>
    classes?: ClassListRelationFilter
  }

  export type ClassSectionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    gradeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    grade?: GradeOrderByWithRelationInput
    classes?: ClassOrderByRelationAggregateInput
  }

  export type ClassSectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClassSectionWhereInput | ClassSectionWhereInput[]
    OR?: ClassSectionWhereInput[]
    NOT?: ClassSectionWhereInput | ClassSectionWhereInput[]
    name?: StringFilter<"ClassSection"> | string
    gradeId?: StringFilter<"ClassSection"> | string
    createdAt?: DateTimeFilter<"ClassSection"> | Date | string
    updatedAt?: DateTimeFilter<"ClassSection"> | Date | string
    grade?: XOR<GradeScalarRelationFilter, GradeWhereInput>
    classes?: ClassListRelationFilter
  }, "id">

  export type ClassSectionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    gradeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClassSectionCountOrderByAggregateInput
    _max?: ClassSectionMaxOrderByAggregateInput
    _min?: ClassSectionMinOrderByAggregateInput
  }

  export type ClassSectionScalarWhereWithAggregatesInput = {
    AND?: ClassSectionScalarWhereWithAggregatesInput | ClassSectionScalarWhereWithAggregatesInput[]
    OR?: ClassSectionScalarWhereWithAggregatesInput[]
    NOT?: ClassSectionScalarWhereWithAggregatesInput | ClassSectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClassSection"> | string
    name?: StringWithAggregatesFilter<"ClassSection"> | string
    gradeId?: StringWithAggregatesFilter<"ClassSection"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ClassSection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClassSection"> | Date | string
  }

  export type GradeWhereInput = {
    AND?: GradeWhereInput | GradeWhereInput[]
    OR?: GradeWhereInput[]
    NOT?: GradeWhereInput | GradeWhereInput[]
    id?: StringFilter<"Grade"> | string
    name?: StringFilter<"Grade"> | string
    level?: IntFilter<"Grade"> | number
    classSections?: ClassSectionListRelationFilter
    subjects?: SubjectListRelationFilter
    classes?: ClassListRelationFilter
  }

  export type GradeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    classSections?: ClassSectionOrderByRelationAggregateInput
    subjects?: SubjectOrderByRelationAggregateInput
    classes?: ClassOrderByRelationAggregateInput
  }

  export type GradeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GradeWhereInput | GradeWhereInput[]
    OR?: GradeWhereInput[]
    NOT?: GradeWhereInput | GradeWhereInput[]
    name?: StringFilter<"Grade"> | string
    level?: IntFilter<"Grade"> | number
    classSections?: ClassSectionListRelationFilter
    subjects?: SubjectListRelationFilter
    classes?: ClassListRelationFilter
  }, "id">

  export type GradeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    _count?: GradeCountOrderByAggregateInput
    _avg?: GradeAvgOrderByAggregateInput
    _max?: GradeMaxOrderByAggregateInput
    _min?: GradeMinOrderByAggregateInput
    _sum?: GradeSumOrderByAggregateInput
  }

  export type GradeScalarWhereWithAggregatesInput = {
    AND?: GradeScalarWhereWithAggregatesInput | GradeScalarWhereWithAggregatesInput[]
    OR?: GradeScalarWhereWithAggregatesInput[]
    NOT?: GradeScalarWhereWithAggregatesInput | GradeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Grade"> | string
    name?: StringWithAggregatesFilter<"Grade"> | string
    level?: IntWithAggregatesFilter<"Grade"> | number
  }

  export type SubjectWhereInput = {
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    id?: StringFilter<"Subject"> | string
    name?: StringFilter<"Subject"> | string
    code?: StringFilter<"Subject"> | string
    description?: StringNullableFilter<"Subject"> | string | null
    gradeId?: StringFilter<"Subject"> | string
    grade?: XOR<GradeScalarRelationFilter, GradeWhereInput>
    teacherSubjects?: TeacherSubjectListRelationFilter
    classSchedules?: ClassScheduleListRelationFilter
    gradeCategories?: GradeCategoryListRelationFilter
    gradeEntries?: GradeEntryListRelationFilter
    attendanceRecords?: AttendanceRecordListRelationFilter
    documents?: DocumentListRelationFilter
    attendanceSummaries?: AttendanceSummaryListRelationFilter
  }

  export type SubjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    gradeId?: SortOrder
    grade?: GradeOrderByWithRelationInput
    teacherSubjects?: TeacherSubjectOrderByRelationAggregateInput
    classSchedules?: ClassScheduleOrderByRelationAggregateInput
    gradeCategories?: GradeCategoryOrderByRelationAggregateInput
    gradeEntries?: GradeEntryOrderByRelationAggregateInput
    attendanceRecords?: AttendanceRecordOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    attendanceSummaries?: AttendanceSummaryOrderByRelationAggregateInput
  }

  export type SubjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    name?: StringFilter<"Subject"> | string
    description?: StringNullableFilter<"Subject"> | string | null
    gradeId?: StringFilter<"Subject"> | string
    grade?: XOR<GradeScalarRelationFilter, GradeWhereInput>
    teacherSubjects?: TeacherSubjectListRelationFilter
    classSchedules?: ClassScheduleListRelationFilter
    gradeCategories?: GradeCategoryListRelationFilter
    gradeEntries?: GradeEntryListRelationFilter
    attendanceRecords?: AttendanceRecordListRelationFilter
    documents?: DocumentListRelationFilter
    attendanceSummaries?: AttendanceSummaryListRelationFilter
  }, "id" | "code">

  export type SubjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    gradeId?: SortOrder
    _count?: SubjectCountOrderByAggregateInput
    _max?: SubjectMaxOrderByAggregateInput
    _min?: SubjectMinOrderByAggregateInput
  }

  export type SubjectScalarWhereWithAggregatesInput = {
    AND?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    OR?: SubjectScalarWhereWithAggregatesInput[]
    NOT?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subject"> | string
    name?: StringWithAggregatesFilter<"Subject"> | string
    code?: StringWithAggregatesFilter<"Subject"> | string
    description?: StringNullableWithAggregatesFilter<"Subject"> | string | null
    gradeId?: StringWithAggregatesFilter<"Subject"> | string
  }

  export type ClassWhereInput = {
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    id?: StringFilter<"Class"> | string
    gradeId?: StringFilter<"Class"> | string
    classSectionId?: StringFilter<"Class"> | string
    academicYearId?: StringFilter<"Class"> | string
    grade?: XOR<GradeScalarRelationFilter, GradeWhereInput>
    classSection?: XOR<ClassSectionScalarRelationFilter, ClassSectionWhereInput>
    academicYear?: XOR<AcademicYearScalarRelationFilter, AcademicYearWhereInput>
    teacherSubjects?: TeacherSubjectListRelationFilter
    studentEnrollments?: StudentEnrollmentListRelationFilter
    classSchedules?: ClassScheduleListRelationFilter
    attendanceRecords?: AttendanceRecordListRelationFilter
    documents?: DocumentListRelationFilter
    gradeCategories?: GradeCategoryListRelationFilter
    gradeEntries?: GradeEntryListRelationFilter
  }

  export type ClassOrderByWithRelationInput = {
    id?: SortOrder
    gradeId?: SortOrder
    classSectionId?: SortOrder
    academicYearId?: SortOrder
    grade?: GradeOrderByWithRelationInput
    classSection?: ClassSectionOrderByWithRelationInput
    academicYear?: AcademicYearOrderByWithRelationInput
    teacherSubjects?: TeacherSubjectOrderByRelationAggregateInput
    studentEnrollments?: StudentEnrollmentOrderByRelationAggregateInput
    classSchedules?: ClassScheduleOrderByRelationAggregateInput
    attendanceRecords?: AttendanceRecordOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    gradeCategories?: GradeCategoryOrderByRelationAggregateInput
    gradeEntries?: GradeEntryOrderByRelationAggregateInput
  }

  export type ClassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    gradeId?: StringFilter<"Class"> | string
    classSectionId?: StringFilter<"Class"> | string
    academicYearId?: StringFilter<"Class"> | string
    grade?: XOR<GradeScalarRelationFilter, GradeWhereInput>
    classSection?: XOR<ClassSectionScalarRelationFilter, ClassSectionWhereInput>
    academicYear?: XOR<AcademicYearScalarRelationFilter, AcademicYearWhereInput>
    teacherSubjects?: TeacherSubjectListRelationFilter
    studentEnrollments?: StudentEnrollmentListRelationFilter
    classSchedules?: ClassScheduleListRelationFilter
    attendanceRecords?: AttendanceRecordListRelationFilter
    documents?: DocumentListRelationFilter
    gradeCategories?: GradeCategoryListRelationFilter
    gradeEntries?: GradeEntryListRelationFilter
  }, "id">

  export type ClassOrderByWithAggregationInput = {
    id?: SortOrder
    gradeId?: SortOrder
    classSectionId?: SortOrder
    academicYearId?: SortOrder
    _count?: ClassCountOrderByAggregateInput
    _max?: ClassMaxOrderByAggregateInput
    _min?: ClassMinOrderByAggregateInput
  }

  export type ClassScalarWhereWithAggregatesInput = {
    AND?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    OR?: ClassScalarWhereWithAggregatesInput[]
    NOT?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Class"> | string
    gradeId?: StringWithAggregatesFilter<"Class"> | string
    classSectionId?: StringWithAggregatesFilter<"Class"> | string
    academicYearId?: StringWithAggregatesFilter<"Class"> | string
  }

  export type TeacherSubjectWhereInput = {
    AND?: TeacherSubjectWhereInput | TeacherSubjectWhereInput[]
    OR?: TeacherSubjectWhereInput[]
    NOT?: TeacherSubjectWhereInput | TeacherSubjectWhereInput[]
    id?: StringFilter<"TeacherSubject"> | string
    teacherId?: StringFilter<"TeacherSubject"> | string
    subjectId?: StringFilter<"TeacherSubject"> | string
    classId?: StringFilter<"TeacherSubject"> | string
    academicYearId?: StringFilter<"TeacherSubject"> | string
    teacher?: XOR<UserScalarRelationFilter, UserWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    academicYear?: XOR<AcademicYearScalarRelationFilter, AcademicYearWhereInput>
  }

  export type TeacherSubjectOrderByWithRelationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    classId?: SortOrder
    academicYearId?: SortOrder
    teacher?: UserOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
    academicYear?: AcademicYearOrderByWithRelationInput
  }

  export type TeacherSubjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeacherSubjectWhereInput | TeacherSubjectWhereInput[]
    OR?: TeacherSubjectWhereInput[]
    NOT?: TeacherSubjectWhereInput | TeacherSubjectWhereInput[]
    teacherId?: StringFilter<"TeacherSubject"> | string
    subjectId?: StringFilter<"TeacherSubject"> | string
    classId?: StringFilter<"TeacherSubject"> | string
    academicYearId?: StringFilter<"TeacherSubject"> | string
    teacher?: XOR<UserScalarRelationFilter, UserWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    academicYear?: XOR<AcademicYearScalarRelationFilter, AcademicYearWhereInput>
  }, "id">

  export type TeacherSubjectOrderByWithAggregationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    classId?: SortOrder
    academicYearId?: SortOrder
    _count?: TeacherSubjectCountOrderByAggregateInput
    _max?: TeacherSubjectMaxOrderByAggregateInput
    _min?: TeacherSubjectMinOrderByAggregateInput
  }

  export type TeacherSubjectScalarWhereWithAggregatesInput = {
    AND?: TeacherSubjectScalarWhereWithAggregatesInput | TeacherSubjectScalarWhereWithAggregatesInput[]
    OR?: TeacherSubjectScalarWhereWithAggregatesInput[]
    NOT?: TeacherSubjectScalarWhereWithAggregatesInput | TeacherSubjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeacherSubject"> | string
    teacherId?: StringWithAggregatesFilter<"TeacherSubject"> | string
    subjectId?: StringWithAggregatesFilter<"TeacherSubject"> | string
    classId?: StringWithAggregatesFilter<"TeacherSubject"> | string
    academicYearId?: StringWithAggregatesFilter<"TeacherSubject"> | string
  }

  export type StudentEnrollmentWhereInput = {
    AND?: StudentEnrollmentWhereInput | StudentEnrollmentWhereInput[]
    OR?: StudentEnrollmentWhereInput[]
    NOT?: StudentEnrollmentWhereInput | StudentEnrollmentWhereInput[]
    id?: StringFilter<"StudentEnrollment"> | string
    studentId?: StringFilter<"StudentEnrollment"> | string
    classId?: StringFilter<"StudentEnrollment"> | string
    academicYearId?: StringFilter<"StudentEnrollment"> | string
    semesterId?: StringNullableFilter<"StudentEnrollment"> | string | null
    enrollmentDate?: DateTimeFilter<"StudentEnrollment"> | Date | string
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    academicYear?: XOR<AcademicYearScalarRelationFilter, AcademicYearWhereInput>
    semester?: XOR<SemesterNullableScalarRelationFilter, SemesterWhereInput> | null
  }

  export type StudentEnrollmentOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    academicYearId?: SortOrder
    semesterId?: SortOrderInput | SortOrder
    enrollmentDate?: SortOrder
    student?: UserOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
    academicYear?: AcademicYearOrderByWithRelationInput
    semester?: SemesterOrderByWithRelationInput
  }

  export type StudentEnrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_classId_academicYearId_semesterId?: StudentEnrollmentStudentIdClassIdAcademicYearIdSemesterIdCompoundUniqueInput
    AND?: StudentEnrollmentWhereInput | StudentEnrollmentWhereInput[]
    OR?: StudentEnrollmentWhereInput[]
    NOT?: StudentEnrollmentWhereInput | StudentEnrollmentWhereInput[]
    studentId?: StringFilter<"StudentEnrollment"> | string
    classId?: StringFilter<"StudentEnrollment"> | string
    academicYearId?: StringFilter<"StudentEnrollment"> | string
    semesterId?: StringNullableFilter<"StudentEnrollment"> | string | null
    enrollmentDate?: DateTimeFilter<"StudentEnrollment"> | Date | string
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    academicYear?: XOR<AcademicYearScalarRelationFilter, AcademicYearWhereInput>
    semester?: XOR<SemesterNullableScalarRelationFilter, SemesterWhereInput> | null
  }, "id" | "studentId_classId_academicYearId_semesterId">

  export type StudentEnrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    academicYearId?: SortOrder
    semesterId?: SortOrderInput | SortOrder
    enrollmentDate?: SortOrder
    _count?: StudentEnrollmentCountOrderByAggregateInput
    _max?: StudentEnrollmentMaxOrderByAggregateInput
    _min?: StudentEnrollmentMinOrderByAggregateInput
  }

  export type StudentEnrollmentScalarWhereWithAggregatesInput = {
    AND?: StudentEnrollmentScalarWhereWithAggregatesInput | StudentEnrollmentScalarWhereWithAggregatesInput[]
    OR?: StudentEnrollmentScalarWhereWithAggregatesInput[]
    NOT?: StudentEnrollmentScalarWhereWithAggregatesInput | StudentEnrollmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentEnrollment"> | string
    studentId?: StringWithAggregatesFilter<"StudentEnrollment"> | string
    classId?: StringWithAggregatesFilter<"StudentEnrollment"> | string
    academicYearId?: StringWithAggregatesFilter<"StudentEnrollment"> | string
    semesterId?: StringNullableWithAggregatesFilter<"StudentEnrollment"> | string | null
    enrollmentDate?: DateTimeWithAggregatesFilter<"StudentEnrollment"> | Date | string
  }

  export type ClassScheduleWhereInput = {
    AND?: ClassScheduleWhereInput | ClassScheduleWhereInput[]
    OR?: ClassScheduleWhereInput[]
    NOT?: ClassScheduleWhereInput | ClassScheduleWhereInput[]
    id?: StringFilter<"ClassSchedule"> | string
    classId?: StringFilter<"ClassSchedule"> | string
    subjectId?: StringFilter<"ClassSchedule"> | string
    teacherId?: StringFilter<"ClassSchedule"> | string
    dayOfWeek?: IntFilter<"ClassSchedule"> | number
    startTime?: StringFilter<"ClassSchedule"> | string
    endTime?: StringFilter<"ClassSchedule"> | string
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    teacher?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ClassScheduleOrderByWithRelationInput = {
    id?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    teacherId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    class?: ClassOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
    teacher?: UserOrderByWithRelationInput
  }

  export type ClassScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClassScheduleWhereInput | ClassScheduleWhereInput[]
    OR?: ClassScheduleWhereInput[]
    NOT?: ClassScheduleWhereInput | ClassScheduleWhereInput[]
    classId?: StringFilter<"ClassSchedule"> | string
    subjectId?: StringFilter<"ClassSchedule"> | string
    teacherId?: StringFilter<"ClassSchedule"> | string
    dayOfWeek?: IntFilter<"ClassSchedule"> | number
    startTime?: StringFilter<"ClassSchedule"> | string
    endTime?: StringFilter<"ClassSchedule"> | string
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    teacher?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ClassScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    teacherId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    _count?: ClassScheduleCountOrderByAggregateInput
    _avg?: ClassScheduleAvgOrderByAggregateInput
    _max?: ClassScheduleMaxOrderByAggregateInput
    _min?: ClassScheduleMinOrderByAggregateInput
    _sum?: ClassScheduleSumOrderByAggregateInput
  }

  export type ClassScheduleScalarWhereWithAggregatesInput = {
    AND?: ClassScheduleScalarWhereWithAggregatesInput | ClassScheduleScalarWhereWithAggregatesInput[]
    OR?: ClassScheduleScalarWhereWithAggregatesInput[]
    NOT?: ClassScheduleScalarWhereWithAggregatesInput | ClassScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClassSchedule"> | string
    classId?: StringWithAggregatesFilter<"ClassSchedule"> | string
    subjectId?: StringWithAggregatesFilter<"ClassSchedule"> | string
    teacherId?: StringWithAggregatesFilter<"ClassSchedule"> | string
    dayOfWeek?: IntWithAggregatesFilter<"ClassSchedule"> | number
    startTime?: StringWithAggregatesFilter<"ClassSchedule"> | string
    endTime?: StringWithAggregatesFilter<"ClassSchedule"> | string
  }

  export type AttendanceRecordWhereInput = {
    AND?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    OR?: AttendanceRecordWhereInput[]
    NOT?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    id?: StringFilter<"AttendanceRecord"> | string
    studentId?: StringFilter<"AttendanceRecord"> | string
    classId?: StringFilter<"AttendanceRecord"> | string
    subjectId?: StringFilter<"AttendanceRecord"> | string
    date?: DateTimeFilter<"AttendanceRecord"> | Date | string
    period?: IntNullableFilter<"AttendanceRecord"> | number | null
    status?: EnumAttendanceStatusFilter<"AttendanceRecord"> | $Enums.AttendanceStatus
    markedById?: StringFilter<"AttendanceRecord"> | string
    markedAt?: DateTimeFilter<"AttendanceRecord"> | Date | string
    remarks?: StringNullableFilter<"AttendanceRecord"> | string | null
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    markedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AttendanceRecordOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    date?: SortOrder
    period?: SortOrderInput | SortOrder
    status?: SortOrder
    markedById?: SortOrder
    markedAt?: SortOrder
    remarks?: SortOrderInput | SortOrder
    student?: UserOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
    markedBy?: UserOrderByWithRelationInput
  }

  export type AttendanceRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    OR?: AttendanceRecordWhereInput[]
    NOT?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    studentId?: StringFilter<"AttendanceRecord"> | string
    classId?: StringFilter<"AttendanceRecord"> | string
    subjectId?: StringFilter<"AttendanceRecord"> | string
    date?: DateTimeFilter<"AttendanceRecord"> | Date | string
    period?: IntNullableFilter<"AttendanceRecord"> | number | null
    status?: EnumAttendanceStatusFilter<"AttendanceRecord"> | $Enums.AttendanceStatus
    markedById?: StringFilter<"AttendanceRecord"> | string
    markedAt?: DateTimeFilter<"AttendanceRecord"> | Date | string
    remarks?: StringNullableFilter<"AttendanceRecord"> | string | null
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    markedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AttendanceRecordOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    date?: SortOrder
    period?: SortOrderInput | SortOrder
    status?: SortOrder
    markedById?: SortOrder
    markedAt?: SortOrder
    remarks?: SortOrderInput | SortOrder
    _count?: AttendanceRecordCountOrderByAggregateInput
    _avg?: AttendanceRecordAvgOrderByAggregateInput
    _max?: AttendanceRecordMaxOrderByAggregateInput
    _min?: AttendanceRecordMinOrderByAggregateInput
    _sum?: AttendanceRecordSumOrderByAggregateInput
  }

  export type AttendanceRecordScalarWhereWithAggregatesInput = {
    AND?: AttendanceRecordScalarWhereWithAggregatesInput | AttendanceRecordScalarWhereWithAggregatesInput[]
    OR?: AttendanceRecordScalarWhereWithAggregatesInput[]
    NOT?: AttendanceRecordScalarWhereWithAggregatesInput | AttendanceRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AttendanceRecord"> | string
    studentId?: StringWithAggregatesFilter<"AttendanceRecord"> | string
    classId?: StringWithAggregatesFilter<"AttendanceRecord"> | string
    subjectId?: StringWithAggregatesFilter<"AttendanceRecord"> | string
    date?: DateTimeWithAggregatesFilter<"AttendanceRecord"> | Date | string
    period?: IntNullableWithAggregatesFilter<"AttendanceRecord"> | number | null
    status?: EnumAttendanceStatusWithAggregatesFilter<"AttendanceRecord"> | $Enums.AttendanceStatus
    markedById?: StringWithAggregatesFilter<"AttendanceRecord"> | string
    markedAt?: DateTimeWithAggregatesFilter<"AttendanceRecord"> | Date | string
    remarks?: StringNullableWithAggregatesFilter<"AttendanceRecord"> | string | null
  }

  export type AttendanceSummaryWhereInput = {
    AND?: AttendanceSummaryWhereInput | AttendanceSummaryWhereInput[]
    OR?: AttendanceSummaryWhereInput[]
    NOT?: AttendanceSummaryWhereInput | AttendanceSummaryWhereInput[]
    id?: StringFilter<"AttendanceSummary"> | string
    studentId?: StringFilter<"AttendanceSummary"> | string
    subjectId?: StringFilter<"AttendanceSummary"> | string
    semesterId?: StringFilter<"AttendanceSummary"> | string
    totalClasses?: IntFilter<"AttendanceSummary"> | number
    presentCount?: IntFilter<"AttendanceSummary"> | number
    absentCount?: IntFilter<"AttendanceSummary"> | number
    lateCount?: IntFilter<"AttendanceSummary"> | number
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    semester?: XOR<SemesterScalarRelationFilter, SemesterWhereInput>
  }

  export type AttendanceSummaryOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    semesterId?: SortOrder
    totalClasses?: SortOrder
    presentCount?: SortOrder
    absentCount?: SortOrder
    lateCount?: SortOrder
    student?: UserOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
    semester?: SemesterOrderByWithRelationInput
  }

  export type AttendanceSummaryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttendanceSummaryWhereInput | AttendanceSummaryWhereInput[]
    OR?: AttendanceSummaryWhereInput[]
    NOT?: AttendanceSummaryWhereInput | AttendanceSummaryWhereInput[]
    studentId?: StringFilter<"AttendanceSummary"> | string
    subjectId?: StringFilter<"AttendanceSummary"> | string
    semesterId?: StringFilter<"AttendanceSummary"> | string
    totalClasses?: IntFilter<"AttendanceSummary"> | number
    presentCount?: IntFilter<"AttendanceSummary"> | number
    absentCount?: IntFilter<"AttendanceSummary"> | number
    lateCount?: IntFilter<"AttendanceSummary"> | number
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    semester?: XOR<SemesterScalarRelationFilter, SemesterWhereInput>
  }, "id">

  export type AttendanceSummaryOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    semesterId?: SortOrder
    totalClasses?: SortOrder
    presentCount?: SortOrder
    absentCount?: SortOrder
    lateCount?: SortOrder
    _count?: AttendanceSummaryCountOrderByAggregateInput
    _avg?: AttendanceSummaryAvgOrderByAggregateInput
    _max?: AttendanceSummaryMaxOrderByAggregateInput
    _min?: AttendanceSummaryMinOrderByAggregateInput
    _sum?: AttendanceSummarySumOrderByAggregateInput
  }

  export type AttendanceSummaryScalarWhereWithAggregatesInput = {
    AND?: AttendanceSummaryScalarWhereWithAggregatesInput | AttendanceSummaryScalarWhereWithAggregatesInput[]
    OR?: AttendanceSummaryScalarWhereWithAggregatesInput[]
    NOT?: AttendanceSummaryScalarWhereWithAggregatesInput | AttendanceSummaryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AttendanceSummary"> | string
    studentId?: StringWithAggregatesFilter<"AttendanceSummary"> | string
    subjectId?: StringWithAggregatesFilter<"AttendanceSummary"> | string
    semesterId?: StringWithAggregatesFilter<"AttendanceSummary"> | string
    totalClasses?: IntWithAggregatesFilter<"AttendanceSummary"> | number
    presentCount?: IntWithAggregatesFilter<"AttendanceSummary"> | number
    absentCount?: IntWithAggregatesFilter<"AttendanceSummary"> | number
    lateCount?: IntWithAggregatesFilter<"AttendanceSummary"> | number
  }

  export type GradeCategoryWhereInput = {
    AND?: GradeCategoryWhereInput | GradeCategoryWhereInput[]
    OR?: GradeCategoryWhereInput[]
    NOT?: GradeCategoryWhereInput | GradeCategoryWhereInput[]
    id?: StringFilter<"GradeCategory"> | string
    name?: StringFilter<"GradeCategory"> | string
    weight?: FloatFilter<"GradeCategory"> | number
    classId?: StringFilter<"GradeCategory"> | string
    subjectId?: StringFilter<"GradeCategory"> | string
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    gradeEntries?: GradeEntryListRelationFilter
  }

  export type GradeCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    weight?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    class?: ClassOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
    gradeEntries?: GradeEntryOrderByRelationAggregateInput
  }

  export type GradeCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GradeCategoryWhereInput | GradeCategoryWhereInput[]
    OR?: GradeCategoryWhereInput[]
    NOT?: GradeCategoryWhereInput | GradeCategoryWhereInput[]
    name?: StringFilter<"GradeCategory"> | string
    weight?: FloatFilter<"GradeCategory"> | number
    classId?: StringFilter<"GradeCategory"> | string
    subjectId?: StringFilter<"GradeCategory"> | string
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    gradeEntries?: GradeEntryListRelationFilter
  }, "id">

  export type GradeCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    weight?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    _count?: GradeCategoryCountOrderByAggregateInput
    _avg?: GradeCategoryAvgOrderByAggregateInput
    _max?: GradeCategoryMaxOrderByAggregateInput
    _min?: GradeCategoryMinOrderByAggregateInput
    _sum?: GradeCategorySumOrderByAggregateInput
  }

  export type GradeCategoryScalarWhereWithAggregatesInput = {
    AND?: GradeCategoryScalarWhereWithAggregatesInput | GradeCategoryScalarWhereWithAggregatesInput[]
    OR?: GradeCategoryScalarWhereWithAggregatesInput[]
    NOT?: GradeCategoryScalarWhereWithAggregatesInput | GradeCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GradeCategory"> | string
    name?: StringWithAggregatesFilter<"GradeCategory"> | string
    weight?: FloatWithAggregatesFilter<"GradeCategory"> | number
    classId?: StringWithAggregatesFilter<"GradeCategory"> | string
    subjectId?: StringWithAggregatesFilter<"GradeCategory"> | string
  }

  export type GradeEntryWhereInput = {
    AND?: GradeEntryWhereInput | GradeEntryWhereInput[]
    OR?: GradeEntryWhereInput[]
    NOT?: GradeEntryWhereInput | GradeEntryWhereInput[]
    id?: StringFilter<"GradeEntry"> | string
    studentId?: StringFilter<"GradeEntry"> | string
    subjectId?: StringFilter<"GradeEntry"> | string
    categoryId?: StringFilter<"GradeEntry"> | string
    classId?: StringFilter<"GradeEntry"> | string
    academicYearId?: StringFilter<"GradeEntry"> | string
    pointsEarned?: FloatFilter<"GradeEntry"> | number
    totalPoints?: FloatFilter<"GradeEntry"> | number
    date?: DateTimeFilter<"GradeEntry"> | Date | string
    semesterId?: StringFilter<"GradeEntry"> | string
    createdById?: StringFilter<"GradeEntry"> | string
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    category?: XOR<GradeCategoryScalarRelationFilter, GradeCategoryWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    academicYear?: XOR<AcademicYearScalarRelationFilter, AcademicYearWhereInput>
    semester?: XOR<SemesterScalarRelationFilter, SemesterWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GradeEntryOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    categoryId?: SortOrder
    classId?: SortOrder
    academicYearId?: SortOrder
    pointsEarned?: SortOrder
    totalPoints?: SortOrder
    date?: SortOrder
    semesterId?: SortOrder
    createdById?: SortOrder
    student?: UserOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
    category?: GradeCategoryOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
    academicYear?: AcademicYearOrderByWithRelationInput
    semester?: SemesterOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type GradeEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GradeEntryWhereInput | GradeEntryWhereInput[]
    OR?: GradeEntryWhereInput[]
    NOT?: GradeEntryWhereInput | GradeEntryWhereInput[]
    studentId?: StringFilter<"GradeEntry"> | string
    subjectId?: StringFilter<"GradeEntry"> | string
    categoryId?: StringFilter<"GradeEntry"> | string
    classId?: StringFilter<"GradeEntry"> | string
    academicYearId?: StringFilter<"GradeEntry"> | string
    pointsEarned?: FloatFilter<"GradeEntry"> | number
    totalPoints?: FloatFilter<"GradeEntry"> | number
    date?: DateTimeFilter<"GradeEntry"> | Date | string
    semesterId?: StringFilter<"GradeEntry"> | string
    createdById?: StringFilter<"GradeEntry"> | string
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
    category?: XOR<GradeCategoryScalarRelationFilter, GradeCategoryWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    academicYear?: XOR<AcademicYearScalarRelationFilter, AcademicYearWhereInput>
    semester?: XOR<SemesterScalarRelationFilter, SemesterWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type GradeEntryOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    categoryId?: SortOrder
    classId?: SortOrder
    academicYearId?: SortOrder
    pointsEarned?: SortOrder
    totalPoints?: SortOrder
    date?: SortOrder
    semesterId?: SortOrder
    createdById?: SortOrder
    _count?: GradeEntryCountOrderByAggregateInput
    _avg?: GradeEntryAvgOrderByAggregateInput
    _max?: GradeEntryMaxOrderByAggregateInput
    _min?: GradeEntryMinOrderByAggregateInput
    _sum?: GradeEntrySumOrderByAggregateInput
  }

  export type GradeEntryScalarWhereWithAggregatesInput = {
    AND?: GradeEntryScalarWhereWithAggregatesInput | GradeEntryScalarWhereWithAggregatesInput[]
    OR?: GradeEntryScalarWhereWithAggregatesInput[]
    NOT?: GradeEntryScalarWhereWithAggregatesInput | GradeEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GradeEntry"> | string
    studentId?: StringWithAggregatesFilter<"GradeEntry"> | string
    subjectId?: StringWithAggregatesFilter<"GradeEntry"> | string
    categoryId?: StringWithAggregatesFilter<"GradeEntry"> | string
    classId?: StringWithAggregatesFilter<"GradeEntry"> | string
    academicYearId?: StringWithAggregatesFilter<"GradeEntry"> | string
    pointsEarned?: FloatWithAggregatesFilter<"GradeEntry"> | number
    totalPoints?: FloatWithAggregatesFilter<"GradeEntry"> | number
    date?: DateTimeWithAggregatesFilter<"GradeEntry"> | Date | string
    semesterId?: StringWithAggregatesFilter<"GradeEntry"> | string
    createdById?: StringWithAggregatesFilter<"GradeEntry"> | string
  }

  export type GradeReportWhereInput = {
    AND?: GradeReportWhereInput | GradeReportWhereInput[]
    OR?: GradeReportWhereInput[]
    NOT?: GradeReportWhereInput | GradeReportWhereInput[]
    id?: StringFilter<"GradeReport"> | string
    studentId?: StringFilter<"GradeReport"> | string
    semesterId?: StringFilter<"GradeReport"> | string
    overallGpa?: FloatFilter<"GradeReport"> | number
    generatedAt?: DateTimeFilter<"GradeReport"> | Date | string
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
    semester?: XOR<SemesterScalarRelationFilter, SemesterWhereInput>
  }

  export type GradeReportOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    semesterId?: SortOrder
    overallGpa?: SortOrder
    generatedAt?: SortOrder
    student?: UserOrderByWithRelationInput
    semester?: SemesterOrderByWithRelationInput
  }

  export type GradeReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GradeReportWhereInput | GradeReportWhereInput[]
    OR?: GradeReportWhereInput[]
    NOT?: GradeReportWhereInput | GradeReportWhereInput[]
    studentId?: StringFilter<"GradeReport"> | string
    semesterId?: StringFilter<"GradeReport"> | string
    overallGpa?: FloatFilter<"GradeReport"> | number
    generatedAt?: DateTimeFilter<"GradeReport"> | Date | string
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
    semester?: XOR<SemesterScalarRelationFilter, SemesterWhereInput>
  }, "id">

  export type GradeReportOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    semesterId?: SortOrder
    overallGpa?: SortOrder
    generatedAt?: SortOrder
    _count?: GradeReportCountOrderByAggregateInput
    _avg?: GradeReportAvgOrderByAggregateInput
    _max?: GradeReportMaxOrderByAggregateInput
    _min?: GradeReportMinOrderByAggregateInput
    _sum?: GradeReportSumOrderByAggregateInput
  }

  export type GradeReportScalarWhereWithAggregatesInput = {
    AND?: GradeReportScalarWhereWithAggregatesInput | GradeReportScalarWhereWithAggregatesInput[]
    OR?: GradeReportScalarWhereWithAggregatesInput[]
    NOT?: GradeReportScalarWhereWithAggregatesInput | GradeReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GradeReport"> | string
    studentId?: StringWithAggregatesFilter<"GradeReport"> | string
    semesterId?: StringWithAggregatesFilter<"GradeReport"> | string
    overallGpa?: FloatWithAggregatesFilter<"GradeReport"> | number
    generatedAt?: DateTimeWithAggregatesFilter<"GradeReport"> | Date | string
  }

  export type AnnouncementWhereInput = {
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    id?: StringFilter<"Announcement"> | string
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    authorId?: StringFilter<"Announcement"> | string
    targetRoles?: StringNullableListFilter<"Announcement">
    targetClasses?: StringNullableListFilter<"Announcement">
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Announcement"> | Date | string | null
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AnnouncementOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    targetRoles?: SortOrder
    targetClasses?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    author?: UserOrderByWithRelationInput
  }

  export type AnnouncementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    authorId?: StringFilter<"Announcement"> | string
    targetRoles?: StringNullableListFilter<"Announcement">
    targetClasses?: StringNullableListFilter<"Announcement">
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Announcement"> | Date | string | null
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AnnouncementOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    targetRoles?: SortOrder
    targetClasses?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: AnnouncementCountOrderByAggregateInput
    _max?: AnnouncementMaxOrderByAggregateInput
    _min?: AnnouncementMinOrderByAggregateInput
  }

  export type AnnouncementScalarWhereWithAggregatesInput = {
    AND?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    OR?: AnnouncementScalarWhereWithAggregatesInput[]
    NOT?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Announcement"> | string
    title?: StringWithAggregatesFilter<"Announcement"> | string
    content?: StringWithAggregatesFilter<"Announcement"> | string
    authorId?: StringWithAggregatesFilter<"Announcement"> | string
    targetRoles?: StringNullableListFilter<"Announcement">
    targetClasses?: StringNullableListFilter<"Announcement">
    createdAt?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Announcement"> | Date | string | null
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    recipientId?: StringFilter<"Message"> | string
    subject?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    sentAt?: DateTimeFilter<"Message"> | Date | string
    parentMessageId?: StringNullableFilter<"Message"> | string | null
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
    parentMessage?: XOR<MessageNullableScalarRelationFilter, MessageWhereInput> | null
    childMessages?: MessageListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    sentAt?: SortOrder
    parentMessageId?: SortOrderInput | SortOrder
    sender?: UserOrderByWithRelationInput
    recipient?: UserOrderByWithRelationInput
    parentMessage?: MessageOrderByWithRelationInput
    childMessages?: MessageOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    senderId?: StringFilter<"Message"> | string
    recipientId?: StringFilter<"Message"> | string
    subject?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    sentAt?: DateTimeFilter<"Message"> | Date | string
    parentMessageId?: StringNullableFilter<"Message"> | string | null
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
    parentMessage?: XOR<MessageNullableScalarRelationFilter, MessageWhereInput> | null
    childMessages?: MessageListRelationFilter
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    sentAt?: SortOrder
    parentMessageId?: SortOrderInput | SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    recipientId?: StringWithAggregatesFilter<"Message"> | string
    subject?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    isRead?: BoolWithAggregatesFilter<"Message"> | boolean
    sentAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    parentMessageId?: StringNullableWithAggregatesFilter<"Message"> | string | null
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    content?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    title?: StringFilter<"Document"> | string
    fileName?: StringFilter<"Document"> | string
    filePath?: StringFilter<"Document"> | string
    fileSize?: IntFilter<"Document"> | number
    mimeType?: StringFilter<"Document"> | string
    uploadedById?: StringFilter<"Document"> | string
    category?: StringFilter<"Document"> | string
    classId?: StringNullableFilter<"Document"> | string | null
    subjectId?: StringNullableFilter<"Document"> | string | null
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
    subject?: XOR<SubjectNullableScalarRelationFilter, SubjectWhereInput> | null
    permissions?: DocumentPermissionListRelationFilter
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedById?: SortOrder
    category?: SortOrder
    classId?: SortOrderInput | SortOrder
    subjectId?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: UserOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
    permissions?: DocumentPermissionOrderByRelationAggregateInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    title?: StringFilter<"Document"> | string
    fileName?: StringFilter<"Document"> | string
    filePath?: StringFilter<"Document"> | string
    fileSize?: IntFilter<"Document"> | number
    mimeType?: StringFilter<"Document"> | string
    uploadedById?: StringFilter<"Document"> | string
    category?: StringFilter<"Document"> | string
    classId?: StringNullableFilter<"Document"> | string | null
    subjectId?: StringNullableFilter<"Document"> | string | null
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
    subject?: XOR<SubjectNullableScalarRelationFilter, SubjectWhereInput> | null
    permissions?: DocumentPermissionListRelationFilter
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedById?: SortOrder
    category?: SortOrder
    classId?: SortOrderInput | SortOrder
    subjectId?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    title?: StringWithAggregatesFilter<"Document"> | string
    fileName?: StringWithAggregatesFilter<"Document"> | string
    filePath?: StringWithAggregatesFilter<"Document"> | string
    fileSize?: IntWithAggregatesFilter<"Document"> | number
    mimeType?: StringWithAggregatesFilter<"Document"> | string
    uploadedById?: StringWithAggregatesFilter<"Document"> | string
    category?: StringWithAggregatesFilter<"Document"> | string
    classId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    subjectId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    uploadedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type DocumentPermissionWhereInput = {
    AND?: DocumentPermissionWhereInput | DocumentPermissionWhereInput[]
    OR?: DocumentPermissionWhereInput[]
    NOT?: DocumentPermissionWhereInput | DocumentPermissionWhereInput[]
    id?: StringFilter<"DocumentPermission"> | string
    documentId?: StringFilter<"DocumentPermission"> | string
    userId?: StringFilter<"DocumentPermission"> | string
    permissionType?: StringFilter<"DocumentPermission"> | string
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DocumentPermissionOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    userId?: SortOrder
    permissionType?: SortOrder
    document?: DocumentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type DocumentPermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentPermissionWhereInput | DocumentPermissionWhereInput[]
    OR?: DocumentPermissionWhereInput[]
    NOT?: DocumentPermissionWhereInput | DocumentPermissionWhereInput[]
    documentId?: StringFilter<"DocumentPermission"> | string
    userId?: StringFilter<"DocumentPermission"> | string
    permissionType?: StringFilter<"DocumentPermission"> | string
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DocumentPermissionOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    userId?: SortOrder
    permissionType?: SortOrder
    _count?: DocumentPermissionCountOrderByAggregateInput
    _max?: DocumentPermissionMaxOrderByAggregateInput
    _min?: DocumentPermissionMinOrderByAggregateInput
  }

  export type DocumentPermissionScalarWhereWithAggregatesInput = {
    AND?: DocumentPermissionScalarWhereWithAggregatesInput | DocumentPermissionScalarWhereWithAggregatesInput[]
    OR?: DocumentPermissionScalarWhereWithAggregatesInput[]
    NOT?: DocumentPermissionScalarWhereWithAggregatesInput | DocumentPermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentPermission"> | string
    documentId?: StringWithAggregatesFilter<"DocumentPermission"> | string
    userId?: StringWithAggregatesFilter<"DocumentPermission"> | string
    permissionType?: StringWithAggregatesFilter<"DocumentPermission"> | string
  }

  export type ExamWhereInput = {
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    id?: StringFilter<"Exam"> | string
    title?: StringFilter<"Exam"> | string
    subjectId?: StringFilter<"Exam"> | string
    classId?: StringFilter<"Exam"> | string
    type?: StringFilter<"Exam"> | string
    date?: DateTimeFilter<"Exam"> | Date | string
    duration?: IntFilter<"Exam"> | number
    maxScore?: IntFilter<"Exam"> | number
    status?: StringFilter<"Exam"> | string
    instructions?: StringNullableFilter<"Exam"> | string | null
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
  }

  export type ExamOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    subjectId?: SortOrder
    classId?: SortOrder
    type?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    maxScore?: SortOrder
    status?: SortOrder
    instructions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    title?: StringFilter<"Exam"> | string
    subjectId?: StringFilter<"Exam"> | string
    classId?: StringFilter<"Exam"> | string
    type?: StringFilter<"Exam"> | string
    date?: DateTimeFilter<"Exam"> | Date | string
    duration?: IntFilter<"Exam"> | number
    maxScore?: IntFilter<"Exam"> | number
    status?: StringFilter<"Exam"> | string
    instructions?: StringNullableFilter<"Exam"> | string | null
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
  }, "id">

  export type ExamOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    subjectId?: SortOrder
    classId?: SortOrder
    type?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    maxScore?: SortOrder
    status?: SortOrder
    instructions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExamCountOrderByAggregateInput
    _avg?: ExamAvgOrderByAggregateInput
    _max?: ExamMaxOrderByAggregateInput
    _min?: ExamMinOrderByAggregateInput
    _sum?: ExamSumOrderByAggregateInput
  }

  export type ExamScalarWhereWithAggregatesInput = {
    AND?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    OR?: ExamScalarWhereWithAggregatesInput[]
    NOT?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Exam"> | string
    title?: StringWithAggregatesFilter<"Exam"> | string
    subjectId?: StringWithAggregatesFilter<"Exam"> | string
    classId?: StringWithAggregatesFilter<"Exam"> | string
    type?: StringWithAggregatesFilter<"Exam"> | string
    date?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
    duration?: IntWithAggregatesFilter<"Exam"> | number
    maxScore?: IntWithAggregatesFilter<"Exam"> | number
    status?: StringWithAggregatesFilter<"Exam"> | string
    instructions?: StringNullableWithAggregatesFilter<"Exam"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
  }

  export type StudentRegistrationRequestWhereInput = {
    AND?: StudentRegistrationRequestWhereInput | StudentRegistrationRequestWhereInput[]
    OR?: StudentRegistrationRequestWhereInput[]
    NOT?: StudentRegistrationRequestWhereInput | StudentRegistrationRequestWhereInput[]
    id?: StringFilter<"StudentRegistrationRequest"> | string
    studentId?: StringFilter<"StudentRegistrationRequest"> | string
    semesterId?: StringFilter<"StudentRegistrationRequest"> | string
    status?: StringFilter<"StudentRegistrationRequest"> | string
    createdAt?: DateTimeFilter<"StudentRegistrationRequest"> | Date | string
    approvedAt?: DateTimeNullableFilter<"StudentRegistrationRequest"> | Date | string | null
    adminId?: StringNullableFilter<"StudentRegistrationRequest"> | string | null
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
    semester?: XOR<SemesterScalarRelationFilter, SemesterWhereInput>
  }

  export type StudentRegistrationRequestOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    semesterId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    adminId?: SortOrderInput | SortOrder
    student?: UserOrderByWithRelationInput
    semester?: SemesterOrderByWithRelationInput
  }

  export type StudentRegistrationRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentRegistrationRequestWhereInput | StudentRegistrationRequestWhereInput[]
    OR?: StudentRegistrationRequestWhereInput[]
    NOT?: StudentRegistrationRequestWhereInput | StudentRegistrationRequestWhereInput[]
    studentId?: StringFilter<"StudentRegistrationRequest"> | string
    semesterId?: StringFilter<"StudentRegistrationRequest"> | string
    status?: StringFilter<"StudentRegistrationRequest"> | string
    createdAt?: DateTimeFilter<"StudentRegistrationRequest"> | Date | string
    approvedAt?: DateTimeNullableFilter<"StudentRegistrationRequest"> | Date | string | null
    adminId?: StringNullableFilter<"StudentRegistrationRequest"> | string | null
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
    semester?: XOR<SemesterScalarRelationFilter, SemesterWhereInput>
  }, "id">

  export type StudentRegistrationRequestOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    semesterId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    adminId?: SortOrderInput | SortOrder
    _count?: StudentRegistrationRequestCountOrderByAggregateInput
    _max?: StudentRegistrationRequestMaxOrderByAggregateInput
    _min?: StudentRegistrationRequestMinOrderByAggregateInput
  }

  export type StudentRegistrationRequestScalarWhereWithAggregatesInput = {
    AND?: StudentRegistrationRequestScalarWhereWithAggregatesInput | StudentRegistrationRequestScalarWhereWithAggregatesInput[]
    OR?: StudentRegistrationRequestScalarWhereWithAggregatesInput[]
    NOT?: StudentRegistrationRequestScalarWhereWithAggregatesInput | StudentRegistrationRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentRegistrationRequest"> | string
    studentId?: StringWithAggregatesFilter<"StudentRegistrationRequest"> | string
    semesterId?: StringWithAggregatesFilter<"StudentRegistrationRequest"> | string
    status?: StringWithAggregatesFilter<"StudentRegistrationRequest"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StudentRegistrationRequest"> | Date | string
    approvedAt?: DateTimeNullableWithAggregatesFilter<"StudentRegistrationRequest"> | Date | string | null
    adminId?: StringNullableWithAggregatesFilter<"StudentRegistrationRequest"> | string | null
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestCreateNestedManyWithoutStudentInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryUncheckedCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportUncheckedCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUpdateManyWithoutStudentNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUncheckedUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateInput = {
    sessionId?: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type UserSessionUncheckedCreateInput = {
    sessionId?: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type UserSessionUpdateInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateManyInput = {
    sessionId?: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type UserSessionUpdateManyMutationInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicYearCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    createdBy: string
    semesters?: SemesterCreateNestedManyWithoutAcademicYearInput
    classes?: ClassCreateNestedManyWithoutAcademicYearInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutAcademicYearInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutAcademicYearInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearUncheckedCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    createdBy: string
    semesters?: SemesterUncheckedCreateNestedManyWithoutAcademicYearInput
    classes?: ClassUncheckedCreateNestedManyWithoutAcademicYearInput
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutAcademicYearInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutAcademicYearInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    semesters?: SemesterUpdateManyWithoutAcademicYearNestedInput
    classes?: ClassUpdateManyWithoutAcademicYearNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutAcademicYearNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutAcademicYearNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutAcademicYearNestedInput
  }

  export type AcademicYearUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    semesters?: SemesterUncheckedUpdateManyWithoutAcademicYearNestedInput
    classes?: ClassUncheckedUpdateManyWithoutAcademicYearNestedInput
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutAcademicYearNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutAcademicYearNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutAcademicYearNestedInput
  }

  export type AcademicYearCreateManyInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    createdBy: string
  }

  export type AcademicYearUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type AcademicYearUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type SemesterCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    registrationOpen?: boolean
    minAverage?: number | null
    noFailedSubjects?: boolean | null
    academicYear: AcademicYearCreateNestedOneWithoutSemestersInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutSemesterInput
    gradeReports?: GradeReportCreateNestedManyWithoutSemesterInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutSemesterInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutSemesterInput
    registrationRequests?: StudentRegistrationRequestCreateNestedManyWithoutSemesterInput
  }

  export type SemesterUncheckedCreateInput = {
    id?: string
    name: string
    academicYearId: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    registrationOpen?: boolean
    minAverage?: number | null
    noFailedSubjects?: boolean | null
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutSemesterInput
    gradeReports?: GradeReportUncheckedCreateNestedManyWithoutSemesterInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutSemesterInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutSemesterInput
    registrationRequests?: StudentRegistrationRequestUncheckedCreateNestedManyWithoutSemesterInput
  }

  export type SemesterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    registrationOpen?: BoolFieldUpdateOperationsInput | boolean
    minAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    noFailedSubjects?: NullableBoolFieldUpdateOperationsInput | boolean | null
    academicYear?: AcademicYearUpdateOneRequiredWithoutSemestersNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutSemesterNestedInput
    gradeReports?: GradeReportUpdateManyWithoutSemesterNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutSemesterNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutSemesterNestedInput
    registrationRequests?: StudentRegistrationRequestUpdateManyWithoutSemesterNestedInput
  }

  export type SemesterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    registrationOpen?: BoolFieldUpdateOperationsInput | boolean
    minAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    noFailedSubjects?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutSemesterNestedInput
    gradeReports?: GradeReportUncheckedUpdateManyWithoutSemesterNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutSemesterNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutSemesterNestedInput
    registrationRequests?: StudentRegistrationRequestUncheckedUpdateManyWithoutSemesterNestedInput
  }

  export type SemesterCreateManyInput = {
    id?: string
    name: string
    academicYearId: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    registrationOpen?: boolean
    minAverage?: number | null
    noFailedSubjects?: boolean | null
  }

  export type SemesterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    registrationOpen?: BoolFieldUpdateOperationsInput | boolean
    minAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    noFailedSubjects?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SemesterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    registrationOpen?: BoolFieldUpdateOperationsInput | boolean
    minAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    noFailedSubjects?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ClassSectionCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    grade: GradeCreateNestedOneWithoutClassSectionsInput
    classes?: ClassCreateNestedManyWithoutClassSectionInput
  }

  export type ClassSectionUncheckedCreateInput = {
    id?: string
    name: string
    gradeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassUncheckedCreateNestedManyWithoutClassSectionInput
  }

  export type ClassSectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: GradeUpdateOneRequiredWithoutClassSectionsNestedInput
    classes?: ClassUpdateManyWithoutClassSectionNestedInput
  }

  export type ClassSectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUncheckedUpdateManyWithoutClassSectionNestedInput
  }

  export type ClassSectionCreateManyInput = {
    id?: string
    name: string
    gradeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassSectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassSectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeCreateInput = {
    id?: string
    name: string
    level: number
    classSections?: ClassSectionCreateNestedManyWithoutGradeInput
    subjects?: SubjectCreateNestedManyWithoutGradeInput
    classes?: ClassCreateNestedManyWithoutGradeInput
  }

  export type GradeUncheckedCreateInput = {
    id?: string
    name: string
    level: number
    classSections?: ClassSectionUncheckedCreateNestedManyWithoutGradeInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutGradeInput
    classes?: ClassUncheckedCreateNestedManyWithoutGradeInput
  }

  export type GradeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    classSections?: ClassSectionUpdateManyWithoutGradeNestedInput
    subjects?: SubjectUpdateManyWithoutGradeNestedInput
    classes?: ClassUpdateManyWithoutGradeNestedInput
  }

  export type GradeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    classSections?: ClassSectionUncheckedUpdateManyWithoutGradeNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutGradeNestedInput
    classes?: ClassUncheckedUpdateManyWithoutGradeNestedInput
  }

  export type GradeCreateManyInput = {
    id?: string
    name: string
    level: number
  }

  export type GradeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type GradeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type SubjectCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    grade: GradeCreateNestedOneWithoutSubjectsInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutSubjectInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutSubjectInput
    gradeCategories?: GradeCategoryCreateNestedManyWithoutSubjectInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutSubjectInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutSubjectInput
    documents?: DocumentCreateNestedManyWithoutSubjectInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    gradeId: string
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutSubjectInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutSubjectInput
    gradeCategories?: GradeCategoryUncheckedCreateNestedManyWithoutSubjectInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutSubjectInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutSubjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSubjectInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: GradeUpdateOneRequiredWithoutSubjectsNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutSubjectNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutSubjectNestedInput
    gradeCategories?: GradeCategoryUpdateManyWithoutSubjectNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutSubjectNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutSubjectNestedInput
    documents?: DocumentUpdateManyWithoutSubjectNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: StringFieldUpdateOperationsInput | string
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutSubjectNestedInput
    gradeCategories?: GradeCategoryUncheckedUpdateManyWithoutSubjectNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutSubjectNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutSubjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSubjectNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectCreateManyInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    gradeId: string
  }

  export type SubjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: StringFieldUpdateOperationsInput | string
  }

  export type ClassCreateInput = {
    id?: string
    grade: GradeCreateNestedOneWithoutClassesInput
    classSection: ClassSectionCreateNestedOneWithoutClassesInput
    academicYear: AcademicYearCreateNestedOneWithoutClassesInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutClassInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutClassInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClassInput
    documents?: DocumentCreateNestedManyWithoutClassInput
    gradeCategories?: GradeCategoryCreateNestedManyWithoutClassInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateInput = {
    id?: string
    gradeId: string
    classSectionId: string
    academicYearId: string
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutClassInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutClassInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClassInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClassInput
    gradeCategories?: GradeCategoryUncheckedCreateNestedManyWithoutClassInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: GradeUpdateOneRequiredWithoutClassesNestedInput
    classSection?: ClassSectionUpdateOneRequiredWithoutClassesNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutClassesNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutClassNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutClassNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClassNestedInput
    documents?: DocumentUpdateManyWithoutClassNestedInput
    gradeCategories?: GradeCategoryUpdateManyWithoutClassNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    classSectionId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutClassNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutClassNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClassNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClassNestedInput
    gradeCategories?: GradeCategoryUncheckedUpdateManyWithoutClassNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassCreateManyInput = {
    id?: string
    gradeId: string
    classSectionId: string
    academicYearId: string
  }

  export type ClassUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ClassUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    classSectionId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherSubjectCreateInput = {
    id?: string
    teacher: UserCreateNestedOneWithoutTeacherSubjectsInput
    subject: SubjectCreateNestedOneWithoutTeacherSubjectsInput
    class: ClassCreateNestedOneWithoutTeacherSubjectsInput
    academicYear: AcademicYearCreateNestedOneWithoutTeacherSubjectsInput
  }

  export type TeacherSubjectUncheckedCreateInput = {
    id?: string
    teacherId: string
    subjectId: string
    classId: string
    academicYearId: string
  }

  export type TeacherSubjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacher?: UserUpdateOneRequiredWithoutTeacherSubjectsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutTeacherSubjectsNestedInput
    class?: ClassUpdateOneRequiredWithoutTeacherSubjectsNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutTeacherSubjectsNestedInput
  }

  export type TeacherSubjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherSubjectCreateManyInput = {
    id?: string
    teacherId: string
    subjectId: string
    classId: string
    academicYearId: string
  }

  export type TeacherSubjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherSubjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentEnrollmentCreateInput = {
    id?: string
    enrollmentDate?: Date | string
    student: UserCreateNestedOneWithoutStudentEnrollmentsInput
    class: ClassCreateNestedOneWithoutStudentEnrollmentsInput
    academicYear: AcademicYearCreateNestedOneWithoutStudentEnrollmentsInput
    semester?: SemesterCreateNestedOneWithoutStudentEnrollmentsInput
  }

  export type StudentEnrollmentUncheckedCreateInput = {
    id?: string
    studentId: string
    classId: string
    academicYearId: string
    semesterId?: string | null
    enrollmentDate?: Date | string
  }

  export type StudentEnrollmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: UserUpdateOneRequiredWithoutStudentEnrollmentsNestedInput
    class?: ClassUpdateOneRequiredWithoutStudentEnrollmentsNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutStudentEnrollmentsNestedInput
    semester?: SemesterUpdateOneWithoutStudentEnrollmentsNestedInput
  }

  export type StudentEnrollmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    semesterId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentEnrollmentCreateManyInput = {
    id?: string
    studentId: string
    classId: string
    academicYearId: string
    semesterId?: string | null
    enrollmentDate?: Date | string
  }

  export type StudentEnrollmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentEnrollmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    semesterId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassScheduleCreateInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    class: ClassCreateNestedOneWithoutClassSchedulesInput
    subject: SubjectCreateNestedOneWithoutClassSchedulesInput
    teacher: UserCreateNestedOneWithoutClassSchedulesInput
  }

  export type ClassScheduleUncheckedCreateInput = {
    id?: string
    classId: string
    subjectId: string
    teacherId: string
    dayOfWeek: number
    startTime: string
    endTime: string
  }

  export type ClassScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    class?: ClassUpdateOneRequiredWithoutClassSchedulesNestedInput
    subject?: SubjectUpdateOneRequiredWithoutClassSchedulesNestedInput
    teacher?: UserUpdateOneRequiredWithoutClassSchedulesNestedInput
  }

  export type ClassScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
  }

  export type ClassScheduleCreateManyInput = {
    id?: string
    classId: string
    subjectId: string
    teacherId: string
    dayOfWeek: number
    startTime: string
    endTime: string
  }

  export type ClassScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
  }

  export type ClassScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
  }

  export type AttendanceRecordCreateInput = {
    id?: string
    date: Date | string
    period?: number | null
    status: $Enums.AttendanceStatus
    markedAt?: Date | string
    remarks?: string | null
    student: UserCreateNestedOneWithoutAttendanceRecordsAsStudentInput
    class: ClassCreateNestedOneWithoutAttendanceRecordsInput
    subject: SubjectCreateNestedOneWithoutAttendanceRecordsInput
    markedBy: UserCreateNestedOneWithoutAttendanceRecordsMarkedInput
  }

  export type AttendanceRecordUncheckedCreateInput = {
    id?: string
    studentId: string
    classId: string
    subjectId: string
    date: Date | string
    period?: number | null
    status: $Enums.AttendanceStatus
    markedById: string
    markedAt?: Date | string
    remarks?: string | null
  }

  export type AttendanceRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    markedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    student?: UserUpdateOneRequiredWithoutAttendanceRecordsAsStudentNestedInput
    class?: ClassUpdateOneRequiredWithoutAttendanceRecordsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutAttendanceRecordsNestedInput
    markedBy?: UserUpdateOneRequiredWithoutAttendanceRecordsMarkedNestedInput
  }

  export type AttendanceRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    markedById?: StringFieldUpdateOperationsInput | string
    markedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceRecordCreateManyInput = {
    id?: string
    studentId: string
    classId: string
    subjectId: string
    date: Date | string
    period?: number | null
    status: $Enums.AttendanceStatus
    markedById: string
    markedAt?: Date | string
    remarks?: string | null
  }

  export type AttendanceRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    markedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    markedById?: StringFieldUpdateOperationsInput | string
    markedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceSummaryCreateInput = {
    id?: string
    totalClasses: number
    presentCount: number
    absentCount: number
    lateCount: number
    student: UserCreateNestedOneWithoutAttendanceSummariesInput
    subject: SubjectCreateNestedOneWithoutAttendanceSummariesInput
    semester: SemesterCreateNestedOneWithoutAttendanceSummariesInput
  }

  export type AttendanceSummaryUncheckedCreateInput = {
    id?: string
    studentId: string
    subjectId: string
    semesterId: string
    totalClasses: number
    presentCount: number
    absentCount: number
    lateCount: number
  }

  export type AttendanceSummaryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalClasses?: IntFieldUpdateOperationsInput | number
    presentCount?: IntFieldUpdateOperationsInput | number
    absentCount?: IntFieldUpdateOperationsInput | number
    lateCount?: IntFieldUpdateOperationsInput | number
    student?: UserUpdateOneRequiredWithoutAttendanceSummariesNestedInput
    subject?: SubjectUpdateOneRequiredWithoutAttendanceSummariesNestedInput
    semester?: SemesterUpdateOneRequiredWithoutAttendanceSummariesNestedInput
  }

  export type AttendanceSummaryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    totalClasses?: IntFieldUpdateOperationsInput | number
    presentCount?: IntFieldUpdateOperationsInput | number
    absentCount?: IntFieldUpdateOperationsInput | number
    lateCount?: IntFieldUpdateOperationsInput | number
  }

  export type AttendanceSummaryCreateManyInput = {
    id?: string
    studentId: string
    subjectId: string
    semesterId: string
    totalClasses: number
    presentCount: number
    absentCount: number
    lateCount: number
  }

  export type AttendanceSummaryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalClasses?: IntFieldUpdateOperationsInput | number
    presentCount?: IntFieldUpdateOperationsInput | number
    absentCount?: IntFieldUpdateOperationsInput | number
    lateCount?: IntFieldUpdateOperationsInput | number
  }

  export type AttendanceSummaryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    totalClasses?: IntFieldUpdateOperationsInput | number
    presentCount?: IntFieldUpdateOperationsInput | number
    absentCount?: IntFieldUpdateOperationsInput | number
    lateCount?: IntFieldUpdateOperationsInput | number
  }

  export type GradeCategoryCreateInput = {
    id?: string
    name: string
    weight: number
    class: ClassCreateNestedOneWithoutGradeCategoriesInput
    subject: SubjectCreateNestedOneWithoutGradeCategoriesInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutCategoryInput
  }

  export type GradeCategoryUncheckedCreateInput = {
    id?: string
    name: string
    weight: number
    classId: string
    subjectId: string
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type GradeCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    class?: ClassUpdateOneRequiredWithoutGradeCategoriesNestedInput
    subject?: SubjectUpdateOneRequiredWithoutGradeCategoriesNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutCategoryNestedInput
  }

  export type GradeCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type GradeCategoryCreateManyInput = {
    id?: string
    name: string
    weight: number
    classId: string
    subjectId: string
  }

  export type GradeCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
  }

  export type GradeCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
  }

  export type GradeEntryCreateInput = {
    id?: string
    pointsEarned: number
    totalPoints: number
    date: Date | string
    student: UserCreateNestedOneWithoutGradeEntriesAsStudentInput
    subject: SubjectCreateNestedOneWithoutGradeEntriesInput
    category: GradeCategoryCreateNestedOneWithoutGradeEntriesInput
    class: ClassCreateNestedOneWithoutGradeEntriesInput
    academicYear: AcademicYearCreateNestedOneWithoutGradeEntriesInput
    semester: SemesterCreateNestedOneWithoutGradeEntriesInput
    createdBy: UserCreateNestedOneWithoutGradeEntriesCreatedInput
  }

  export type GradeEntryUncheckedCreateInput = {
    id?: string
    studentId: string
    subjectId: string
    categoryId: string
    classId: string
    academicYearId: string
    pointsEarned: number
    totalPoints: number
    date: Date | string
    semesterId: string
    createdById: string
  }

  export type GradeEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointsEarned?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: UserUpdateOneRequiredWithoutGradeEntriesAsStudentNestedInput
    subject?: SubjectUpdateOneRequiredWithoutGradeEntriesNestedInput
    category?: GradeCategoryUpdateOneRequiredWithoutGradeEntriesNestedInput
    class?: ClassUpdateOneRequiredWithoutGradeEntriesNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutGradeEntriesNestedInput
    semester?: SemesterUpdateOneRequiredWithoutGradeEntriesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutGradeEntriesCreatedNestedInput
  }

  export type GradeEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    pointsEarned?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type GradeEntryCreateManyInput = {
    id?: string
    studentId: string
    subjectId: string
    categoryId: string
    classId: string
    academicYearId: string
    pointsEarned: number
    totalPoints: number
    date: Date | string
    semesterId: string
    createdById: string
  }

  export type GradeEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointsEarned?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    pointsEarned?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type GradeReportCreateInput = {
    id?: string
    overallGpa: number
    generatedAt?: Date | string
    student: UserCreateNestedOneWithoutGradeReportsInput
    semester: SemesterCreateNestedOneWithoutGradeReportsInput
  }

  export type GradeReportUncheckedCreateInput = {
    id?: string
    studentId: string
    semesterId: string
    overallGpa: number
    generatedAt?: Date | string
  }

  export type GradeReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallGpa?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: UserUpdateOneRequiredWithoutGradeReportsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutGradeReportsNestedInput
  }

  export type GradeReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    overallGpa?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeReportCreateManyInput = {
    id?: string
    studentId: string
    semesterId: string
    overallGpa: number
    generatedAt?: Date | string
  }

  export type GradeReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallGpa?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    overallGpa?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementCreateInput = {
    id?: string
    title: string
    content: string
    targetRoles?: AnnouncementCreatetargetRolesInput | string[]
    targetClasses?: AnnouncementCreatetargetClassesInput | string[]
    createdAt?: Date | string
    expiresAt?: Date | string | null
    author: UserCreateNestedOneWithoutAnnouncementsInput
  }

  export type AnnouncementUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    authorId: string
    targetRoles?: AnnouncementCreatetargetRolesInput | string[]
    targetClasses?: AnnouncementCreatetargetClassesInput | string[]
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type AnnouncementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetRoles?: AnnouncementUpdatetargetRolesInput | string[]
    targetClasses?: AnnouncementUpdatetargetClassesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: UserUpdateOneRequiredWithoutAnnouncementsNestedInput
  }

  export type AnnouncementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    targetRoles?: AnnouncementUpdatetargetRolesInput | string[]
    targetClasses?: AnnouncementUpdatetargetClassesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnnouncementCreateManyInput = {
    id?: string
    title: string
    content: string
    authorId: string
    targetRoles?: AnnouncementCreatetargetRolesInput | string[]
    targetClasses?: AnnouncementCreatetargetClassesInput | string[]
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type AnnouncementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetRoles?: AnnouncementUpdatetargetRolesInput | string[]
    targetClasses?: AnnouncementUpdatetargetClassesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnnouncementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    targetRoles?: AnnouncementUpdatetargetRolesInput | string[]
    targetClasses?: AnnouncementUpdatetargetClassesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageCreateInput = {
    id?: string
    subject: string
    content: string
    isRead?: boolean
    sentAt?: Date | string
    sender: UserCreateNestedOneWithoutMessagesSentInput
    recipient: UserCreateNestedOneWithoutMessagesReceivedInput
    parentMessage?: MessageCreateNestedOneWithoutChildMessagesInput
    childMessages?: MessageCreateNestedManyWithoutParentMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    senderId: string
    recipientId: string
    subject: string
    content: string
    isRead?: boolean
    sentAt?: Date | string
    parentMessageId?: string | null
    childMessages?: MessageUncheckedCreateNestedManyWithoutParentMessageInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutMessagesSentNestedInput
    recipient?: UserUpdateOneRequiredWithoutMessagesReceivedNestedInput
    parentMessage?: MessageUpdateOneWithoutChildMessagesNestedInput
    childMessages?: MessageUpdateManyWithoutParentMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    childMessages?: MessageUncheckedUpdateManyWithoutParentMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    senderId: string
    recipientId: string
    subject: string
    content: string
    isRead?: boolean
    sentAt?: Date | string
    parentMessageId?: string | null
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentMessageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    content: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    content: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    title: string
    content: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    title: string
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    category: string
    uploadedAt?: Date | string
    uploadedBy: UserCreateNestedOneWithoutDocumentsInput
    class?: ClassCreateNestedOneWithoutDocumentsInput
    subject?: SubjectCreateNestedOneWithoutDocumentsInput
    permissions?: DocumentPermissionCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    title: string
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedById: string
    category: string
    classId?: string | null
    subjectId?: string | null
    uploadedAt?: Date | string
    permissions?: DocumentPermissionUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    class?: ClassUpdateOneWithoutDocumentsNestedInput
    subject?: SubjectUpdateOneWithoutDocumentsNestedInput
    permissions?: DocumentPermissionUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: DocumentPermissionUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentCreateManyInput = {
    id?: string
    title: string
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedById: string
    category: string
    classId?: string | null
    subjectId?: string | null
    uploadedAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentPermissionCreateInput = {
    id?: string
    permissionType: string
    document: DocumentCreateNestedOneWithoutPermissionsInput
    user: UserCreateNestedOneWithoutDocumentPermissionsInput
  }

  export type DocumentPermissionUncheckedCreateInput = {
    id?: string
    documentId: string
    userId: string
    permissionType: string
  }

  export type DocumentPermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionType?: StringFieldUpdateOperationsInput | string
    document?: DocumentUpdateOneRequiredWithoutPermissionsNestedInput
    user?: UserUpdateOneRequiredWithoutDocumentPermissionsNestedInput
  }

  export type DocumentPermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissionType?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentPermissionCreateManyInput = {
    id?: string
    documentId: string
    userId: string
    permissionType: string
  }

  export type DocumentPermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionType?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentPermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissionType?: StringFieldUpdateOperationsInput | string
  }

  export type ExamCreateInput = {
    id?: string
    title: string
    subjectId: string
    classId: string
    type: string
    date: Date | string
    duration: number
    maxScore: number
    status: string
    instructions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamUncheckedCreateInput = {
    id?: string
    title: string
    subjectId: string
    classId: string
    type: string
    date: Date | string
    duration: number
    maxScore: number
    status: string
    instructions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    maxScore?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    maxScore?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamCreateManyInput = {
    id?: string
    title: string
    subjectId: string
    classId: string
    type: string
    date: Date | string
    duration: number
    maxScore: number
    status: string
    instructions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    maxScore?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    maxScore?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentRegistrationRequestCreateInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    approvedAt?: Date | string | null
    adminId?: string | null
    student: UserCreateNestedOneWithoutRegistrationRequestsInput
    semester: SemesterCreateNestedOneWithoutRegistrationRequestsInput
  }

  export type StudentRegistrationRequestUncheckedCreateInput = {
    id?: string
    studentId: string
    semesterId: string
    status?: string
    createdAt?: Date | string
    approvedAt?: Date | string | null
    adminId?: string | null
  }

  export type StudentRegistrationRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    student?: UserUpdateOneRequiredWithoutRegistrationRequestsNestedInput
    semester?: SemesterUpdateOneRequiredWithoutRegistrationRequestsNestedInput
  }

  export type StudentRegistrationRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentRegistrationRequestCreateManyInput = {
    id?: string
    studentId: string
    semesterId: string
    status?: string
    createdAt?: Date | string
    approvedAt?: Date | string | null
    adminId?: string | null
  }

  export type StudentRegistrationRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentRegistrationRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserSessionListRelationFilter = {
    every?: UserSessionWhereInput
    some?: UserSessionWhereInput
    none?: UserSessionWhereInput
  }

  export type AnnouncementListRelationFilter = {
    every?: AnnouncementWhereInput
    some?: AnnouncementWhereInput
    none?: AnnouncementWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type DocumentPermissionListRelationFilter = {
    every?: DocumentPermissionWhereInput
    some?: DocumentPermissionWhereInput
    none?: DocumentPermissionWhereInput
  }

  export type TeacherSubjectListRelationFilter = {
    every?: TeacherSubjectWhereInput
    some?: TeacherSubjectWhereInput
    none?: TeacherSubjectWhereInput
  }

  export type StudentEnrollmentListRelationFilter = {
    every?: StudentEnrollmentWhereInput
    some?: StudentEnrollmentWhereInput
    none?: StudentEnrollmentWhereInput
  }

  export type ClassScheduleListRelationFilter = {
    every?: ClassScheduleWhereInput
    some?: ClassScheduleWhereInput
    none?: ClassScheduleWhereInput
  }

  export type AttendanceRecordListRelationFilter = {
    every?: AttendanceRecordWhereInput
    some?: AttendanceRecordWhereInput
    none?: AttendanceRecordWhereInput
  }

  export type AttendanceSummaryListRelationFilter = {
    every?: AttendanceSummaryWhereInput
    some?: AttendanceSummaryWhereInput
    none?: AttendanceSummaryWhereInput
  }

  export type GradeEntryListRelationFilter = {
    every?: GradeEntryWhereInput
    some?: GradeEntryWhereInput
    none?: GradeEntryWhereInput
  }

  export type GradeReportListRelationFilter = {
    every?: GradeReportWhereInput
    some?: GradeReportWhereInput
    none?: GradeReportWhereInput
  }

  export type StudentRegistrationRequestListRelationFilter = {
    every?: StudentRegistrationRequestWhereInput
    some?: StudentRegistrationRequestWhereInput
    none?: StudentRegistrationRequestWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnnouncementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentPermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherSubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentEnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceSummaryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GradeEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GradeReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentRegistrationRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserSessionCountOrderByAggregateInput = {
    sessionId?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSessionMaxOrderByAggregateInput = {
    sessionId?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSessionMinOrderByAggregateInput = {
    sessionId?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type SemesterListRelationFilter = {
    every?: SemesterWhereInput
    some?: SemesterWhereInput
    none?: SemesterWhereInput
  }

  export type ClassListRelationFilter = {
    every?: ClassWhereInput
    some?: ClassWhereInput
    none?: ClassWhereInput
  }

  export type SemesterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AcademicYearCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCurrent?: SortOrder
    createdBy?: SortOrder
  }

  export type AcademicYearMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCurrent?: SortOrder
    createdBy?: SortOrder
  }

  export type AcademicYearMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCurrent?: SortOrder
    createdBy?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type AcademicYearScalarRelationFilter = {
    is?: AcademicYearWhereInput
    isNot?: AcademicYearWhereInput
  }

  export type SemesterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    academicYearId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCurrent?: SortOrder
    registrationOpen?: SortOrder
    minAverage?: SortOrder
    noFailedSubjects?: SortOrder
  }

  export type SemesterAvgOrderByAggregateInput = {
    minAverage?: SortOrder
  }

  export type SemesterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    academicYearId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCurrent?: SortOrder
    registrationOpen?: SortOrder
    minAverage?: SortOrder
    noFailedSubjects?: SortOrder
  }

  export type SemesterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    academicYearId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCurrent?: SortOrder
    registrationOpen?: SortOrder
    minAverage?: SortOrder
    noFailedSubjects?: SortOrder
  }

  export type SemesterSumOrderByAggregateInput = {
    minAverage?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type GradeScalarRelationFilter = {
    is?: GradeWhereInput
    isNot?: GradeWhereInput
  }

  export type ClassSectionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    gradeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassSectionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    gradeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassSectionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    gradeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ClassSectionListRelationFilter = {
    every?: ClassSectionWhereInput
    some?: ClassSectionWhereInput
    none?: ClassSectionWhereInput
  }

  export type SubjectListRelationFilter = {
    every?: SubjectWhereInput
    some?: SubjectWhereInput
    none?: SubjectWhereInput
  }

  export type ClassSectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GradeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
  }

  export type GradeAvgOrderByAggregateInput = {
    level?: SortOrder
  }

  export type GradeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
  }

  export type GradeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
  }

  export type GradeSumOrderByAggregateInput = {
    level?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type GradeCategoryListRelationFilter = {
    every?: GradeCategoryWhereInput
    some?: GradeCategoryWhereInput
    none?: GradeCategoryWhereInput
  }

  export type GradeCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    gradeId?: SortOrder
  }

  export type SubjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    gradeId?: SortOrder
  }

  export type SubjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    gradeId?: SortOrder
  }

  export type ClassSectionScalarRelationFilter = {
    is?: ClassSectionWhereInput
    isNot?: ClassSectionWhereInput
  }

  export type ClassCountOrderByAggregateInput = {
    id?: SortOrder
    gradeId?: SortOrder
    classSectionId?: SortOrder
    academicYearId?: SortOrder
  }

  export type ClassMaxOrderByAggregateInput = {
    id?: SortOrder
    gradeId?: SortOrder
    classSectionId?: SortOrder
    academicYearId?: SortOrder
  }

  export type ClassMinOrderByAggregateInput = {
    id?: SortOrder
    gradeId?: SortOrder
    classSectionId?: SortOrder
    academicYearId?: SortOrder
  }

  export type SubjectScalarRelationFilter = {
    is?: SubjectWhereInput
    isNot?: SubjectWhereInput
  }

  export type ClassScalarRelationFilter = {
    is?: ClassWhereInput
    isNot?: ClassWhereInput
  }

  export type TeacherSubjectCountOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    classId?: SortOrder
    academicYearId?: SortOrder
  }

  export type TeacherSubjectMaxOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    classId?: SortOrder
    academicYearId?: SortOrder
  }

  export type TeacherSubjectMinOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    classId?: SortOrder
    academicYearId?: SortOrder
  }

  export type SemesterNullableScalarRelationFilter = {
    is?: SemesterWhereInput | null
    isNot?: SemesterWhereInput | null
  }

  export type StudentEnrollmentStudentIdClassIdAcademicYearIdSemesterIdCompoundUniqueInput = {
    studentId: string
    classId: string
    academicYearId: string
    semesterId: string
  }

  export type StudentEnrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    academicYearId?: SortOrder
    semesterId?: SortOrder
    enrollmentDate?: SortOrder
  }

  export type StudentEnrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    academicYearId?: SortOrder
    semesterId?: SortOrder
    enrollmentDate?: SortOrder
  }

  export type StudentEnrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    academicYearId?: SortOrder
    semesterId?: SortOrder
    enrollmentDate?: SortOrder
  }

  export type ClassScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    teacherId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
  }

  export type ClassScheduleAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type ClassScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    teacherId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
  }

  export type ClassScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    teacherId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
  }

  export type ClassScheduleSumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type AttendanceRecordCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    date?: SortOrder
    period?: SortOrder
    status?: SortOrder
    markedById?: SortOrder
    markedAt?: SortOrder
    remarks?: SortOrder
  }

  export type AttendanceRecordAvgOrderByAggregateInput = {
    period?: SortOrder
  }

  export type AttendanceRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    date?: SortOrder
    period?: SortOrder
    status?: SortOrder
    markedById?: SortOrder
    markedAt?: SortOrder
    remarks?: SortOrder
  }

  export type AttendanceRecordMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    date?: SortOrder
    period?: SortOrder
    status?: SortOrder
    markedById?: SortOrder
    markedAt?: SortOrder
    remarks?: SortOrder
  }

  export type AttendanceRecordSumOrderByAggregateInput = {
    period?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type SemesterScalarRelationFilter = {
    is?: SemesterWhereInput
    isNot?: SemesterWhereInput
  }

  export type AttendanceSummaryCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    semesterId?: SortOrder
    totalClasses?: SortOrder
    presentCount?: SortOrder
    absentCount?: SortOrder
    lateCount?: SortOrder
  }

  export type AttendanceSummaryAvgOrderByAggregateInput = {
    totalClasses?: SortOrder
    presentCount?: SortOrder
    absentCount?: SortOrder
    lateCount?: SortOrder
  }

  export type AttendanceSummaryMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    semesterId?: SortOrder
    totalClasses?: SortOrder
    presentCount?: SortOrder
    absentCount?: SortOrder
    lateCount?: SortOrder
  }

  export type AttendanceSummaryMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    semesterId?: SortOrder
    totalClasses?: SortOrder
    presentCount?: SortOrder
    absentCount?: SortOrder
    lateCount?: SortOrder
  }

  export type AttendanceSummarySumOrderByAggregateInput = {
    totalClasses?: SortOrder
    presentCount?: SortOrder
    absentCount?: SortOrder
    lateCount?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type GradeCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    weight?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
  }

  export type GradeCategoryAvgOrderByAggregateInput = {
    weight?: SortOrder
  }

  export type GradeCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    weight?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
  }

  export type GradeCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    weight?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
  }

  export type GradeCategorySumOrderByAggregateInput = {
    weight?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type GradeCategoryScalarRelationFilter = {
    is?: GradeCategoryWhereInput
    isNot?: GradeCategoryWhereInput
  }

  export type GradeEntryCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    categoryId?: SortOrder
    classId?: SortOrder
    academicYearId?: SortOrder
    pointsEarned?: SortOrder
    totalPoints?: SortOrder
    date?: SortOrder
    semesterId?: SortOrder
    createdById?: SortOrder
  }

  export type GradeEntryAvgOrderByAggregateInput = {
    pointsEarned?: SortOrder
    totalPoints?: SortOrder
  }

  export type GradeEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    categoryId?: SortOrder
    classId?: SortOrder
    academicYearId?: SortOrder
    pointsEarned?: SortOrder
    totalPoints?: SortOrder
    date?: SortOrder
    semesterId?: SortOrder
    createdById?: SortOrder
  }

  export type GradeEntryMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    categoryId?: SortOrder
    classId?: SortOrder
    academicYearId?: SortOrder
    pointsEarned?: SortOrder
    totalPoints?: SortOrder
    date?: SortOrder
    semesterId?: SortOrder
    createdById?: SortOrder
  }

  export type GradeEntrySumOrderByAggregateInput = {
    pointsEarned?: SortOrder
    totalPoints?: SortOrder
  }

  export type GradeReportCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    semesterId?: SortOrder
    overallGpa?: SortOrder
    generatedAt?: SortOrder
  }

  export type GradeReportAvgOrderByAggregateInput = {
    overallGpa?: SortOrder
  }

  export type GradeReportMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    semesterId?: SortOrder
    overallGpa?: SortOrder
    generatedAt?: SortOrder
  }

  export type GradeReportMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    semesterId?: SortOrder
    overallGpa?: SortOrder
    generatedAt?: SortOrder
  }

  export type GradeReportSumOrderByAggregateInput = {
    overallGpa?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AnnouncementCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    targetRoles?: SortOrder
    targetClasses?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type AnnouncementMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type AnnouncementMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type MessageNullableScalarRelationFilter = {
    is?: MessageWhereInput | null
    isNot?: MessageWhereInput | null
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    sentAt?: SortOrder
    parentMessageId?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    sentAt?: SortOrder
    parentMessageId?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    recipientId?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    sentAt?: SortOrder
    parentMessageId?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type ClassNullableScalarRelationFilter = {
    is?: ClassWhereInput | null
    isNot?: ClassWhereInput | null
  }

  export type SubjectNullableScalarRelationFilter = {
    is?: SubjectWhereInput | null
    isNot?: SubjectWhereInput | null
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedById?: SortOrder
    category?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    uploadedAt?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedById?: SortOrder
    category?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    uploadedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedById?: SortOrder
    category?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    uploadedAt?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type DocumentScalarRelationFilter = {
    is?: DocumentWhereInput
    isNot?: DocumentWhereInput
  }

  export type DocumentPermissionCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    userId?: SortOrder
    permissionType?: SortOrder
  }

  export type DocumentPermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    userId?: SortOrder
    permissionType?: SortOrder
  }

  export type DocumentPermissionMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    userId?: SortOrder
    permissionType?: SortOrder
  }

  export type ExamCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subjectId?: SortOrder
    classId?: SortOrder
    type?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    maxScore?: SortOrder
    status?: SortOrder
    instructions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamAvgOrderByAggregateInput = {
    duration?: SortOrder
    maxScore?: SortOrder
  }

  export type ExamMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subjectId?: SortOrder
    classId?: SortOrder
    type?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    maxScore?: SortOrder
    status?: SortOrder
    instructions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subjectId?: SortOrder
    classId?: SortOrder
    type?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    maxScore?: SortOrder
    status?: SortOrder
    instructions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamSumOrderByAggregateInput = {
    duration?: SortOrder
    maxScore?: SortOrder
  }

  export type StudentRegistrationRequestCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    semesterId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrder
    adminId?: SortOrder
  }

  export type StudentRegistrationRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    semesterId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrder
    adminId?: SortOrder
  }

  export type StudentRegistrationRequestMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    semesterId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrder
    adminId?: SortOrder
  }

  export type UserSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type AnnouncementCreateNestedManyWithoutAuthorInput = {
    create?: XOR<AnnouncementCreateWithoutAuthorInput, AnnouncementUncheckedCreateWithoutAuthorInput> | AnnouncementCreateWithoutAuthorInput[] | AnnouncementUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutAuthorInput | AnnouncementCreateOrConnectWithoutAuthorInput[]
    createMany?: AnnouncementCreateManyAuthorInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutRecipientInput = {
    create?: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput> | MessageCreateWithoutRecipientInput[] | MessageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientInput | MessageCreateOrConnectWithoutRecipientInput[]
    createMany?: MessageCreateManyRecipientInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput> | DocumentCreateWithoutUploadedByInput[] | DocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploadedByInput | DocumentCreateOrConnectWithoutUploadedByInput[]
    createMany?: DocumentCreateManyUploadedByInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentPermissionCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentPermissionCreateWithoutUserInput, DocumentPermissionUncheckedCreateWithoutUserInput> | DocumentPermissionCreateWithoutUserInput[] | DocumentPermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentPermissionCreateOrConnectWithoutUserInput | DocumentPermissionCreateOrConnectWithoutUserInput[]
    createMany?: DocumentPermissionCreateManyUserInputEnvelope
    connect?: DocumentPermissionWhereUniqueInput | DocumentPermissionWhereUniqueInput[]
  }

  export type TeacherSubjectCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeacherSubjectCreateWithoutTeacherInput, TeacherSubjectUncheckedCreateWithoutTeacherInput> | TeacherSubjectCreateWithoutTeacherInput[] | TeacherSubjectUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutTeacherInput | TeacherSubjectCreateOrConnectWithoutTeacherInput[]
    createMany?: TeacherSubjectCreateManyTeacherInputEnvelope
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
  }

  export type StudentEnrollmentCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentEnrollmentCreateWithoutStudentInput, StudentEnrollmentUncheckedCreateWithoutStudentInput> | StudentEnrollmentCreateWithoutStudentInput[] | StudentEnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutStudentInput | StudentEnrollmentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentEnrollmentCreateManyStudentInputEnvelope
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
  }

  export type ClassScheduleCreateNestedManyWithoutTeacherInput = {
    create?: XOR<ClassScheduleCreateWithoutTeacherInput, ClassScheduleUncheckedCreateWithoutTeacherInput> | ClassScheduleCreateWithoutTeacherInput[] | ClassScheduleUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutTeacherInput | ClassScheduleCreateOrConnectWithoutTeacherInput[]
    createMany?: ClassScheduleCreateManyTeacherInputEnvelope
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
  }

  export type AttendanceRecordCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendanceRecordCreateWithoutStudentInput, AttendanceRecordUncheckedCreateWithoutStudentInput> | AttendanceRecordCreateWithoutStudentInput[] | AttendanceRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutStudentInput | AttendanceRecordCreateOrConnectWithoutStudentInput[]
    createMany?: AttendanceRecordCreateManyStudentInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type AttendanceRecordCreateNestedManyWithoutMarkedByInput = {
    create?: XOR<AttendanceRecordCreateWithoutMarkedByInput, AttendanceRecordUncheckedCreateWithoutMarkedByInput> | AttendanceRecordCreateWithoutMarkedByInput[] | AttendanceRecordUncheckedCreateWithoutMarkedByInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutMarkedByInput | AttendanceRecordCreateOrConnectWithoutMarkedByInput[]
    createMany?: AttendanceRecordCreateManyMarkedByInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type AttendanceSummaryCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendanceSummaryCreateWithoutStudentInput, AttendanceSummaryUncheckedCreateWithoutStudentInput> | AttendanceSummaryCreateWithoutStudentInput[] | AttendanceSummaryUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutStudentInput | AttendanceSummaryCreateOrConnectWithoutStudentInput[]
    createMany?: AttendanceSummaryCreateManyStudentInputEnvelope
    connect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
  }

  export type GradeEntryCreateNestedManyWithoutStudentInput = {
    create?: XOR<GradeEntryCreateWithoutStudentInput, GradeEntryUncheckedCreateWithoutStudentInput> | GradeEntryCreateWithoutStudentInput[] | GradeEntryUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: GradeEntryCreateOrConnectWithoutStudentInput | GradeEntryCreateOrConnectWithoutStudentInput[]
    createMany?: GradeEntryCreateManyStudentInputEnvelope
    connect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
  }

  export type GradeEntryCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<GradeEntryCreateWithoutCreatedByInput, GradeEntryUncheckedCreateWithoutCreatedByInput> | GradeEntryCreateWithoutCreatedByInput[] | GradeEntryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: GradeEntryCreateOrConnectWithoutCreatedByInput | GradeEntryCreateOrConnectWithoutCreatedByInput[]
    createMany?: GradeEntryCreateManyCreatedByInputEnvelope
    connect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
  }

  export type GradeReportCreateNestedManyWithoutStudentInput = {
    create?: XOR<GradeReportCreateWithoutStudentInput, GradeReportUncheckedCreateWithoutStudentInput> | GradeReportCreateWithoutStudentInput[] | GradeReportUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: GradeReportCreateOrConnectWithoutStudentInput | GradeReportCreateOrConnectWithoutStudentInput[]
    createMany?: GradeReportCreateManyStudentInputEnvelope
    connect?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
  }

  export type StudentRegistrationRequestCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentRegistrationRequestCreateWithoutStudentInput, StudentRegistrationRequestUncheckedCreateWithoutStudentInput> | StudentRegistrationRequestCreateWithoutStudentInput[] | StudentRegistrationRequestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentRegistrationRequestCreateOrConnectWithoutStudentInput | StudentRegistrationRequestCreateOrConnectWithoutStudentInput[]
    createMany?: StudentRegistrationRequestCreateManyStudentInputEnvelope
    connect?: StudentRegistrationRequestWhereUniqueInput | StudentRegistrationRequestWhereUniqueInput[]
  }

  export type UserSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type AnnouncementUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<AnnouncementCreateWithoutAuthorInput, AnnouncementUncheckedCreateWithoutAuthorInput> | AnnouncementCreateWithoutAuthorInput[] | AnnouncementUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutAuthorInput | AnnouncementCreateOrConnectWithoutAuthorInput[]
    createMany?: AnnouncementCreateManyAuthorInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutRecipientInput = {
    create?: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput> | MessageCreateWithoutRecipientInput[] | MessageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientInput | MessageCreateOrConnectWithoutRecipientInput[]
    createMany?: MessageCreateManyRecipientInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput> | DocumentCreateWithoutUploadedByInput[] | DocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploadedByInput | DocumentCreateOrConnectWithoutUploadedByInput[]
    createMany?: DocumentCreateManyUploadedByInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentPermissionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentPermissionCreateWithoutUserInput, DocumentPermissionUncheckedCreateWithoutUserInput> | DocumentPermissionCreateWithoutUserInput[] | DocumentPermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentPermissionCreateOrConnectWithoutUserInput | DocumentPermissionCreateOrConnectWithoutUserInput[]
    createMany?: DocumentPermissionCreateManyUserInputEnvelope
    connect?: DocumentPermissionWhereUniqueInput | DocumentPermissionWhereUniqueInput[]
  }

  export type TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeacherSubjectCreateWithoutTeacherInput, TeacherSubjectUncheckedCreateWithoutTeacherInput> | TeacherSubjectCreateWithoutTeacherInput[] | TeacherSubjectUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutTeacherInput | TeacherSubjectCreateOrConnectWithoutTeacherInput[]
    createMany?: TeacherSubjectCreateManyTeacherInputEnvelope
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
  }

  export type StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentEnrollmentCreateWithoutStudentInput, StudentEnrollmentUncheckedCreateWithoutStudentInput> | StudentEnrollmentCreateWithoutStudentInput[] | StudentEnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutStudentInput | StudentEnrollmentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentEnrollmentCreateManyStudentInputEnvelope
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
  }

  export type ClassScheduleUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<ClassScheduleCreateWithoutTeacherInput, ClassScheduleUncheckedCreateWithoutTeacherInput> | ClassScheduleCreateWithoutTeacherInput[] | ClassScheduleUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutTeacherInput | ClassScheduleCreateOrConnectWithoutTeacherInput[]
    createMany?: ClassScheduleCreateManyTeacherInputEnvelope
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
  }

  export type AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendanceRecordCreateWithoutStudentInput, AttendanceRecordUncheckedCreateWithoutStudentInput> | AttendanceRecordCreateWithoutStudentInput[] | AttendanceRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutStudentInput | AttendanceRecordCreateOrConnectWithoutStudentInput[]
    createMany?: AttendanceRecordCreateManyStudentInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type AttendanceRecordUncheckedCreateNestedManyWithoutMarkedByInput = {
    create?: XOR<AttendanceRecordCreateWithoutMarkedByInput, AttendanceRecordUncheckedCreateWithoutMarkedByInput> | AttendanceRecordCreateWithoutMarkedByInput[] | AttendanceRecordUncheckedCreateWithoutMarkedByInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutMarkedByInput | AttendanceRecordCreateOrConnectWithoutMarkedByInput[]
    createMany?: AttendanceRecordCreateManyMarkedByInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type AttendanceSummaryUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendanceSummaryCreateWithoutStudentInput, AttendanceSummaryUncheckedCreateWithoutStudentInput> | AttendanceSummaryCreateWithoutStudentInput[] | AttendanceSummaryUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutStudentInput | AttendanceSummaryCreateOrConnectWithoutStudentInput[]
    createMany?: AttendanceSummaryCreateManyStudentInputEnvelope
    connect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
  }

  export type GradeEntryUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<GradeEntryCreateWithoutStudentInput, GradeEntryUncheckedCreateWithoutStudentInput> | GradeEntryCreateWithoutStudentInput[] | GradeEntryUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: GradeEntryCreateOrConnectWithoutStudentInput | GradeEntryCreateOrConnectWithoutStudentInput[]
    createMany?: GradeEntryCreateManyStudentInputEnvelope
    connect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
  }

  export type GradeEntryUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<GradeEntryCreateWithoutCreatedByInput, GradeEntryUncheckedCreateWithoutCreatedByInput> | GradeEntryCreateWithoutCreatedByInput[] | GradeEntryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: GradeEntryCreateOrConnectWithoutCreatedByInput | GradeEntryCreateOrConnectWithoutCreatedByInput[]
    createMany?: GradeEntryCreateManyCreatedByInputEnvelope
    connect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
  }

  export type GradeReportUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<GradeReportCreateWithoutStudentInput, GradeReportUncheckedCreateWithoutStudentInput> | GradeReportCreateWithoutStudentInput[] | GradeReportUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: GradeReportCreateOrConnectWithoutStudentInput | GradeReportCreateOrConnectWithoutStudentInput[]
    createMany?: GradeReportCreateManyStudentInputEnvelope
    connect?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
  }

  export type StudentRegistrationRequestUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentRegistrationRequestCreateWithoutStudentInput, StudentRegistrationRequestUncheckedCreateWithoutStudentInput> | StudentRegistrationRequestCreateWithoutStudentInput[] | StudentRegistrationRequestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentRegistrationRequestCreateOrConnectWithoutStudentInput | StudentRegistrationRequestCreateOrConnectWithoutStudentInput[]
    createMany?: StudentRegistrationRequestCreateManyStudentInputEnvelope
    connect?: StudentRegistrationRequestWhereUniqueInput | StudentRegistrationRequestWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type AnnouncementUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<AnnouncementCreateWithoutAuthorInput, AnnouncementUncheckedCreateWithoutAuthorInput> | AnnouncementCreateWithoutAuthorInput[] | AnnouncementUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutAuthorInput | AnnouncementCreateOrConnectWithoutAuthorInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutAuthorInput | AnnouncementUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: AnnouncementCreateManyAuthorInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutAuthorInput | AnnouncementUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutAuthorInput | AnnouncementUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput> | MessageCreateWithoutRecipientInput[] | MessageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientInput | MessageCreateOrConnectWithoutRecipientInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutRecipientInput | MessageUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: MessageCreateManyRecipientInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutRecipientInput | MessageUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutRecipientInput | MessageUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput> | DocumentCreateWithoutUploadedByInput[] | DocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploadedByInput | DocumentCreateOrConnectWithoutUploadedByInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUploadedByInput | DocumentUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: DocumentCreateManyUploadedByInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUploadedByInput | DocumentUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUploadedByInput | DocumentUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentPermissionUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentPermissionCreateWithoutUserInput, DocumentPermissionUncheckedCreateWithoutUserInput> | DocumentPermissionCreateWithoutUserInput[] | DocumentPermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentPermissionCreateOrConnectWithoutUserInput | DocumentPermissionCreateOrConnectWithoutUserInput[]
    upsert?: DocumentPermissionUpsertWithWhereUniqueWithoutUserInput | DocumentPermissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentPermissionCreateManyUserInputEnvelope
    set?: DocumentPermissionWhereUniqueInput | DocumentPermissionWhereUniqueInput[]
    disconnect?: DocumentPermissionWhereUniqueInput | DocumentPermissionWhereUniqueInput[]
    delete?: DocumentPermissionWhereUniqueInput | DocumentPermissionWhereUniqueInput[]
    connect?: DocumentPermissionWhereUniqueInput | DocumentPermissionWhereUniqueInput[]
    update?: DocumentPermissionUpdateWithWhereUniqueWithoutUserInput | DocumentPermissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentPermissionUpdateManyWithWhereWithoutUserInput | DocumentPermissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentPermissionScalarWhereInput | DocumentPermissionScalarWhereInput[]
  }

  export type TeacherSubjectUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeacherSubjectCreateWithoutTeacherInput, TeacherSubjectUncheckedCreateWithoutTeacherInput> | TeacherSubjectCreateWithoutTeacherInput[] | TeacherSubjectUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutTeacherInput | TeacherSubjectCreateOrConnectWithoutTeacherInput[]
    upsert?: TeacherSubjectUpsertWithWhereUniqueWithoutTeacherInput | TeacherSubjectUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeacherSubjectCreateManyTeacherInputEnvelope
    set?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    disconnect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    delete?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    update?: TeacherSubjectUpdateWithWhereUniqueWithoutTeacherInput | TeacherSubjectUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeacherSubjectUpdateManyWithWhereWithoutTeacherInput | TeacherSubjectUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeacherSubjectScalarWhereInput | TeacherSubjectScalarWhereInput[]
  }

  export type StudentEnrollmentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentEnrollmentCreateWithoutStudentInput, StudentEnrollmentUncheckedCreateWithoutStudentInput> | StudentEnrollmentCreateWithoutStudentInput[] | StudentEnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutStudentInput | StudentEnrollmentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentEnrollmentUpsertWithWhereUniqueWithoutStudentInput | StudentEnrollmentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentEnrollmentCreateManyStudentInputEnvelope
    set?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    disconnect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    delete?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    update?: StudentEnrollmentUpdateWithWhereUniqueWithoutStudentInput | StudentEnrollmentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentEnrollmentUpdateManyWithWhereWithoutStudentInput | StudentEnrollmentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentEnrollmentScalarWhereInput | StudentEnrollmentScalarWhereInput[]
  }

  export type ClassScheduleUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<ClassScheduleCreateWithoutTeacherInput, ClassScheduleUncheckedCreateWithoutTeacherInput> | ClassScheduleCreateWithoutTeacherInput[] | ClassScheduleUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutTeacherInput | ClassScheduleCreateOrConnectWithoutTeacherInput[]
    upsert?: ClassScheduleUpsertWithWhereUniqueWithoutTeacherInput | ClassScheduleUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: ClassScheduleCreateManyTeacherInputEnvelope
    set?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    disconnect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    delete?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    update?: ClassScheduleUpdateWithWhereUniqueWithoutTeacherInput | ClassScheduleUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: ClassScheduleUpdateManyWithWhereWithoutTeacherInput | ClassScheduleUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: ClassScheduleScalarWhereInput | ClassScheduleScalarWhereInput[]
  }

  export type AttendanceRecordUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutStudentInput, AttendanceRecordUncheckedCreateWithoutStudentInput> | AttendanceRecordCreateWithoutStudentInput[] | AttendanceRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutStudentInput | AttendanceRecordCreateOrConnectWithoutStudentInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutStudentInput | AttendanceRecordUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendanceRecordCreateManyStudentInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutStudentInput | AttendanceRecordUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutStudentInput | AttendanceRecordUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type AttendanceRecordUpdateManyWithoutMarkedByNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutMarkedByInput, AttendanceRecordUncheckedCreateWithoutMarkedByInput> | AttendanceRecordCreateWithoutMarkedByInput[] | AttendanceRecordUncheckedCreateWithoutMarkedByInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutMarkedByInput | AttendanceRecordCreateOrConnectWithoutMarkedByInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutMarkedByInput | AttendanceRecordUpsertWithWhereUniqueWithoutMarkedByInput[]
    createMany?: AttendanceRecordCreateManyMarkedByInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutMarkedByInput | AttendanceRecordUpdateWithWhereUniqueWithoutMarkedByInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutMarkedByInput | AttendanceRecordUpdateManyWithWhereWithoutMarkedByInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type AttendanceSummaryUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendanceSummaryCreateWithoutStudentInput, AttendanceSummaryUncheckedCreateWithoutStudentInput> | AttendanceSummaryCreateWithoutStudentInput[] | AttendanceSummaryUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutStudentInput | AttendanceSummaryCreateOrConnectWithoutStudentInput[]
    upsert?: AttendanceSummaryUpsertWithWhereUniqueWithoutStudentInput | AttendanceSummaryUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendanceSummaryCreateManyStudentInputEnvelope
    set?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    disconnect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    delete?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    connect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    update?: AttendanceSummaryUpdateWithWhereUniqueWithoutStudentInput | AttendanceSummaryUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendanceSummaryUpdateManyWithWhereWithoutStudentInput | AttendanceSummaryUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendanceSummaryScalarWhereInput | AttendanceSummaryScalarWhereInput[]
  }

  export type GradeEntryUpdateManyWithoutStudentNestedInput = {
    create?: XOR<GradeEntryCreateWithoutStudentInput, GradeEntryUncheckedCreateWithoutStudentInput> | GradeEntryCreateWithoutStudentInput[] | GradeEntryUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: GradeEntryCreateOrConnectWithoutStudentInput | GradeEntryCreateOrConnectWithoutStudentInput[]
    upsert?: GradeEntryUpsertWithWhereUniqueWithoutStudentInput | GradeEntryUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: GradeEntryCreateManyStudentInputEnvelope
    set?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    disconnect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    delete?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    connect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    update?: GradeEntryUpdateWithWhereUniqueWithoutStudentInput | GradeEntryUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: GradeEntryUpdateManyWithWhereWithoutStudentInput | GradeEntryUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: GradeEntryScalarWhereInput | GradeEntryScalarWhereInput[]
  }

  export type GradeEntryUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<GradeEntryCreateWithoutCreatedByInput, GradeEntryUncheckedCreateWithoutCreatedByInput> | GradeEntryCreateWithoutCreatedByInput[] | GradeEntryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: GradeEntryCreateOrConnectWithoutCreatedByInput | GradeEntryCreateOrConnectWithoutCreatedByInput[]
    upsert?: GradeEntryUpsertWithWhereUniqueWithoutCreatedByInput | GradeEntryUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: GradeEntryCreateManyCreatedByInputEnvelope
    set?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    disconnect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    delete?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    connect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    update?: GradeEntryUpdateWithWhereUniqueWithoutCreatedByInput | GradeEntryUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: GradeEntryUpdateManyWithWhereWithoutCreatedByInput | GradeEntryUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: GradeEntryScalarWhereInput | GradeEntryScalarWhereInput[]
  }

  export type GradeReportUpdateManyWithoutStudentNestedInput = {
    create?: XOR<GradeReportCreateWithoutStudentInput, GradeReportUncheckedCreateWithoutStudentInput> | GradeReportCreateWithoutStudentInput[] | GradeReportUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: GradeReportCreateOrConnectWithoutStudentInput | GradeReportCreateOrConnectWithoutStudentInput[]
    upsert?: GradeReportUpsertWithWhereUniqueWithoutStudentInput | GradeReportUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: GradeReportCreateManyStudentInputEnvelope
    set?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    disconnect?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    delete?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    connect?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    update?: GradeReportUpdateWithWhereUniqueWithoutStudentInput | GradeReportUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: GradeReportUpdateManyWithWhereWithoutStudentInput | GradeReportUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: GradeReportScalarWhereInput | GradeReportScalarWhereInput[]
  }

  export type StudentRegistrationRequestUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentRegistrationRequestCreateWithoutStudentInput, StudentRegistrationRequestUncheckedCreateWithoutStudentInput> | StudentRegistrationRequestCreateWithoutStudentInput[] | StudentRegistrationRequestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentRegistrationRequestCreateOrConnectWithoutStudentInput | StudentRegistrationRequestCreateOrConnectWithoutStudentInput[]
    upsert?: StudentRegistrationRequestUpsertWithWhereUniqueWithoutStudentInput | StudentRegistrationRequestUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentRegistrationRequestCreateManyStudentInputEnvelope
    set?: StudentRegistrationRequestWhereUniqueInput | StudentRegistrationRequestWhereUniqueInput[]
    disconnect?: StudentRegistrationRequestWhereUniqueInput | StudentRegistrationRequestWhereUniqueInput[]
    delete?: StudentRegistrationRequestWhereUniqueInput | StudentRegistrationRequestWhereUniqueInput[]
    connect?: StudentRegistrationRequestWhereUniqueInput | StudentRegistrationRequestWhereUniqueInput[]
    update?: StudentRegistrationRequestUpdateWithWhereUniqueWithoutStudentInput | StudentRegistrationRequestUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentRegistrationRequestUpdateManyWithWhereWithoutStudentInput | StudentRegistrationRequestUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentRegistrationRequestScalarWhereInput | StudentRegistrationRequestScalarWhereInput[]
  }

  export type UserSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<AnnouncementCreateWithoutAuthorInput, AnnouncementUncheckedCreateWithoutAuthorInput> | AnnouncementCreateWithoutAuthorInput[] | AnnouncementUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutAuthorInput | AnnouncementCreateOrConnectWithoutAuthorInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutAuthorInput | AnnouncementUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: AnnouncementCreateManyAuthorInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutAuthorInput | AnnouncementUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutAuthorInput | AnnouncementUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput> | MessageCreateWithoutRecipientInput[] | MessageUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientInput | MessageCreateOrConnectWithoutRecipientInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutRecipientInput | MessageUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: MessageCreateManyRecipientInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutRecipientInput | MessageUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutRecipientInput | MessageUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput> | DocumentCreateWithoutUploadedByInput[] | DocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploadedByInput | DocumentCreateOrConnectWithoutUploadedByInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUploadedByInput | DocumentUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: DocumentCreateManyUploadedByInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUploadedByInput | DocumentUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUploadedByInput | DocumentUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentPermissionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentPermissionCreateWithoutUserInput, DocumentPermissionUncheckedCreateWithoutUserInput> | DocumentPermissionCreateWithoutUserInput[] | DocumentPermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentPermissionCreateOrConnectWithoutUserInput | DocumentPermissionCreateOrConnectWithoutUserInput[]
    upsert?: DocumentPermissionUpsertWithWhereUniqueWithoutUserInput | DocumentPermissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentPermissionCreateManyUserInputEnvelope
    set?: DocumentPermissionWhereUniqueInput | DocumentPermissionWhereUniqueInput[]
    disconnect?: DocumentPermissionWhereUniqueInput | DocumentPermissionWhereUniqueInput[]
    delete?: DocumentPermissionWhereUniqueInput | DocumentPermissionWhereUniqueInput[]
    connect?: DocumentPermissionWhereUniqueInput | DocumentPermissionWhereUniqueInput[]
    update?: DocumentPermissionUpdateWithWhereUniqueWithoutUserInput | DocumentPermissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentPermissionUpdateManyWithWhereWithoutUserInput | DocumentPermissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentPermissionScalarWhereInput | DocumentPermissionScalarWhereInput[]
  }

  export type TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeacherSubjectCreateWithoutTeacherInput, TeacherSubjectUncheckedCreateWithoutTeacherInput> | TeacherSubjectCreateWithoutTeacherInput[] | TeacherSubjectUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutTeacherInput | TeacherSubjectCreateOrConnectWithoutTeacherInput[]
    upsert?: TeacherSubjectUpsertWithWhereUniqueWithoutTeacherInput | TeacherSubjectUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeacherSubjectCreateManyTeacherInputEnvelope
    set?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    disconnect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    delete?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    update?: TeacherSubjectUpdateWithWhereUniqueWithoutTeacherInput | TeacherSubjectUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeacherSubjectUpdateManyWithWhereWithoutTeacherInput | TeacherSubjectUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeacherSubjectScalarWhereInput | TeacherSubjectScalarWhereInput[]
  }

  export type StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentEnrollmentCreateWithoutStudentInput, StudentEnrollmentUncheckedCreateWithoutStudentInput> | StudentEnrollmentCreateWithoutStudentInput[] | StudentEnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutStudentInput | StudentEnrollmentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentEnrollmentUpsertWithWhereUniqueWithoutStudentInput | StudentEnrollmentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentEnrollmentCreateManyStudentInputEnvelope
    set?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    disconnect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    delete?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    update?: StudentEnrollmentUpdateWithWhereUniqueWithoutStudentInput | StudentEnrollmentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentEnrollmentUpdateManyWithWhereWithoutStudentInput | StudentEnrollmentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentEnrollmentScalarWhereInput | StudentEnrollmentScalarWhereInput[]
  }

  export type ClassScheduleUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<ClassScheduleCreateWithoutTeacherInput, ClassScheduleUncheckedCreateWithoutTeacherInput> | ClassScheduleCreateWithoutTeacherInput[] | ClassScheduleUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutTeacherInput | ClassScheduleCreateOrConnectWithoutTeacherInput[]
    upsert?: ClassScheduleUpsertWithWhereUniqueWithoutTeacherInput | ClassScheduleUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: ClassScheduleCreateManyTeacherInputEnvelope
    set?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    disconnect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    delete?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    update?: ClassScheduleUpdateWithWhereUniqueWithoutTeacherInput | ClassScheduleUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: ClassScheduleUpdateManyWithWhereWithoutTeacherInput | ClassScheduleUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: ClassScheduleScalarWhereInput | ClassScheduleScalarWhereInput[]
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutStudentInput, AttendanceRecordUncheckedCreateWithoutStudentInput> | AttendanceRecordCreateWithoutStudentInput[] | AttendanceRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutStudentInput | AttendanceRecordCreateOrConnectWithoutStudentInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutStudentInput | AttendanceRecordUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendanceRecordCreateManyStudentInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutStudentInput | AttendanceRecordUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutStudentInput | AttendanceRecordUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutMarkedByNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutMarkedByInput, AttendanceRecordUncheckedCreateWithoutMarkedByInput> | AttendanceRecordCreateWithoutMarkedByInput[] | AttendanceRecordUncheckedCreateWithoutMarkedByInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutMarkedByInput | AttendanceRecordCreateOrConnectWithoutMarkedByInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutMarkedByInput | AttendanceRecordUpsertWithWhereUniqueWithoutMarkedByInput[]
    createMany?: AttendanceRecordCreateManyMarkedByInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutMarkedByInput | AttendanceRecordUpdateWithWhereUniqueWithoutMarkedByInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutMarkedByInput | AttendanceRecordUpdateManyWithWhereWithoutMarkedByInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type AttendanceSummaryUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendanceSummaryCreateWithoutStudentInput, AttendanceSummaryUncheckedCreateWithoutStudentInput> | AttendanceSummaryCreateWithoutStudentInput[] | AttendanceSummaryUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutStudentInput | AttendanceSummaryCreateOrConnectWithoutStudentInput[]
    upsert?: AttendanceSummaryUpsertWithWhereUniqueWithoutStudentInput | AttendanceSummaryUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendanceSummaryCreateManyStudentInputEnvelope
    set?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    disconnect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    delete?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    connect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    update?: AttendanceSummaryUpdateWithWhereUniqueWithoutStudentInput | AttendanceSummaryUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendanceSummaryUpdateManyWithWhereWithoutStudentInput | AttendanceSummaryUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendanceSummaryScalarWhereInput | AttendanceSummaryScalarWhereInput[]
  }

  export type GradeEntryUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<GradeEntryCreateWithoutStudentInput, GradeEntryUncheckedCreateWithoutStudentInput> | GradeEntryCreateWithoutStudentInput[] | GradeEntryUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: GradeEntryCreateOrConnectWithoutStudentInput | GradeEntryCreateOrConnectWithoutStudentInput[]
    upsert?: GradeEntryUpsertWithWhereUniqueWithoutStudentInput | GradeEntryUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: GradeEntryCreateManyStudentInputEnvelope
    set?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    disconnect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    delete?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    connect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    update?: GradeEntryUpdateWithWhereUniqueWithoutStudentInput | GradeEntryUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: GradeEntryUpdateManyWithWhereWithoutStudentInput | GradeEntryUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: GradeEntryScalarWhereInput | GradeEntryScalarWhereInput[]
  }

  export type GradeEntryUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<GradeEntryCreateWithoutCreatedByInput, GradeEntryUncheckedCreateWithoutCreatedByInput> | GradeEntryCreateWithoutCreatedByInput[] | GradeEntryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: GradeEntryCreateOrConnectWithoutCreatedByInput | GradeEntryCreateOrConnectWithoutCreatedByInput[]
    upsert?: GradeEntryUpsertWithWhereUniqueWithoutCreatedByInput | GradeEntryUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: GradeEntryCreateManyCreatedByInputEnvelope
    set?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    disconnect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    delete?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    connect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    update?: GradeEntryUpdateWithWhereUniqueWithoutCreatedByInput | GradeEntryUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: GradeEntryUpdateManyWithWhereWithoutCreatedByInput | GradeEntryUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: GradeEntryScalarWhereInput | GradeEntryScalarWhereInput[]
  }

  export type GradeReportUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<GradeReportCreateWithoutStudentInput, GradeReportUncheckedCreateWithoutStudentInput> | GradeReportCreateWithoutStudentInput[] | GradeReportUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: GradeReportCreateOrConnectWithoutStudentInput | GradeReportCreateOrConnectWithoutStudentInput[]
    upsert?: GradeReportUpsertWithWhereUniqueWithoutStudentInput | GradeReportUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: GradeReportCreateManyStudentInputEnvelope
    set?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    disconnect?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    delete?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    connect?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    update?: GradeReportUpdateWithWhereUniqueWithoutStudentInput | GradeReportUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: GradeReportUpdateManyWithWhereWithoutStudentInput | GradeReportUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: GradeReportScalarWhereInput | GradeReportScalarWhereInput[]
  }

  export type StudentRegistrationRequestUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentRegistrationRequestCreateWithoutStudentInput, StudentRegistrationRequestUncheckedCreateWithoutStudentInput> | StudentRegistrationRequestCreateWithoutStudentInput[] | StudentRegistrationRequestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentRegistrationRequestCreateOrConnectWithoutStudentInput | StudentRegistrationRequestCreateOrConnectWithoutStudentInput[]
    upsert?: StudentRegistrationRequestUpsertWithWhereUniqueWithoutStudentInput | StudentRegistrationRequestUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentRegistrationRequestCreateManyStudentInputEnvelope
    set?: StudentRegistrationRequestWhereUniqueInput | StudentRegistrationRequestWhereUniqueInput[]
    disconnect?: StudentRegistrationRequestWhereUniqueInput | StudentRegistrationRequestWhereUniqueInput[]
    delete?: StudentRegistrationRequestWhereUniqueInput | StudentRegistrationRequestWhereUniqueInput[]
    connect?: StudentRegistrationRequestWhereUniqueInput | StudentRegistrationRequestWhereUniqueInput[]
    update?: StudentRegistrationRequestUpdateWithWhereUniqueWithoutStudentInput | StudentRegistrationRequestUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentRegistrationRequestUpdateManyWithWhereWithoutStudentInput | StudentRegistrationRequestUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentRegistrationRequestScalarWhereInput | StudentRegistrationRequestScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type SemesterCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<SemesterCreateWithoutAcademicYearInput, SemesterUncheckedCreateWithoutAcademicYearInput> | SemesterCreateWithoutAcademicYearInput[] | SemesterUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: SemesterCreateOrConnectWithoutAcademicYearInput | SemesterCreateOrConnectWithoutAcademicYearInput[]
    createMany?: SemesterCreateManyAcademicYearInputEnvelope
    connect?: SemesterWhereUniqueInput | SemesterWhereUniqueInput[]
  }

  export type ClassCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<ClassCreateWithoutAcademicYearInput, ClassUncheckedCreateWithoutAcademicYearInput> | ClassCreateWithoutAcademicYearInput[] | ClassUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutAcademicYearInput | ClassCreateOrConnectWithoutAcademicYearInput[]
    createMany?: ClassCreateManyAcademicYearInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type TeacherSubjectCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<TeacherSubjectCreateWithoutAcademicYearInput, TeacherSubjectUncheckedCreateWithoutAcademicYearInput> | TeacherSubjectCreateWithoutAcademicYearInput[] | TeacherSubjectUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutAcademicYearInput | TeacherSubjectCreateOrConnectWithoutAcademicYearInput[]
    createMany?: TeacherSubjectCreateManyAcademicYearInputEnvelope
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
  }

  export type StudentEnrollmentCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<StudentEnrollmentCreateWithoutAcademicYearInput, StudentEnrollmentUncheckedCreateWithoutAcademicYearInput> | StudentEnrollmentCreateWithoutAcademicYearInput[] | StudentEnrollmentUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutAcademicYearInput | StudentEnrollmentCreateOrConnectWithoutAcademicYearInput[]
    createMany?: StudentEnrollmentCreateManyAcademicYearInputEnvelope
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
  }

  export type GradeEntryCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<GradeEntryCreateWithoutAcademicYearInput, GradeEntryUncheckedCreateWithoutAcademicYearInput> | GradeEntryCreateWithoutAcademicYearInput[] | GradeEntryUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: GradeEntryCreateOrConnectWithoutAcademicYearInput | GradeEntryCreateOrConnectWithoutAcademicYearInput[]
    createMany?: GradeEntryCreateManyAcademicYearInputEnvelope
    connect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
  }

  export type SemesterUncheckedCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<SemesterCreateWithoutAcademicYearInput, SemesterUncheckedCreateWithoutAcademicYearInput> | SemesterCreateWithoutAcademicYearInput[] | SemesterUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: SemesterCreateOrConnectWithoutAcademicYearInput | SemesterCreateOrConnectWithoutAcademicYearInput[]
    createMany?: SemesterCreateManyAcademicYearInputEnvelope
    connect?: SemesterWhereUniqueInput | SemesterWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<ClassCreateWithoutAcademicYearInput, ClassUncheckedCreateWithoutAcademicYearInput> | ClassCreateWithoutAcademicYearInput[] | ClassUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutAcademicYearInput | ClassCreateOrConnectWithoutAcademicYearInput[]
    createMany?: ClassCreateManyAcademicYearInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type TeacherSubjectUncheckedCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<TeacherSubjectCreateWithoutAcademicYearInput, TeacherSubjectUncheckedCreateWithoutAcademicYearInput> | TeacherSubjectCreateWithoutAcademicYearInput[] | TeacherSubjectUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutAcademicYearInput | TeacherSubjectCreateOrConnectWithoutAcademicYearInput[]
    createMany?: TeacherSubjectCreateManyAcademicYearInputEnvelope
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
  }

  export type StudentEnrollmentUncheckedCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<StudentEnrollmentCreateWithoutAcademicYearInput, StudentEnrollmentUncheckedCreateWithoutAcademicYearInput> | StudentEnrollmentCreateWithoutAcademicYearInput[] | StudentEnrollmentUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutAcademicYearInput | StudentEnrollmentCreateOrConnectWithoutAcademicYearInput[]
    createMany?: StudentEnrollmentCreateManyAcademicYearInputEnvelope
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
  }

  export type GradeEntryUncheckedCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<GradeEntryCreateWithoutAcademicYearInput, GradeEntryUncheckedCreateWithoutAcademicYearInput> | GradeEntryCreateWithoutAcademicYearInput[] | GradeEntryUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: GradeEntryCreateOrConnectWithoutAcademicYearInput | GradeEntryCreateOrConnectWithoutAcademicYearInput[]
    createMany?: GradeEntryCreateManyAcademicYearInputEnvelope
    connect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type SemesterUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<SemesterCreateWithoutAcademicYearInput, SemesterUncheckedCreateWithoutAcademicYearInput> | SemesterCreateWithoutAcademicYearInput[] | SemesterUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: SemesterCreateOrConnectWithoutAcademicYearInput | SemesterCreateOrConnectWithoutAcademicYearInput[]
    upsert?: SemesterUpsertWithWhereUniqueWithoutAcademicYearInput | SemesterUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: SemesterCreateManyAcademicYearInputEnvelope
    set?: SemesterWhereUniqueInput | SemesterWhereUniqueInput[]
    disconnect?: SemesterWhereUniqueInput | SemesterWhereUniqueInput[]
    delete?: SemesterWhereUniqueInput | SemesterWhereUniqueInput[]
    connect?: SemesterWhereUniqueInput | SemesterWhereUniqueInput[]
    update?: SemesterUpdateWithWhereUniqueWithoutAcademicYearInput | SemesterUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: SemesterUpdateManyWithWhereWithoutAcademicYearInput | SemesterUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: SemesterScalarWhereInput | SemesterScalarWhereInput[]
  }

  export type ClassUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<ClassCreateWithoutAcademicYearInput, ClassUncheckedCreateWithoutAcademicYearInput> | ClassCreateWithoutAcademicYearInput[] | ClassUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutAcademicYearInput | ClassCreateOrConnectWithoutAcademicYearInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutAcademicYearInput | ClassUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: ClassCreateManyAcademicYearInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutAcademicYearInput | ClassUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutAcademicYearInput | ClassUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type TeacherSubjectUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<TeacherSubjectCreateWithoutAcademicYearInput, TeacherSubjectUncheckedCreateWithoutAcademicYearInput> | TeacherSubjectCreateWithoutAcademicYearInput[] | TeacherSubjectUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutAcademicYearInput | TeacherSubjectCreateOrConnectWithoutAcademicYearInput[]
    upsert?: TeacherSubjectUpsertWithWhereUniqueWithoutAcademicYearInput | TeacherSubjectUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: TeacherSubjectCreateManyAcademicYearInputEnvelope
    set?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    disconnect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    delete?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    update?: TeacherSubjectUpdateWithWhereUniqueWithoutAcademicYearInput | TeacherSubjectUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: TeacherSubjectUpdateManyWithWhereWithoutAcademicYearInput | TeacherSubjectUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: TeacherSubjectScalarWhereInput | TeacherSubjectScalarWhereInput[]
  }

  export type StudentEnrollmentUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<StudentEnrollmentCreateWithoutAcademicYearInput, StudentEnrollmentUncheckedCreateWithoutAcademicYearInput> | StudentEnrollmentCreateWithoutAcademicYearInput[] | StudentEnrollmentUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutAcademicYearInput | StudentEnrollmentCreateOrConnectWithoutAcademicYearInput[]
    upsert?: StudentEnrollmentUpsertWithWhereUniqueWithoutAcademicYearInput | StudentEnrollmentUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: StudentEnrollmentCreateManyAcademicYearInputEnvelope
    set?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    disconnect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    delete?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    update?: StudentEnrollmentUpdateWithWhereUniqueWithoutAcademicYearInput | StudentEnrollmentUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: StudentEnrollmentUpdateManyWithWhereWithoutAcademicYearInput | StudentEnrollmentUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: StudentEnrollmentScalarWhereInput | StudentEnrollmentScalarWhereInput[]
  }

  export type GradeEntryUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<GradeEntryCreateWithoutAcademicYearInput, GradeEntryUncheckedCreateWithoutAcademicYearInput> | GradeEntryCreateWithoutAcademicYearInput[] | GradeEntryUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: GradeEntryCreateOrConnectWithoutAcademicYearInput | GradeEntryCreateOrConnectWithoutAcademicYearInput[]
    upsert?: GradeEntryUpsertWithWhereUniqueWithoutAcademicYearInput | GradeEntryUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: GradeEntryCreateManyAcademicYearInputEnvelope
    set?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    disconnect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    delete?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    connect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    update?: GradeEntryUpdateWithWhereUniqueWithoutAcademicYearInput | GradeEntryUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: GradeEntryUpdateManyWithWhereWithoutAcademicYearInput | GradeEntryUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: GradeEntryScalarWhereInput | GradeEntryScalarWhereInput[]
  }

  export type SemesterUncheckedUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<SemesterCreateWithoutAcademicYearInput, SemesterUncheckedCreateWithoutAcademicYearInput> | SemesterCreateWithoutAcademicYearInput[] | SemesterUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: SemesterCreateOrConnectWithoutAcademicYearInput | SemesterCreateOrConnectWithoutAcademicYearInput[]
    upsert?: SemesterUpsertWithWhereUniqueWithoutAcademicYearInput | SemesterUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: SemesterCreateManyAcademicYearInputEnvelope
    set?: SemesterWhereUniqueInput | SemesterWhereUniqueInput[]
    disconnect?: SemesterWhereUniqueInput | SemesterWhereUniqueInput[]
    delete?: SemesterWhereUniqueInput | SemesterWhereUniqueInput[]
    connect?: SemesterWhereUniqueInput | SemesterWhereUniqueInput[]
    update?: SemesterUpdateWithWhereUniqueWithoutAcademicYearInput | SemesterUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: SemesterUpdateManyWithWhereWithoutAcademicYearInput | SemesterUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: SemesterScalarWhereInput | SemesterScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<ClassCreateWithoutAcademicYearInput, ClassUncheckedCreateWithoutAcademicYearInput> | ClassCreateWithoutAcademicYearInput[] | ClassUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutAcademicYearInput | ClassCreateOrConnectWithoutAcademicYearInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutAcademicYearInput | ClassUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: ClassCreateManyAcademicYearInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutAcademicYearInput | ClassUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutAcademicYearInput | ClassUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type TeacherSubjectUncheckedUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<TeacherSubjectCreateWithoutAcademicYearInput, TeacherSubjectUncheckedCreateWithoutAcademicYearInput> | TeacherSubjectCreateWithoutAcademicYearInput[] | TeacherSubjectUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutAcademicYearInput | TeacherSubjectCreateOrConnectWithoutAcademicYearInput[]
    upsert?: TeacherSubjectUpsertWithWhereUniqueWithoutAcademicYearInput | TeacherSubjectUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: TeacherSubjectCreateManyAcademicYearInputEnvelope
    set?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    disconnect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    delete?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    update?: TeacherSubjectUpdateWithWhereUniqueWithoutAcademicYearInput | TeacherSubjectUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: TeacherSubjectUpdateManyWithWhereWithoutAcademicYearInput | TeacherSubjectUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: TeacherSubjectScalarWhereInput | TeacherSubjectScalarWhereInput[]
  }

  export type StudentEnrollmentUncheckedUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<StudentEnrollmentCreateWithoutAcademicYearInput, StudentEnrollmentUncheckedCreateWithoutAcademicYearInput> | StudentEnrollmentCreateWithoutAcademicYearInput[] | StudentEnrollmentUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutAcademicYearInput | StudentEnrollmentCreateOrConnectWithoutAcademicYearInput[]
    upsert?: StudentEnrollmentUpsertWithWhereUniqueWithoutAcademicYearInput | StudentEnrollmentUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: StudentEnrollmentCreateManyAcademicYearInputEnvelope
    set?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    disconnect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    delete?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    update?: StudentEnrollmentUpdateWithWhereUniqueWithoutAcademicYearInput | StudentEnrollmentUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: StudentEnrollmentUpdateManyWithWhereWithoutAcademicYearInput | StudentEnrollmentUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: StudentEnrollmentScalarWhereInput | StudentEnrollmentScalarWhereInput[]
  }

  export type GradeEntryUncheckedUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<GradeEntryCreateWithoutAcademicYearInput, GradeEntryUncheckedCreateWithoutAcademicYearInput> | GradeEntryCreateWithoutAcademicYearInput[] | GradeEntryUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: GradeEntryCreateOrConnectWithoutAcademicYearInput | GradeEntryCreateOrConnectWithoutAcademicYearInput[]
    upsert?: GradeEntryUpsertWithWhereUniqueWithoutAcademicYearInput | GradeEntryUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: GradeEntryCreateManyAcademicYearInputEnvelope
    set?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    disconnect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    delete?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    connect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    update?: GradeEntryUpdateWithWhereUniqueWithoutAcademicYearInput | GradeEntryUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: GradeEntryUpdateManyWithWhereWithoutAcademicYearInput | GradeEntryUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: GradeEntryScalarWhereInput | GradeEntryScalarWhereInput[]
  }

  export type AcademicYearCreateNestedOneWithoutSemestersInput = {
    create?: XOR<AcademicYearCreateWithoutSemestersInput, AcademicYearUncheckedCreateWithoutSemestersInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutSemestersInput
    connect?: AcademicYearWhereUniqueInput
  }

  export type AttendanceSummaryCreateNestedManyWithoutSemesterInput = {
    create?: XOR<AttendanceSummaryCreateWithoutSemesterInput, AttendanceSummaryUncheckedCreateWithoutSemesterInput> | AttendanceSummaryCreateWithoutSemesterInput[] | AttendanceSummaryUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutSemesterInput | AttendanceSummaryCreateOrConnectWithoutSemesterInput[]
    createMany?: AttendanceSummaryCreateManySemesterInputEnvelope
    connect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
  }

  export type GradeReportCreateNestedManyWithoutSemesterInput = {
    create?: XOR<GradeReportCreateWithoutSemesterInput, GradeReportUncheckedCreateWithoutSemesterInput> | GradeReportCreateWithoutSemesterInput[] | GradeReportUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: GradeReportCreateOrConnectWithoutSemesterInput | GradeReportCreateOrConnectWithoutSemesterInput[]
    createMany?: GradeReportCreateManySemesterInputEnvelope
    connect?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
  }

  export type GradeEntryCreateNestedManyWithoutSemesterInput = {
    create?: XOR<GradeEntryCreateWithoutSemesterInput, GradeEntryUncheckedCreateWithoutSemesterInput> | GradeEntryCreateWithoutSemesterInput[] | GradeEntryUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: GradeEntryCreateOrConnectWithoutSemesterInput | GradeEntryCreateOrConnectWithoutSemesterInput[]
    createMany?: GradeEntryCreateManySemesterInputEnvelope
    connect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
  }

  export type StudentEnrollmentCreateNestedManyWithoutSemesterInput = {
    create?: XOR<StudentEnrollmentCreateWithoutSemesterInput, StudentEnrollmentUncheckedCreateWithoutSemesterInput> | StudentEnrollmentCreateWithoutSemesterInput[] | StudentEnrollmentUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutSemesterInput | StudentEnrollmentCreateOrConnectWithoutSemesterInput[]
    createMany?: StudentEnrollmentCreateManySemesterInputEnvelope
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
  }

  export type StudentRegistrationRequestCreateNestedManyWithoutSemesterInput = {
    create?: XOR<StudentRegistrationRequestCreateWithoutSemesterInput, StudentRegistrationRequestUncheckedCreateWithoutSemesterInput> | StudentRegistrationRequestCreateWithoutSemesterInput[] | StudentRegistrationRequestUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: StudentRegistrationRequestCreateOrConnectWithoutSemesterInput | StudentRegistrationRequestCreateOrConnectWithoutSemesterInput[]
    createMany?: StudentRegistrationRequestCreateManySemesterInputEnvelope
    connect?: StudentRegistrationRequestWhereUniqueInput | StudentRegistrationRequestWhereUniqueInput[]
  }

  export type AttendanceSummaryUncheckedCreateNestedManyWithoutSemesterInput = {
    create?: XOR<AttendanceSummaryCreateWithoutSemesterInput, AttendanceSummaryUncheckedCreateWithoutSemesterInput> | AttendanceSummaryCreateWithoutSemesterInput[] | AttendanceSummaryUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutSemesterInput | AttendanceSummaryCreateOrConnectWithoutSemesterInput[]
    createMany?: AttendanceSummaryCreateManySemesterInputEnvelope
    connect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
  }

  export type GradeReportUncheckedCreateNestedManyWithoutSemesterInput = {
    create?: XOR<GradeReportCreateWithoutSemesterInput, GradeReportUncheckedCreateWithoutSemesterInput> | GradeReportCreateWithoutSemesterInput[] | GradeReportUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: GradeReportCreateOrConnectWithoutSemesterInput | GradeReportCreateOrConnectWithoutSemesterInput[]
    createMany?: GradeReportCreateManySemesterInputEnvelope
    connect?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
  }

  export type GradeEntryUncheckedCreateNestedManyWithoutSemesterInput = {
    create?: XOR<GradeEntryCreateWithoutSemesterInput, GradeEntryUncheckedCreateWithoutSemesterInput> | GradeEntryCreateWithoutSemesterInput[] | GradeEntryUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: GradeEntryCreateOrConnectWithoutSemesterInput | GradeEntryCreateOrConnectWithoutSemesterInput[]
    createMany?: GradeEntryCreateManySemesterInputEnvelope
    connect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
  }

  export type StudentEnrollmentUncheckedCreateNestedManyWithoutSemesterInput = {
    create?: XOR<StudentEnrollmentCreateWithoutSemesterInput, StudentEnrollmentUncheckedCreateWithoutSemesterInput> | StudentEnrollmentCreateWithoutSemesterInput[] | StudentEnrollmentUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutSemesterInput | StudentEnrollmentCreateOrConnectWithoutSemesterInput[]
    createMany?: StudentEnrollmentCreateManySemesterInputEnvelope
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
  }

  export type StudentRegistrationRequestUncheckedCreateNestedManyWithoutSemesterInput = {
    create?: XOR<StudentRegistrationRequestCreateWithoutSemesterInput, StudentRegistrationRequestUncheckedCreateWithoutSemesterInput> | StudentRegistrationRequestCreateWithoutSemesterInput[] | StudentRegistrationRequestUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: StudentRegistrationRequestCreateOrConnectWithoutSemesterInput | StudentRegistrationRequestCreateOrConnectWithoutSemesterInput[]
    createMany?: StudentRegistrationRequestCreateManySemesterInputEnvelope
    connect?: StudentRegistrationRequestWhereUniqueInput | StudentRegistrationRequestWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type AcademicYearUpdateOneRequiredWithoutSemestersNestedInput = {
    create?: XOR<AcademicYearCreateWithoutSemestersInput, AcademicYearUncheckedCreateWithoutSemestersInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutSemestersInput
    upsert?: AcademicYearUpsertWithoutSemestersInput
    connect?: AcademicYearWhereUniqueInput
    update?: XOR<XOR<AcademicYearUpdateToOneWithWhereWithoutSemestersInput, AcademicYearUpdateWithoutSemestersInput>, AcademicYearUncheckedUpdateWithoutSemestersInput>
  }

  export type AttendanceSummaryUpdateManyWithoutSemesterNestedInput = {
    create?: XOR<AttendanceSummaryCreateWithoutSemesterInput, AttendanceSummaryUncheckedCreateWithoutSemesterInput> | AttendanceSummaryCreateWithoutSemesterInput[] | AttendanceSummaryUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutSemesterInput | AttendanceSummaryCreateOrConnectWithoutSemesterInput[]
    upsert?: AttendanceSummaryUpsertWithWhereUniqueWithoutSemesterInput | AttendanceSummaryUpsertWithWhereUniqueWithoutSemesterInput[]
    createMany?: AttendanceSummaryCreateManySemesterInputEnvelope
    set?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    disconnect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    delete?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    connect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    update?: AttendanceSummaryUpdateWithWhereUniqueWithoutSemesterInput | AttendanceSummaryUpdateWithWhereUniqueWithoutSemesterInput[]
    updateMany?: AttendanceSummaryUpdateManyWithWhereWithoutSemesterInput | AttendanceSummaryUpdateManyWithWhereWithoutSemesterInput[]
    deleteMany?: AttendanceSummaryScalarWhereInput | AttendanceSummaryScalarWhereInput[]
  }

  export type GradeReportUpdateManyWithoutSemesterNestedInput = {
    create?: XOR<GradeReportCreateWithoutSemesterInput, GradeReportUncheckedCreateWithoutSemesterInput> | GradeReportCreateWithoutSemesterInput[] | GradeReportUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: GradeReportCreateOrConnectWithoutSemesterInput | GradeReportCreateOrConnectWithoutSemesterInput[]
    upsert?: GradeReportUpsertWithWhereUniqueWithoutSemesterInput | GradeReportUpsertWithWhereUniqueWithoutSemesterInput[]
    createMany?: GradeReportCreateManySemesterInputEnvelope
    set?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    disconnect?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    delete?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    connect?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    update?: GradeReportUpdateWithWhereUniqueWithoutSemesterInput | GradeReportUpdateWithWhereUniqueWithoutSemesterInput[]
    updateMany?: GradeReportUpdateManyWithWhereWithoutSemesterInput | GradeReportUpdateManyWithWhereWithoutSemesterInput[]
    deleteMany?: GradeReportScalarWhereInput | GradeReportScalarWhereInput[]
  }

  export type GradeEntryUpdateManyWithoutSemesterNestedInput = {
    create?: XOR<GradeEntryCreateWithoutSemesterInput, GradeEntryUncheckedCreateWithoutSemesterInput> | GradeEntryCreateWithoutSemesterInput[] | GradeEntryUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: GradeEntryCreateOrConnectWithoutSemesterInput | GradeEntryCreateOrConnectWithoutSemesterInput[]
    upsert?: GradeEntryUpsertWithWhereUniqueWithoutSemesterInput | GradeEntryUpsertWithWhereUniqueWithoutSemesterInput[]
    createMany?: GradeEntryCreateManySemesterInputEnvelope
    set?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    disconnect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    delete?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    connect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    update?: GradeEntryUpdateWithWhereUniqueWithoutSemesterInput | GradeEntryUpdateWithWhereUniqueWithoutSemesterInput[]
    updateMany?: GradeEntryUpdateManyWithWhereWithoutSemesterInput | GradeEntryUpdateManyWithWhereWithoutSemesterInput[]
    deleteMany?: GradeEntryScalarWhereInput | GradeEntryScalarWhereInput[]
  }

  export type StudentEnrollmentUpdateManyWithoutSemesterNestedInput = {
    create?: XOR<StudentEnrollmentCreateWithoutSemesterInput, StudentEnrollmentUncheckedCreateWithoutSemesterInput> | StudentEnrollmentCreateWithoutSemesterInput[] | StudentEnrollmentUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutSemesterInput | StudentEnrollmentCreateOrConnectWithoutSemesterInput[]
    upsert?: StudentEnrollmentUpsertWithWhereUniqueWithoutSemesterInput | StudentEnrollmentUpsertWithWhereUniqueWithoutSemesterInput[]
    createMany?: StudentEnrollmentCreateManySemesterInputEnvelope
    set?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    disconnect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    delete?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    update?: StudentEnrollmentUpdateWithWhereUniqueWithoutSemesterInput | StudentEnrollmentUpdateWithWhereUniqueWithoutSemesterInput[]
    updateMany?: StudentEnrollmentUpdateManyWithWhereWithoutSemesterInput | StudentEnrollmentUpdateManyWithWhereWithoutSemesterInput[]
    deleteMany?: StudentEnrollmentScalarWhereInput | StudentEnrollmentScalarWhereInput[]
  }

  export type StudentRegistrationRequestUpdateManyWithoutSemesterNestedInput = {
    create?: XOR<StudentRegistrationRequestCreateWithoutSemesterInput, StudentRegistrationRequestUncheckedCreateWithoutSemesterInput> | StudentRegistrationRequestCreateWithoutSemesterInput[] | StudentRegistrationRequestUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: StudentRegistrationRequestCreateOrConnectWithoutSemesterInput | StudentRegistrationRequestCreateOrConnectWithoutSemesterInput[]
    upsert?: StudentRegistrationRequestUpsertWithWhereUniqueWithoutSemesterInput | StudentRegistrationRequestUpsertWithWhereUniqueWithoutSemesterInput[]
    createMany?: StudentRegistrationRequestCreateManySemesterInputEnvelope
    set?: StudentRegistrationRequestWhereUniqueInput | StudentRegistrationRequestWhereUniqueInput[]
    disconnect?: StudentRegistrationRequestWhereUniqueInput | StudentRegistrationRequestWhereUniqueInput[]
    delete?: StudentRegistrationRequestWhereUniqueInput | StudentRegistrationRequestWhereUniqueInput[]
    connect?: StudentRegistrationRequestWhereUniqueInput | StudentRegistrationRequestWhereUniqueInput[]
    update?: StudentRegistrationRequestUpdateWithWhereUniqueWithoutSemesterInput | StudentRegistrationRequestUpdateWithWhereUniqueWithoutSemesterInput[]
    updateMany?: StudentRegistrationRequestUpdateManyWithWhereWithoutSemesterInput | StudentRegistrationRequestUpdateManyWithWhereWithoutSemesterInput[]
    deleteMany?: StudentRegistrationRequestScalarWhereInput | StudentRegistrationRequestScalarWhereInput[]
  }

  export type AttendanceSummaryUncheckedUpdateManyWithoutSemesterNestedInput = {
    create?: XOR<AttendanceSummaryCreateWithoutSemesterInput, AttendanceSummaryUncheckedCreateWithoutSemesterInput> | AttendanceSummaryCreateWithoutSemesterInput[] | AttendanceSummaryUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutSemesterInput | AttendanceSummaryCreateOrConnectWithoutSemesterInput[]
    upsert?: AttendanceSummaryUpsertWithWhereUniqueWithoutSemesterInput | AttendanceSummaryUpsertWithWhereUniqueWithoutSemesterInput[]
    createMany?: AttendanceSummaryCreateManySemesterInputEnvelope
    set?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    disconnect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    delete?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    connect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    update?: AttendanceSummaryUpdateWithWhereUniqueWithoutSemesterInput | AttendanceSummaryUpdateWithWhereUniqueWithoutSemesterInput[]
    updateMany?: AttendanceSummaryUpdateManyWithWhereWithoutSemesterInput | AttendanceSummaryUpdateManyWithWhereWithoutSemesterInput[]
    deleteMany?: AttendanceSummaryScalarWhereInput | AttendanceSummaryScalarWhereInput[]
  }

  export type GradeReportUncheckedUpdateManyWithoutSemesterNestedInput = {
    create?: XOR<GradeReportCreateWithoutSemesterInput, GradeReportUncheckedCreateWithoutSemesterInput> | GradeReportCreateWithoutSemesterInput[] | GradeReportUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: GradeReportCreateOrConnectWithoutSemesterInput | GradeReportCreateOrConnectWithoutSemesterInput[]
    upsert?: GradeReportUpsertWithWhereUniqueWithoutSemesterInput | GradeReportUpsertWithWhereUniqueWithoutSemesterInput[]
    createMany?: GradeReportCreateManySemesterInputEnvelope
    set?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    disconnect?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    delete?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    connect?: GradeReportWhereUniqueInput | GradeReportWhereUniqueInput[]
    update?: GradeReportUpdateWithWhereUniqueWithoutSemesterInput | GradeReportUpdateWithWhereUniqueWithoutSemesterInput[]
    updateMany?: GradeReportUpdateManyWithWhereWithoutSemesterInput | GradeReportUpdateManyWithWhereWithoutSemesterInput[]
    deleteMany?: GradeReportScalarWhereInput | GradeReportScalarWhereInput[]
  }

  export type GradeEntryUncheckedUpdateManyWithoutSemesterNestedInput = {
    create?: XOR<GradeEntryCreateWithoutSemesterInput, GradeEntryUncheckedCreateWithoutSemesterInput> | GradeEntryCreateWithoutSemesterInput[] | GradeEntryUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: GradeEntryCreateOrConnectWithoutSemesterInput | GradeEntryCreateOrConnectWithoutSemesterInput[]
    upsert?: GradeEntryUpsertWithWhereUniqueWithoutSemesterInput | GradeEntryUpsertWithWhereUniqueWithoutSemesterInput[]
    createMany?: GradeEntryCreateManySemesterInputEnvelope
    set?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    disconnect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    delete?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    connect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    update?: GradeEntryUpdateWithWhereUniqueWithoutSemesterInput | GradeEntryUpdateWithWhereUniqueWithoutSemesterInput[]
    updateMany?: GradeEntryUpdateManyWithWhereWithoutSemesterInput | GradeEntryUpdateManyWithWhereWithoutSemesterInput[]
    deleteMany?: GradeEntryScalarWhereInput | GradeEntryScalarWhereInput[]
  }

  export type StudentEnrollmentUncheckedUpdateManyWithoutSemesterNestedInput = {
    create?: XOR<StudentEnrollmentCreateWithoutSemesterInput, StudentEnrollmentUncheckedCreateWithoutSemesterInput> | StudentEnrollmentCreateWithoutSemesterInput[] | StudentEnrollmentUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutSemesterInput | StudentEnrollmentCreateOrConnectWithoutSemesterInput[]
    upsert?: StudentEnrollmentUpsertWithWhereUniqueWithoutSemesterInput | StudentEnrollmentUpsertWithWhereUniqueWithoutSemesterInput[]
    createMany?: StudentEnrollmentCreateManySemesterInputEnvelope
    set?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    disconnect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    delete?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    update?: StudentEnrollmentUpdateWithWhereUniqueWithoutSemesterInput | StudentEnrollmentUpdateWithWhereUniqueWithoutSemesterInput[]
    updateMany?: StudentEnrollmentUpdateManyWithWhereWithoutSemesterInput | StudentEnrollmentUpdateManyWithWhereWithoutSemesterInput[]
    deleteMany?: StudentEnrollmentScalarWhereInput | StudentEnrollmentScalarWhereInput[]
  }

  export type StudentRegistrationRequestUncheckedUpdateManyWithoutSemesterNestedInput = {
    create?: XOR<StudentRegistrationRequestCreateWithoutSemesterInput, StudentRegistrationRequestUncheckedCreateWithoutSemesterInput> | StudentRegistrationRequestCreateWithoutSemesterInput[] | StudentRegistrationRequestUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: StudentRegistrationRequestCreateOrConnectWithoutSemesterInput | StudentRegistrationRequestCreateOrConnectWithoutSemesterInput[]
    upsert?: StudentRegistrationRequestUpsertWithWhereUniqueWithoutSemesterInput | StudentRegistrationRequestUpsertWithWhereUniqueWithoutSemesterInput[]
    createMany?: StudentRegistrationRequestCreateManySemesterInputEnvelope
    set?: StudentRegistrationRequestWhereUniqueInput | StudentRegistrationRequestWhereUniqueInput[]
    disconnect?: StudentRegistrationRequestWhereUniqueInput | StudentRegistrationRequestWhereUniqueInput[]
    delete?: StudentRegistrationRequestWhereUniqueInput | StudentRegistrationRequestWhereUniqueInput[]
    connect?: StudentRegistrationRequestWhereUniqueInput | StudentRegistrationRequestWhereUniqueInput[]
    update?: StudentRegistrationRequestUpdateWithWhereUniqueWithoutSemesterInput | StudentRegistrationRequestUpdateWithWhereUniqueWithoutSemesterInput[]
    updateMany?: StudentRegistrationRequestUpdateManyWithWhereWithoutSemesterInput | StudentRegistrationRequestUpdateManyWithWhereWithoutSemesterInput[]
    deleteMany?: StudentRegistrationRequestScalarWhereInput | StudentRegistrationRequestScalarWhereInput[]
  }

  export type GradeCreateNestedOneWithoutClassSectionsInput = {
    create?: XOR<GradeCreateWithoutClassSectionsInput, GradeUncheckedCreateWithoutClassSectionsInput>
    connectOrCreate?: GradeCreateOrConnectWithoutClassSectionsInput
    connect?: GradeWhereUniqueInput
  }

  export type ClassCreateNestedManyWithoutClassSectionInput = {
    create?: XOR<ClassCreateWithoutClassSectionInput, ClassUncheckedCreateWithoutClassSectionInput> | ClassCreateWithoutClassSectionInput[] | ClassUncheckedCreateWithoutClassSectionInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutClassSectionInput | ClassCreateOrConnectWithoutClassSectionInput[]
    createMany?: ClassCreateManyClassSectionInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutClassSectionInput = {
    create?: XOR<ClassCreateWithoutClassSectionInput, ClassUncheckedCreateWithoutClassSectionInput> | ClassCreateWithoutClassSectionInput[] | ClassUncheckedCreateWithoutClassSectionInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutClassSectionInput | ClassCreateOrConnectWithoutClassSectionInput[]
    createMany?: ClassCreateManyClassSectionInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type GradeUpdateOneRequiredWithoutClassSectionsNestedInput = {
    create?: XOR<GradeCreateWithoutClassSectionsInput, GradeUncheckedCreateWithoutClassSectionsInput>
    connectOrCreate?: GradeCreateOrConnectWithoutClassSectionsInput
    upsert?: GradeUpsertWithoutClassSectionsInput
    connect?: GradeWhereUniqueInput
    update?: XOR<XOR<GradeUpdateToOneWithWhereWithoutClassSectionsInput, GradeUpdateWithoutClassSectionsInput>, GradeUncheckedUpdateWithoutClassSectionsInput>
  }

  export type ClassUpdateManyWithoutClassSectionNestedInput = {
    create?: XOR<ClassCreateWithoutClassSectionInput, ClassUncheckedCreateWithoutClassSectionInput> | ClassCreateWithoutClassSectionInput[] | ClassUncheckedCreateWithoutClassSectionInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutClassSectionInput | ClassCreateOrConnectWithoutClassSectionInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutClassSectionInput | ClassUpsertWithWhereUniqueWithoutClassSectionInput[]
    createMany?: ClassCreateManyClassSectionInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutClassSectionInput | ClassUpdateWithWhereUniqueWithoutClassSectionInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutClassSectionInput | ClassUpdateManyWithWhereWithoutClassSectionInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutClassSectionNestedInput = {
    create?: XOR<ClassCreateWithoutClassSectionInput, ClassUncheckedCreateWithoutClassSectionInput> | ClassCreateWithoutClassSectionInput[] | ClassUncheckedCreateWithoutClassSectionInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutClassSectionInput | ClassCreateOrConnectWithoutClassSectionInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutClassSectionInput | ClassUpsertWithWhereUniqueWithoutClassSectionInput[]
    createMany?: ClassCreateManyClassSectionInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutClassSectionInput | ClassUpdateWithWhereUniqueWithoutClassSectionInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutClassSectionInput | ClassUpdateManyWithWhereWithoutClassSectionInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type ClassSectionCreateNestedManyWithoutGradeInput = {
    create?: XOR<ClassSectionCreateWithoutGradeInput, ClassSectionUncheckedCreateWithoutGradeInput> | ClassSectionCreateWithoutGradeInput[] | ClassSectionUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: ClassSectionCreateOrConnectWithoutGradeInput | ClassSectionCreateOrConnectWithoutGradeInput[]
    createMany?: ClassSectionCreateManyGradeInputEnvelope
    connect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
  }

  export type SubjectCreateNestedManyWithoutGradeInput = {
    create?: XOR<SubjectCreateWithoutGradeInput, SubjectUncheckedCreateWithoutGradeInput> | SubjectCreateWithoutGradeInput[] | SubjectUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutGradeInput | SubjectCreateOrConnectWithoutGradeInput[]
    createMany?: SubjectCreateManyGradeInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type ClassCreateNestedManyWithoutGradeInput = {
    create?: XOR<ClassCreateWithoutGradeInput, ClassUncheckedCreateWithoutGradeInput> | ClassCreateWithoutGradeInput[] | ClassUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutGradeInput | ClassCreateOrConnectWithoutGradeInput[]
    createMany?: ClassCreateManyGradeInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type ClassSectionUncheckedCreateNestedManyWithoutGradeInput = {
    create?: XOR<ClassSectionCreateWithoutGradeInput, ClassSectionUncheckedCreateWithoutGradeInput> | ClassSectionCreateWithoutGradeInput[] | ClassSectionUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: ClassSectionCreateOrConnectWithoutGradeInput | ClassSectionCreateOrConnectWithoutGradeInput[]
    createMany?: ClassSectionCreateManyGradeInputEnvelope
    connect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutGradeInput = {
    create?: XOR<SubjectCreateWithoutGradeInput, SubjectUncheckedCreateWithoutGradeInput> | SubjectCreateWithoutGradeInput[] | SubjectUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutGradeInput | SubjectCreateOrConnectWithoutGradeInput[]
    createMany?: SubjectCreateManyGradeInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutGradeInput = {
    create?: XOR<ClassCreateWithoutGradeInput, ClassUncheckedCreateWithoutGradeInput> | ClassCreateWithoutGradeInput[] | ClassUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutGradeInput | ClassCreateOrConnectWithoutGradeInput[]
    createMany?: ClassCreateManyGradeInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClassSectionUpdateManyWithoutGradeNestedInput = {
    create?: XOR<ClassSectionCreateWithoutGradeInput, ClassSectionUncheckedCreateWithoutGradeInput> | ClassSectionCreateWithoutGradeInput[] | ClassSectionUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: ClassSectionCreateOrConnectWithoutGradeInput | ClassSectionCreateOrConnectWithoutGradeInput[]
    upsert?: ClassSectionUpsertWithWhereUniqueWithoutGradeInput | ClassSectionUpsertWithWhereUniqueWithoutGradeInput[]
    createMany?: ClassSectionCreateManyGradeInputEnvelope
    set?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    disconnect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    delete?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    connect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    update?: ClassSectionUpdateWithWhereUniqueWithoutGradeInput | ClassSectionUpdateWithWhereUniqueWithoutGradeInput[]
    updateMany?: ClassSectionUpdateManyWithWhereWithoutGradeInput | ClassSectionUpdateManyWithWhereWithoutGradeInput[]
    deleteMany?: ClassSectionScalarWhereInput | ClassSectionScalarWhereInput[]
  }

  export type SubjectUpdateManyWithoutGradeNestedInput = {
    create?: XOR<SubjectCreateWithoutGradeInput, SubjectUncheckedCreateWithoutGradeInput> | SubjectCreateWithoutGradeInput[] | SubjectUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutGradeInput | SubjectCreateOrConnectWithoutGradeInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutGradeInput | SubjectUpsertWithWhereUniqueWithoutGradeInput[]
    createMany?: SubjectCreateManyGradeInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutGradeInput | SubjectUpdateWithWhereUniqueWithoutGradeInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutGradeInput | SubjectUpdateManyWithWhereWithoutGradeInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type ClassUpdateManyWithoutGradeNestedInput = {
    create?: XOR<ClassCreateWithoutGradeInput, ClassUncheckedCreateWithoutGradeInput> | ClassCreateWithoutGradeInput[] | ClassUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutGradeInput | ClassCreateOrConnectWithoutGradeInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutGradeInput | ClassUpsertWithWhereUniqueWithoutGradeInput[]
    createMany?: ClassCreateManyGradeInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutGradeInput | ClassUpdateWithWhereUniqueWithoutGradeInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutGradeInput | ClassUpdateManyWithWhereWithoutGradeInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type ClassSectionUncheckedUpdateManyWithoutGradeNestedInput = {
    create?: XOR<ClassSectionCreateWithoutGradeInput, ClassSectionUncheckedCreateWithoutGradeInput> | ClassSectionCreateWithoutGradeInput[] | ClassSectionUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: ClassSectionCreateOrConnectWithoutGradeInput | ClassSectionCreateOrConnectWithoutGradeInput[]
    upsert?: ClassSectionUpsertWithWhereUniqueWithoutGradeInput | ClassSectionUpsertWithWhereUniqueWithoutGradeInput[]
    createMany?: ClassSectionCreateManyGradeInputEnvelope
    set?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    disconnect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    delete?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    connect?: ClassSectionWhereUniqueInput | ClassSectionWhereUniqueInput[]
    update?: ClassSectionUpdateWithWhereUniqueWithoutGradeInput | ClassSectionUpdateWithWhereUniqueWithoutGradeInput[]
    updateMany?: ClassSectionUpdateManyWithWhereWithoutGradeInput | ClassSectionUpdateManyWithWhereWithoutGradeInput[]
    deleteMany?: ClassSectionScalarWhereInput | ClassSectionScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutGradeNestedInput = {
    create?: XOR<SubjectCreateWithoutGradeInput, SubjectUncheckedCreateWithoutGradeInput> | SubjectCreateWithoutGradeInput[] | SubjectUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutGradeInput | SubjectCreateOrConnectWithoutGradeInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutGradeInput | SubjectUpsertWithWhereUniqueWithoutGradeInput[]
    createMany?: SubjectCreateManyGradeInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutGradeInput | SubjectUpdateWithWhereUniqueWithoutGradeInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutGradeInput | SubjectUpdateManyWithWhereWithoutGradeInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutGradeNestedInput = {
    create?: XOR<ClassCreateWithoutGradeInput, ClassUncheckedCreateWithoutGradeInput> | ClassCreateWithoutGradeInput[] | ClassUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutGradeInput | ClassCreateOrConnectWithoutGradeInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutGradeInput | ClassUpsertWithWhereUniqueWithoutGradeInput[]
    createMany?: ClassCreateManyGradeInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutGradeInput | ClassUpdateWithWhereUniqueWithoutGradeInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutGradeInput | ClassUpdateManyWithWhereWithoutGradeInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type GradeCreateNestedOneWithoutSubjectsInput = {
    create?: XOR<GradeCreateWithoutSubjectsInput, GradeUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: GradeCreateOrConnectWithoutSubjectsInput
    connect?: GradeWhereUniqueInput
  }

  export type TeacherSubjectCreateNestedManyWithoutSubjectInput = {
    create?: XOR<TeacherSubjectCreateWithoutSubjectInput, TeacherSubjectUncheckedCreateWithoutSubjectInput> | TeacherSubjectCreateWithoutSubjectInput[] | TeacherSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutSubjectInput | TeacherSubjectCreateOrConnectWithoutSubjectInput[]
    createMany?: TeacherSubjectCreateManySubjectInputEnvelope
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
  }

  export type ClassScheduleCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ClassScheduleCreateWithoutSubjectInput, ClassScheduleUncheckedCreateWithoutSubjectInput> | ClassScheduleCreateWithoutSubjectInput[] | ClassScheduleUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutSubjectInput | ClassScheduleCreateOrConnectWithoutSubjectInput[]
    createMany?: ClassScheduleCreateManySubjectInputEnvelope
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
  }

  export type GradeCategoryCreateNestedManyWithoutSubjectInput = {
    create?: XOR<GradeCategoryCreateWithoutSubjectInput, GradeCategoryUncheckedCreateWithoutSubjectInput> | GradeCategoryCreateWithoutSubjectInput[] | GradeCategoryUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: GradeCategoryCreateOrConnectWithoutSubjectInput | GradeCategoryCreateOrConnectWithoutSubjectInput[]
    createMany?: GradeCategoryCreateManySubjectInputEnvelope
    connect?: GradeCategoryWhereUniqueInput | GradeCategoryWhereUniqueInput[]
  }

  export type GradeEntryCreateNestedManyWithoutSubjectInput = {
    create?: XOR<GradeEntryCreateWithoutSubjectInput, GradeEntryUncheckedCreateWithoutSubjectInput> | GradeEntryCreateWithoutSubjectInput[] | GradeEntryUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: GradeEntryCreateOrConnectWithoutSubjectInput | GradeEntryCreateOrConnectWithoutSubjectInput[]
    createMany?: GradeEntryCreateManySubjectInputEnvelope
    connect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
  }

  export type AttendanceRecordCreateNestedManyWithoutSubjectInput = {
    create?: XOR<AttendanceRecordCreateWithoutSubjectInput, AttendanceRecordUncheckedCreateWithoutSubjectInput> | AttendanceRecordCreateWithoutSubjectInput[] | AttendanceRecordUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutSubjectInput | AttendanceRecordCreateOrConnectWithoutSubjectInput[]
    createMany?: AttendanceRecordCreateManySubjectInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutSubjectInput = {
    create?: XOR<DocumentCreateWithoutSubjectInput, DocumentUncheckedCreateWithoutSubjectInput> | DocumentCreateWithoutSubjectInput[] | DocumentUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutSubjectInput | DocumentCreateOrConnectWithoutSubjectInput[]
    createMany?: DocumentCreateManySubjectInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type AttendanceSummaryCreateNestedManyWithoutSubjectInput = {
    create?: XOR<AttendanceSummaryCreateWithoutSubjectInput, AttendanceSummaryUncheckedCreateWithoutSubjectInput> | AttendanceSummaryCreateWithoutSubjectInput[] | AttendanceSummaryUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutSubjectInput | AttendanceSummaryCreateOrConnectWithoutSubjectInput[]
    createMany?: AttendanceSummaryCreateManySubjectInputEnvelope
    connect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
  }

  export type TeacherSubjectUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<TeacherSubjectCreateWithoutSubjectInput, TeacherSubjectUncheckedCreateWithoutSubjectInput> | TeacherSubjectCreateWithoutSubjectInput[] | TeacherSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutSubjectInput | TeacherSubjectCreateOrConnectWithoutSubjectInput[]
    createMany?: TeacherSubjectCreateManySubjectInputEnvelope
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
  }

  export type ClassScheduleUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ClassScheduleCreateWithoutSubjectInput, ClassScheduleUncheckedCreateWithoutSubjectInput> | ClassScheduleCreateWithoutSubjectInput[] | ClassScheduleUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutSubjectInput | ClassScheduleCreateOrConnectWithoutSubjectInput[]
    createMany?: ClassScheduleCreateManySubjectInputEnvelope
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
  }

  export type GradeCategoryUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<GradeCategoryCreateWithoutSubjectInput, GradeCategoryUncheckedCreateWithoutSubjectInput> | GradeCategoryCreateWithoutSubjectInput[] | GradeCategoryUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: GradeCategoryCreateOrConnectWithoutSubjectInput | GradeCategoryCreateOrConnectWithoutSubjectInput[]
    createMany?: GradeCategoryCreateManySubjectInputEnvelope
    connect?: GradeCategoryWhereUniqueInput | GradeCategoryWhereUniqueInput[]
  }

  export type GradeEntryUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<GradeEntryCreateWithoutSubjectInput, GradeEntryUncheckedCreateWithoutSubjectInput> | GradeEntryCreateWithoutSubjectInput[] | GradeEntryUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: GradeEntryCreateOrConnectWithoutSubjectInput | GradeEntryCreateOrConnectWithoutSubjectInput[]
    createMany?: GradeEntryCreateManySubjectInputEnvelope
    connect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
  }

  export type AttendanceRecordUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<AttendanceRecordCreateWithoutSubjectInput, AttendanceRecordUncheckedCreateWithoutSubjectInput> | AttendanceRecordCreateWithoutSubjectInput[] | AttendanceRecordUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutSubjectInput | AttendanceRecordCreateOrConnectWithoutSubjectInput[]
    createMany?: AttendanceRecordCreateManySubjectInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<DocumentCreateWithoutSubjectInput, DocumentUncheckedCreateWithoutSubjectInput> | DocumentCreateWithoutSubjectInput[] | DocumentUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutSubjectInput | DocumentCreateOrConnectWithoutSubjectInput[]
    createMany?: DocumentCreateManySubjectInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type AttendanceSummaryUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<AttendanceSummaryCreateWithoutSubjectInput, AttendanceSummaryUncheckedCreateWithoutSubjectInput> | AttendanceSummaryCreateWithoutSubjectInput[] | AttendanceSummaryUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutSubjectInput | AttendanceSummaryCreateOrConnectWithoutSubjectInput[]
    createMany?: AttendanceSummaryCreateManySubjectInputEnvelope
    connect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
  }

  export type GradeUpdateOneRequiredWithoutSubjectsNestedInput = {
    create?: XOR<GradeCreateWithoutSubjectsInput, GradeUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: GradeCreateOrConnectWithoutSubjectsInput
    upsert?: GradeUpsertWithoutSubjectsInput
    connect?: GradeWhereUniqueInput
    update?: XOR<XOR<GradeUpdateToOneWithWhereWithoutSubjectsInput, GradeUpdateWithoutSubjectsInput>, GradeUncheckedUpdateWithoutSubjectsInput>
  }

  export type TeacherSubjectUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<TeacherSubjectCreateWithoutSubjectInput, TeacherSubjectUncheckedCreateWithoutSubjectInput> | TeacherSubjectCreateWithoutSubjectInput[] | TeacherSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutSubjectInput | TeacherSubjectCreateOrConnectWithoutSubjectInput[]
    upsert?: TeacherSubjectUpsertWithWhereUniqueWithoutSubjectInput | TeacherSubjectUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: TeacherSubjectCreateManySubjectInputEnvelope
    set?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    disconnect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    delete?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    update?: TeacherSubjectUpdateWithWhereUniqueWithoutSubjectInput | TeacherSubjectUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: TeacherSubjectUpdateManyWithWhereWithoutSubjectInput | TeacherSubjectUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: TeacherSubjectScalarWhereInput | TeacherSubjectScalarWhereInput[]
  }

  export type ClassScheduleUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ClassScheduleCreateWithoutSubjectInput, ClassScheduleUncheckedCreateWithoutSubjectInput> | ClassScheduleCreateWithoutSubjectInput[] | ClassScheduleUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutSubjectInput | ClassScheduleCreateOrConnectWithoutSubjectInput[]
    upsert?: ClassScheduleUpsertWithWhereUniqueWithoutSubjectInput | ClassScheduleUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ClassScheduleCreateManySubjectInputEnvelope
    set?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    disconnect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    delete?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    update?: ClassScheduleUpdateWithWhereUniqueWithoutSubjectInput | ClassScheduleUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ClassScheduleUpdateManyWithWhereWithoutSubjectInput | ClassScheduleUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ClassScheduleScalarWhereInput | ClassScheduleScalarWhereInput[]
  }

  export type GradeCategoryUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<GradeCategoryCreateWithoutSubjectInput, GradeCategoryUncheckedCreateWithoutSubjectInput> | GradeCategoryCreateWithoutSubjectInput[] | GradeCategoryUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: GradeCategoryCreateOrConnectWithoutSubjectInput | GradeCategoryCreateOrConnectWithoutSubjectInput[]
    upsert?: GradeCategoryUpsertWithWhereUniqueWithoutSubjectInput | GradeCategoryUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: GradeCategoryCreateManySubjectInputEnvelope
    set?: GradeCategoryWhereUniqueInput | GradeCategoryWhereUniqueInput[]
    disconnect?: GradeCategoryWhereUniqueInput | GradeCategoryWhereUniqueInput[]
    delete?: GradeCategoryWhereUniqueInput | GradeCategoryWhereUniqueInput[]
    connect?: GradeCategoryWhereUniqueInput | GradeCategoryWhereUniqueInput[]
    update?: GradeCategoryUpdateWithWhereUniqueWithoutSubjectInput | GradeCategoryUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: GradeCategoryUpdateManyWithWhereWithoutSubjectInput | GradeCategoryUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: GradeCategoryScalarWhereInput | GradeCategoryScalarWhereInput[]
  }

  export type GradeEntryUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<GradeEntryCreateWithoutSubjectInput, GradeEntryUncheckedCreateWithoutSubjectInput> | GradeEntryCreateWithoutSubjectInput[] | GradeEntryUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: GradeEntryCreateOrConnectWithoutSubjectInput | GradeEntryCreateOrConnectWithoutSubjectInput[]
    upsert?: GradeEntryUpsertWithWhereUniqueWithoutSubjectInput | GradeEntryUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: GradeEntryCreateManySubjectInputEnvelope
    set?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    disconnect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    delete?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    connect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    update?: GradeEntryUpdateWithWhereUniqueWithoutSubjectInput | GradeEntryUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: GradeEntryUpdateManyWithWhereWithoutSubjectInput | GradeEntryUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: GradeEntryScalarWhereInput | GradeEntryScalarWhereInput[]
  }

  export type AttendanceRecordUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutSubjectInput, AttendanceRecordUncheckedCreateWithoutSubjectInput> | AttendanceRecordCreateWithoutSubjectInput[] | AttendanceRecordUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutSubjectInput | AttendanceRecordCreateOrConnectWithoutSubjectInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutSubjectInput | AttendanceRecordUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: AttendanceRecordCreateManySubjectInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutSubjectInput | AttendanceRecordUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutSubjectInput | AttendanceRecordUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<DocumentCreateWithoutSubjectInput, DocumentUncheckedCreateWithoutSubjectInput> | DocumentCreateWithoutSubjectInput[] | DocumentUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutSubjectInput | DocumentCreateOrConnectWithoutSubjectInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutSubjectInput | DocumentUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: DocumentCreateManySubjectInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutSubjectInput | DocumentUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutSubjectInput | DocumentUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type AttendanceSummaryUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<AttendanceSummaryCreateWithoutSubjectInput, AttendanceSummaryUncheckedCreateWithoutSubjectInput> | AttendanceSummaryCreateWithoutSubjectInput[] | AttendanceSummaryUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutSubjectInput | AttendanceSummaryCreateOrConnectWithoutSubjectInput[]
    upsert?: AttendanceSummaryUpsertWithWhereUniqueWithoutSubjectInput | AttendanceSummaryUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: AttendanceSummaryCreateManySubjectInputEnvelope
    set?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    disconnect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    delete?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    connect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    update?: AttendanceSummaryUpdateWithWhereUniqueWithoutSubjectInput | AttendanceSummaryUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: AttendanceSummaryUpdateManyWithWhereWithoutSubjectInput | AttendanceSummaryUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: AttendanceSummaryScalarWhereInput | AttendanceSummaryScalarWhereInput[]
  }

  export type TeacherSubjectUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<TeacherSubjectCreateWithoutSubjectInput, TeacherSubjectUncheckedCreateWithoutSubjectInput> | TeacherSubjectCreateWithoutSubjectInput[] | TeacherSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutSubjectInput | TeacherSubjectCreateOrConnectWithoutSubjectInput[]
    upsert?: TeacherSubjectUpsertWithWhereUniqueWithoutSubjectInput | TeacherSubjectUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: TeacherSubjectCreateManySubjectInputEnvelope
    set?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    disconnect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    delete?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    update?: TeacherSubjectUpdateWithWhereUniqueWithoutSubjectInput | TeacherSubjectUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: TeacherSubjectUpdateManyWithWhereWithoutSubjectInput | TeacherSubjectUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: TeacherSubjectScalarWhereInput | TeacherSubjectScalarWhereInput[]
  }

  export type ClassScheduleUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ClassScheduleCreateWithoutSubjectInput, ClassScheduleUncheckedCreateWithoutSubjectInput> | ClassScheduleCreateWithoutSubjectInput[] | ClassScheduleUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutSubjectInput | ClassScheduleCreateOrConnectWithoutSubjectInput[]
    upsert?: ClassScheduleUpsertWithWhereUniqueWithoutSubjectInput | ClassScheduleUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ClassScheduleCreateManySubjectInputEnvelope
    set?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    disconnect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    delete?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    update?: ClassScheduleUpdateWithWhereUniqueWithoutSubjectInput | ClassScheduleUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ClassScheduleUpdateManyWithWhereWithoutSubjectInput | ClassScheduleUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ClassScheduleScalarWhereInput | ClassScheduleScalarWhereInput[]
  }

  export type GradeCategoryUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<GradeCategoryCreateWithoutSubjectInput, GradeCategoryUncheckedCreateWithoutSubjectInput> | GradeCategoryCreateWithoutSubjectInput[] | GradeCategoryUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: GradeCategoryCreateOrConnectWithoutSubjectInput | GradeCategoryCreateOrConnectWithoutSubjectInput[]
    upsert?: GradeCategoryUpsertWithWhereUniqueWithoutSubjectInput | GradeCategoryUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: GradeCategoryCreateManySubjectInputEnvelope
    set?: GradeCategoryWhereUniqueInput | GradeCategoryWhereUniqueInput[]
    disconnect?: GradeCategoryWhereUniqueInput | GradeCategoryWhereUniqueInput[]
    delete?: GradeCategoryWhereUniqueInput | GradeCategoryWhereUniqueInput[]
    connect?: GradeCategoryWhereUniqueInput | GradeCategoryWhereUniqueInput[]
    update?: GradeCategoryUpdateWithWhereUniqueWithoutSubjectInput | GradeCategoryUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: GradeCategoryUpdateManyWithWhereWithoutSubjectInput | GradeCategoryUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: GradeCategoryScalarWhereInput | GradeCategoryScalarWhereInput[]
  }

  export type GradeEntryUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<GradeEntryCreateWithoutSubjectInput, GradeEntryUncheckedCreateWithoutSubjectInput> | GradeEntryCreateWithoutSubjectInput[] | GradeEntryUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: GradeEntryCreateOrConnectWithoutSubjectInput | GradeEntryCreateOrConnectWithoutSubjectInput[]
    upsert?: GradeEntryUpsertWithWhereUniqueWithoutSubjectInput | GradeEntryUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: GradeEntryCreateManySubjectInputEnvelope
    set?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    disconnect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    delete?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    connect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    update?: GradeEntryUpdateWithWhereUniqueWithoutSubjectInput | GradeEntryUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: GradeEntryUpdateManyWithWhereWithoutSubjectInput | GradeEntryUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: GradeEntryScalarWhereInput | GradeEntryScalarWhereInput[]
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutSubjectInput, AttendanceRecordUncheckedCreateWithoutSubjectInput> | AttendanceRecordCreateWithoutSubjectInput[] | AttendanceRecordUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutSubjectInput | AttendanceRecordCreateOrConnectWithoutSubjectInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutSubjectInput | AttendanceRecordUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: AttendanceRecordCreateManySubjectInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutSubjectInput | AttendanceRecordUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutSubjectInput | AttendanceRecordUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<DocumentCreateWithoutSubjectInput, DocumentUncheckedCreateWithoutSubjectInput> | DocumentCreateWithoutSubjectInput[] | DocumentUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutSubjectInput | DocumentCreateOrConnectWithoutSubjectInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutSubjectInput | DocumentUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: DocumentCreateManySubjectInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutSubjectInput | DocumentUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutSubjectInput | DocumentUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type AttendanceSummaryUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<AttendanceSummaryCreateWithoutSubjectInput, AttendanceSummaryUncheckedCreateWithoutSubjectInput> | AttendanceSummaryCreateWithoutSubjectInput[] | AttendanceSummaryUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutSubjectInput | AttendanceSummaryCreateOrConnectWithoutSubjectInput[]
    upsert?: AttendanceSummaryUpsertWithWhereUniqueWithoutSubjectInput | AttendanceSummaryUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: AttendanceSummaryCreateManySubjectInputEnvelope
    set?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    disconnect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    delete?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    connect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    update?: AttendanceSummaryUpdateWithWhereUniqueWithoutSubjectInput | AttendanceSummaryUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: AttendanceSummaryUpdateManyWithWhereWithoutSubjectInput | AttendanceSummaryUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: AttendanceSummaryScalarWhereInput | AttendanceSummaryScalarWhereInput[]
  }

  export type GradeCreateNestedOneWithoutClassesInput = {
    create?: XOR<GradeCreateWithoutClassesInput, GradeUncheckedCreateWithoutClassesInput>
    connectOrCreate?: GradeCreateOrConnectWithoutClassesInput
    connect?: GradeWhereUniqueInput
  }

  export type ClassSectionCreateNestedOneWithoutClassesInput = {
    create?: XOR<ClassSectionCreateWithoutClassesInput, ClassSectionUncheckedCreateWithoutClassesInput>
    connectOrCreate?: ClassSectionCreateOrConnectWithoutClassesInput
    connect?: ClassSectionWhereUniqueInput
  }

  export type AcademicYearCreateNestedOneWithoutClassesInput = {
    create?: XOR<AcademicYearCreateWithoutClassesInput, AcademicYearUncheckedCreateWithoutClassesInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutClassesInput
    connect?: AcademicYearWhereUniqueInput
  }

  export type TeacherSubjectCreateNestedManyWithoutClassInput = {
    create?: XOR<TeacherSubjectCreateWithoutClassInput, TeacherSubjectUncheckedCreateWithoutClassInput> | TeacherSubjectCreateWithoutClassInput[] | TeacherSubjectUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutClassInput | TeacherSubjectCreateOrConnectWithoutClassInput[]
    createMany?: TeacherSubjectCreateManyClassInputEnvelope
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
  }

  export type StudentEnrollmentCreateNestedManyWithoutClassInput = {
    create?: XOR<StudentEnrollmentCreateWithoutClassInput, StudentEnrollmentUncheckedCreateWithoutClassInput> | StudentEnrollmentCreateWithoutClassInput[] | StudentEnrollmentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutClassInput | StudentEnrollmentCreateOrConnectWithoutClassInput[]
    createMany?: StudentEnrollmentCreateManyClassInputEnvelope
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
  }

  export type ClassScheduleCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassScheduleCreateWithoutClassInput, ClassScheduleUncheckedCreateWithoutClassInput> | ClassScheduleCreateWithoutClassInput[] | ClassScheduleUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutClassInput | ClassScheduleCreateOrConnectWithoutClassInput[]
    createMany?: ClassScheduleCreateManyClassInputEnvelope
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
  }

  export type AttendanceRecordCreateNestedManyWithoutClassInput = {
    create?: XOR<AttendanceRecordCreateWithoutClassInput, AttendanceRecordUncheckedCreateWithoutClassInput> | AttendanceRecordCreateWithoutClassInput[] | AttendanceRecordUncheckedCreateWithoutClassInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutClassInput | AttendanceRecordCreateOrConnectWithoutClassInput[]
    createMany?: AttendanceRecordCreateManyClassInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutClassInput = {
    create?: XOR<DocumentCreateWithoutClassInput, DocumentUncheckedCreateWithoutClassInput> | DocumentCreateWithoutClassInput[] | DocumentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClassInput | DocumentCreateOrConnectWithoutClassInput[]
    createMany?: DocumentCreateManyClassInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type GradeCategoryCreateNestedManyWithoutClassInput = {
    create?: XOR<GradeCategoryCreateWithoutClassInput, GradeCategoryUncheckedCreateWithoutClassInput> | GradeCategoryCreateWithoutClassInput[] | GradeCategoryUncheckedCreateWithoutClassInput[]
    connectOrCreate?: GradeCategoryCreateOrConnectWithoutClassInput | GradeCategoryCreateOrConnectWithoutClassInput[]
    createMany?: GradeCategoryCreateManyClassInputEnvelope
    connect?: GradeCategoryWhereUniqueInput | GradeCategoryWhereUniqueInput[]
  }

  export type GradeEntryCreateNestedManyWithoutClassInput = {
    create?: XOR<GradeEntryCreateWithoutClassInput, GradeEntryUncheckedCreateWithoutClassInput> | GradeEntryCreateWithoutClassInput[] | GradeEntryUncheckedCreateWithoutClassInput[]
    connectOrCreate?: GradeEntryCreateOrConnectWithoutClassInput | GradeEntryCreateOrConnectWithoutClassInput[]
    createMany?: GradeEntryCreateManyClassInputEnvelope
    connect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
  }

  export type TeacherSubjectUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<TeacherSubjectCreateWithoutClassInput, TeacherSubjectUncheckedCreateWithoutClassInput> | TeacherSubjectCreateWithoutClassInput[] | TeacherSubjectUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutClassInput | TeacherSubjectCreateOrConnectWithoutClassInput[]
    createMany?: TeacherSubjectCreateManyClassInputEnvelope
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
  }

  export type StudentEnrollmentUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<StudentEnrollmentCreateWithoutClassInput, StudentEnrollmentUncheckedCreateWithoutClassInput> | StudentEnrollmentCreateWithoutClassInput[] | StudentEnrollmentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutClassInput | StudentEnrollmentCreateOrConnectWithoutClassInput[]
    createMany?: StudentEnrollmentCreateManyClassInputEnvelope
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
  }

  export type ClassScheduleUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassScheduleCreateWithoutClassInput, ClassScheduleUncheckedCreateWithoutClassInput> | ClassScheduleCreateWithoutClassInput[] | ClassScheduleUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutClassInput | ClassScheduleCreateOrConnectWithoutClassInput[]
    createMany?: ClassScheduleCreateManyClassInputEnvelope
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
  }

  export type AttendanceRecordUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<AttendanceRecordCreateWithoutClassInput, AttendanceRecordUncheckedCreateWithoutClassInput> | AttendanceRecordCreateWithoutClassInput[] | AttendanceRecordUncheckedCreateWithoutClassInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutClassInput | AttendanceRecordCreateOrConnectWithoutClassInput[]
    createMany?: AttendanceRecordCreateManyClassInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<DocumentCreateWithoutClassInput, DocumentUncheckedCreateWithoutClassInput> | DocumentCreateWithoutClassInput[] | DocumentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClassInput | DocumentCreateOrConnectWithoutClassInput[]
    createMany?: DocumentCreateManyClassInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type GradeCategoryUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<GradeCategoryCreateWithoutClassInput, GradeCategoryUncheckedCreateWithoutClassInput> | GradeCategoryCreateWithoutClassInput[] | GradeCategoryUncheckedCreateWithoutClassInput[]
    connectOrCreate?: GradeCategoryCreateOrConnectWithoutClassInput | GradeCategoryCreateOrConnectWithoutClassInput[]
    createMany?: GradeCategoryCreateManyClassInputEnvelope
    connect?: GradeCategoryWhereUniqueInput | GradeCategoryWhereUniqueInput[]
  }

  export type GradeEntryUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<GradeEntryCreateWithoutClassInput, GradeEntryUncheckedCreateWithoutClassInput> | GradeEntryCreateWithoutClassInput[] | GradeEntryUncheckedCreateWithoutClassInput[]
    connectOrCreate?: GradeEntryCreateOrConnectWithoutClassInput | GradeEntryCreateOrConnectWithoutClassInput[]
    createMany?: GradeEntryCreateManyClassInputEnvelope
    connect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
  }

  export type GradeUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<GradeCreateWithoutClassesInput, GradeUncheckedCreateWithoutClassesInput>
    connectOrCreate?: GradeCreateOrConnectWithoutClassesInput
    upsert?: GradeUpsertWithoutClassesInput
    connect?: GradeWhereUniqueInput
    update?: XOR<XOR<GradeUpdateToOneWithWhereWithoutClassesInput, GradeUpdateWithoutClassesInput>, GradeUncheckedUpdateWithoutClassesInput>
  }

  export type ClassSectionUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<ClassSectionCreateWithoutClassesInput, ClassSectionUncheckedCreateWithoutClassesInput>
    connectOrCreate?: ClassSectionCreateOrConnectWithoutClassesInput
    upsert?: ClassSectionUpsertWithoutClassesInput
    connect?: ClassSectionWhereUniqueInput
    update?: XOR<XOR<ClassSectionUpdateToOneWithWhereWithoutClassesInput, ClassSectionUpdateWithoutClassesInput>, ClassSectionUncheckedUpdateWithoutClassesInput>
  }

  export type AcademicYearUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<AcademicYearCreateWithoutClassesInput, AcademicYearUncheckedCreateWithoutClassesInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutClassesInput
    upsert?: AcademicYearUpsertWithoutClassesInput
    connect?: AcademicYearWhereUniqueInput
    update?: XOR<XOR<AcademicYearUpdateToOneWithWhereWithoutClassesInput, AcademicYearUpdateWithoutClassesInput>, AcademicYearUncheckedUpdateWithoutClassesInput>
  }

  export type TeacherSubjectUpdateManyWithoutClassNestedInput = {
    create?: XOR<TeacherSubjectCreateWithoutClassInput, TeacherSubjectUncheckedCreateWithoutClassInput> | TeacherSubjectCreateWithoutClassInput[] | TeacherSubjectUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutClassInput | TeacherSubjectCreateOrConnectWithoutClassInput[]
    upsert?: TeacherSubjectUpsertWithWhereUniqueWithoutClassInput | TeacherSubjectUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: TeacherSubjectCreateManyClassInputEnvelope
    set?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    disconnect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    delete?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    update?: TeacherSubjectUpdateWithWhereUniqueWithoutClassInput | TeacherSubjectUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: TeacherSubjectUpdateManyWithWhereWithoutClassInput | TeacherSubjectUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: TeacherSubjectScalarWhereInput | TeacherSubjectScalarWhereInput[]
  }

  export type StudentEnrollmentUpdateManyWithoutClassNestedInput = {
    create?: XOR<StudentEnrollmentCreateWithoutClassInput, StudentEnrollmentUncheckedCreateWithoutClassInput> | StudentEnrollmentCreateWithoutClassInput[] | StudentEnrollmentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutClassInput | StudentEnrollmentCreateOrConnectWithoutClassInput[]
    upsert?: StudentEnrollmentUpsertWithWhereUniqueWithoutClassInput | StudentEnrollmentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: StudentEnrollmentCreateManyClassInputEnvelope
    set?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    disconnect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    delete?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    update?: StudentEnrollmentUpdateWithWhereUniqueWithoutClassInput | StudentEnrollmentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: StudentEnrollmentUpdateManyWithWhereWithoutClassInput | StudentEnrollmentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: StudentEnrollmentScalarWhereInput | StudentEnrollmentScalarWhereInput[]
  }

  export type ClassScheduleUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassScheduleCreateWithoutClassInput, ClassScheduleUncheckedCreateWithoutClassInput> | ClassScheduleCreateWithoutClassInput[] | ClassScheduleUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutClassInput | ClassScheduleCreateOrConnectWithoutClassInput[]
    upsert?: ClassScheduleUpsertWithWhereUniqueWithoutClassInput | ClassScheduleUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassScheduleCreateManyClassInputEnvelope
    set?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    disconnect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    delete?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    update?: ClassScheduleUpdateWithWhereUniqueWithoutClassInput | ClassScheduleUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassScheduleUpdateManyWithWhereWithoutClassInput | ClassScheduleUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassScheduleScalarWhereInput | ClassScheduleScalarWhereInput[]
  }

  export type AttendanceRecordUpdateManyWithoutClassNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutClassInput, AttendanceRecordUncheckedCreateWithoutClassInput> | AttendanceRecordCreateWithoutClassInput[] | AttendanceRecordUncheckedCreateWithoutClassInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutClassInput | AttendanceRecordCreateOrConnectWithoutClassInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutClassInput | AttendanceRecordUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: AttendanceRecordCreateManyClassInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutClassInput | AttendanceRecordUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutClassInput | AttendanceRecordUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutClassNestedInput = {
    create?: XOR<DocumentCreateWithoutClassInput, DocumentUncheckedCreateWithoutClassInput> | DocumentCreateWithoutClassInput[] | DocumentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClassInput | DocumentCreateOrConnectWithoutClassInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutClassInput | DocumentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: DocumentCreateManyClassInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutClassInput | DocumentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutClassInput | DocumentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type GradeCategoryUpdateManyWithoutClassNestedInput = {
    create?: XOR<GradeCategoryCreateWithoutClassInput, GradeCategoryUncheckedCreateWithoutClassInput> | GradeCategoryCreateWithoutClassInput[] | GradeCategoryUncheckedCreateWithoutClassInput[]
    connectOrCreate?: GradeCategoryCreateOrConnectWithoutClassInput | GradeCategoryCreateOrConnectWithoutClassInput[]
    upsert?: GradeCategoryUpsertWithWhereUniqueWithoutClassInput | GradeCategoryUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: GradeCategoryCreateManyClassInputEnvelope
    set?: GradeCategoryWhereUniqueInput | GradeCategoryWhereUniqueInput[]
    disconnect?: GradeCategoryWhereUniqueInput | GradeCategoryWhereUniqueInput[]
    delete?: GradeCategoryWhereUniqueInput | GradeCategoryWhereUniqueInput[]
    connect?: GradeCategoryWhereUniqueInput | GradeCategoryWhereUniqueInput[]
    update?: GradeCategoryUpdateWithWhereUniqueWithoutClassInput | GradeCategoryUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: GradeCategoryUpdateManyWithWhereWithoutClassInput | GradeCategoryUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: GradeCategoryScalarWhereInput | GradeCategoryScalarWhereInput[]
  }

  export type GradeEntryUpdateManyWithoutClassNestedInput = {
    create?: XOR<GradeEntryCreateWithoutClassInput, GradeEntryUncheckedCreateWithoutClassInput> | GradeEntryCreateWithoutClassInput[] | GradeEntryUncheckedCreateWithoutClassInput[]
    connectOrCreate?: GradeEntryCreateOrConnectWithoutClassInput | GradeEntryCreateOrConnectWithoutClassInput[]
    upsert?: GradeEntryUpsertWithWhereUniqueWithoutClassInput | GradeEntryUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: GradeEntryCreateManyClassInputEnvelope
    set?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    disconnect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    delete?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    connect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    update?: GradeEntryUpdateWithWhereUniqueWithoutClassInput | GradeEntryUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: GradeEntryUpdateManyWithWhereWithoutClassInput | GradeEntryUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: GradeEntryScalarWhereInput | GradeEntryScalarWhereInput[]
  }

  export type TeacherSubjectUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<TeacherSubjectCreateWithoutClassInput, TeacherSubjectUncheckedCreateWithoutClassInput> | TeacherSubjectCreateWithoutClassInput[] | TeacherSubjectUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutClassInput | TeacherSubjectCreateOrConnectWithoutClassInput[]
    upsert?: TeacherSubjectUpsertWithWhereUniqueWithoutClassInput | TeacherSubjectUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: TeacherSubjectCreateManyClassInputEnvelope
    set?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    disconnect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    delete?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    update?: TeacherSubjectUpdateWithWhereUniqueWithoutClassInput | TeacherSubjectUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: TeacherSubjectUpdateManyWithWhereWithoutClassInput | TeacherSubjectUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: TeacherSubjectScalarWhereInput | TeacherSubjectScalarWhereInput[]
  }

  export type StudentEnrollmentUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<StudentEnrollmentCreateWithoutClassInput, StudentEnrollmentUncheckedCreateWithoutClassInput> | StudentEnrollmentCreateWithoutClassInput[] | StudentEnrollmentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentEnrollmentCreateOrConnectWithoutClassInput | StudentEnrollmentCreateOrConnectWithoutClassInput[]
    upsert?: StudentEnrollmentUpsertWithWhereUniqueWithoutClassInput | StudentEnrollmentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: StudentEnrollmentCreateManyClassInputEnvelope
    set?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    disconnect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    delete?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    connect?: StudentEnrollmentWhereUniqueInput | StudentEnrollmentWhereUniqueInput[]
    update?: StudentEnrollmentUpdateWithWhereUniqueWithoutClassInput | StudentEnrollmentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: StudentEnrollmentUpdateManyWithWhereWithoutClassInput | StudentEnrollmentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: StudentEnrollmentScalarWhereInput | StudentEnrollmentScalarWhereInput[]
  }

  export type ClassScheduleUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassScheduleCreateWithoutClassInput, ClassScheduleUncheckedCreateWithoutClassInput> | ClassScheduleCreateWithoutClassInput[] | ClassScheduleUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassScheduleCreateOrConnectWithoutClassInput | ClassScheduleCreateOrConnectWithoutClassInput[]
    upsert?: ClassScheduleUpsertWithWhereUniqueWithoutClassInput | ClassScheduleUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassScheduleCreateManyClassInputEnvelope
    set?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    disconnect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    delete?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    connect?: ClassScheduleWhereUniqueInput | ClassScheduleWhereUniqueInput[]
    update?: ClassScheduleUpdateWithWhereUniqueWithoutClassInput | ClassScheduleUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassScheduleUpdateManyWithWhereWithoutClassInput | ClassScheduleUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassScheduleScalarWhereInput | ClassScheduleScalarWhereInput[]
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutClassInput, AttendanceRecordUncheckedCreateWithoutClassInput> | AttendanceRecordCreateWithoutClassInput[] | AttendanceRecordUncheckedCreateWithoutClassInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutClassInput | AttendanceRecordCreateOrConnectWithoutClassInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutClassInput | AttendanceRecordUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: AttendanceRecordCreateManyClassInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutClassInput | AttendanceRecordUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutClassInput | AttendanceRecordUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<DocumentCreateWithoutClassInput, DocumentUncheckedCreateWithoutClassInput> | DocumentCreateWithoutClassInput[] | DocumentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClassInput | DocumentCreateOrConnectWithoutClassInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutClassInput | DocumentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: DocumentCreateManyClassInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutClassInput | DocumentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutClassInput | DocumentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type GradeCategoryUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<GradeCategoryCreateWithoutClassInput, GradeCategoryUncheckedCreateWithoutClassInput> | GradeCategoryCreateWithoutClassInput[] | GradeCategoryUncheckedCreateWithoutClassInput[]
    connectOrCreate?: GradeCategoryCreateOrConnectWithoutClassInput | GradeCategoryCreateOrConnectWithoutClassInput[]
    upsert?: GradeCategoryUpsertWithWhereUniqueWithoutClassInput | GradeCategoryUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: GradeCategoryCreateManyClassInputEnvelope
    set?: GradeCategoryWhereUniqueInput | GradeCategoryWhereUniqueInput[]
    disconnect?: GradeCategoryWhereUniqueInput | GradeCategoryWhereUniqueInput[]
    delete?: GradeCategoryWhereUniqueInput | GradeCategoryWhereUniqueInput[]
    connect?: GradeCategoryWhereUniqueInput | GradeCategoryWhereUniqueInput[]
    update?: GradeCategoryUpdateWithWhereUniqueWithoutClassInput | GradeCategoryUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: GradeCategoryUpdateManyWithWhereWithoutClassInput | GradeCategoryUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: GradeCategoryScalarWhereInput | GradeCategoryScalarWhereInput[]
  }

  export type GradeEntryUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<GradeEntryCreateWithoutClassInput, GradeEntryUncheckedCreateWithoutClassInput> | GradeEntryCreateWithoutClassInput[] | GradeEntryUncheckedCreateWithoutClassInput[]
    connectOrCreate?: GradeEntryCreateOrConnectWithoutClassInput | GradeEntryCreateOrConnectWithoutClassInput[]
    upsert?: GradeEntryUpsertWithWhereUniqueWithoutClassInput | GradeEntryUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: GradeEntryCreateManyClassInputEnvelope
    set?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    disconnect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    delete?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    connect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    update?: GradeEntryUpdateWithWhereUniqueWithoutClassInput | GradeEntryUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: GradeEntryUpdateManyWithWhereWithoutClassInput | GradeEntryUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: GradeEntryScalarWhereInput | GradeEntryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTeacherSubjectsInput = {
    create?: XOR<UserCreateWithoutTeacherSubjectsInput, UserUncheckedCreateWithoutTeacherSubjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherSubjectsInput
    connect?: UserWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutTeacherSubjectsInput = {
    create?: XOR<SubjectCreateWithoutTeacherSubjectsInput, SubjectUncheckedCreateWithoutTeacherSubjectsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutTeacherSubjectsInput
    connect?: SubjectWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutTeacherSubjectsInput = {
    create?: XOR<ClassCreateWithoutTeacherSubjectsInput, ClassUncheckedCreateWithoutTeacherSubjectsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutTeacherSubjectsInput
    connect?: ClassWhereUniqueInput
  }

  export type AcademicYearCreateNestedOneWithoutTeacherSubjectsInput = {
    create?: XOR<AcademicYearCreateWithoutTeacherSubjectsInput, AcademicYearUncheckedCreateWithoutTeacherSubjectsInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutTeacherSubjectsInput
    connect?: AcademicYearWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTeacherSubjectsNestedInput = {
    create?: XOR<UserCreateWithoutTeacherSubjectsInput, UserUncheckedCreateWithoutTeacherSubjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherSubjectsInput
    upsert?: UserUpsertWithoutTeacherSubjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeacherSubjectsInput, UserUpdateWithoutTeacherSubjectsInput>, UserUncheckedUpdateWithoutTeacherSubjectsInput>
  }

  export type SubjectUpdateOneRequiredWithoutTeacherSubjectsNestedInput = {
    create?: XOR<SubjectCreateWithoutTeacherSubjectsInput, SubjectUncheckedCreateWithoutTeacherSubjectsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutTeacherSubjectsInput
    upsert?: SubjectUpsertWithoutTeacherSubjectsInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutTeacherSubjectsInput, SubjectUpdateWithoutTeacherSubjectsInput>, SubjectUncheckedUpdateWithoutTeacherSubjectsInput>
  }

  export type ClassUpdateOneRequiredWithoutTeacherSubjectsNestedInput = {
    create?: XOR<ClassCreateWithoutTeacherSubjectsInput, ClassUncheckedCreateWithoutTeacherSubjectsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutTeacherSubjectsInput
    upsert?: ClassUpsertWithoutTeacherSubjectsInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutTeacherSubjectsInput, ClassUpdateWithoutTeacherSubjectsInput>, ClassUncheckedUpdateWithoutTeacherSubjectsInput>
  }

  export type AcademicYearUpdateOneRequiredWithoutTeacherSubjectsNestedInput = {
    create?: XOR<AcademicYearCreateWithoutTeacherSubjectsInput, AcademicYearUncheckedCreateWithoutTeacherSubjectsInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutTeacherSubjectsInput
    upsert?: AcademicYearUpsertWithoutTeacherSubjectsInput
    connect?: AcademicYearWhereUniqueInput
    update?: XOR<XOR<AcademicYearUpdateToOneWithWhereWithoutTeacherSubjectsInput, AcademicYearUpdateWithoutTeacherSubjectsInput>, AcademicYearUncheckedUpdateWithoutTeacherSubjectsInput>
  }

  export type UserCreateNestedOneWithoutStudentEnrollmentsInput = {
    create?: XOR<UserCreateWithoutStudentEnrollmentsInput, UserUncheckedCreateWithoutStudentEnrollmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentEnrollmentsInput
    connect?: UserWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutStudentEnrollmentsInput = {
    create?: XOR<ClassCreateWithoutStudentEnrollmentsInput, ClassUncheckedCreateWithoutStudentEnrollmentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutStudentEnrollmentsInput
    connect?: ClassWhereUniqueInput
  }

  export type AcademicYearCreateNestedOneWithoutStudentEnrollmentsInput = {
    create?: XOR<AcademicYearCreateWithoutStudentEnrollmentsInput, AcademicYearUncheckedCreateWithoutStudentEnrollmentsInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutStudentEnrollmentsInput
    connect?: AcademicYearWhereUniqueInput
  }

  export type SemesterCreateNestedOneWithoutStudentEnrollmentsInput = {
    create?: XOR<SemesterCreateWithoutStudentEnrollmentsInput, SemesterUncheckedCreateWithoutStudentEnrollmentsInput>
    connectOrCreate?: SemesterCreateOrConnectWithoutStudentEnrollmentsInput
    connect?: SemesterWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutStudentEnrollmentsNestedInput = {
    create?: XOR<UserCreateWithoutStudentEnrollmentsInput, UserUncheckedCreateWithoutStudentEnrollmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentEnrollmentsInput
    upsert?: UserUpsertWithoutStudentEnrollmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudentEnrollmentsInput, UserUpdateWithoutStudentEnrollmentsInput>, UserUncheckedUpdateWithoutStudentEnrollmentsInput>
  }

  export type ClassUpdateOneRequiredWithoutStudentEnrollmentsNestedInput = {
    create?: XOR<ClassCreateWithoutStudentEnrollmentsInput, ClassUncheckedCreateWithoutStudentEnrollmentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutStudentEnrollmentsInput
    upsert?: ClassUpsertWithoutStudentEnrollmentsInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutStudentEnrollmentsInput, ClassUpdateWithoutStudentEnrollmentsInput>, ClassUncheckedUpdateWithoutStudentEnrollmentsInput>
  }

  export type AcademicYearUpdateOneRequiredWithoutStudentEnrollmentsNestedInput = {
    create?: XOR<AcademicYearCreateWithoutStudentEnrollmentsInput, AcademicYearUncheckedCreateWithoutStudentEnrollmentsInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutStudentEnrollmentsInput
    upsert?: AcademicYearUpsertWithoutStudentEnrollmentsInput
    connect?: AcademicYearWhereUniqueInput
    update?: XOR<XOR<AcademicYearUpdateToOneWithWhereWithoutStudentEnrollmentsInput, AcademicYearUpdateWithoutStudentEnrollmentsInput>, AcademicYearUncheckedUpdateWithoutStudentEnrollmentsInput>
  }

  export type SemesterUpdateOneWithoutStudentEnrollmentsNestedInput = {
    create?: XOR<SemesterCreateWithoutStudentEnrollmentsInput, SemesterUncheckedCreateWithoutStudentEnrollmentsInput>
    connectOrCreate?: SemesterCreateOrConnectWithoutStudentEnrollmentsInput
    upsert?: SemesterUpsertWithoutStudentEnrollmentsInput
    disconnect?: SemesterWhereInput | boolean
    delete?: SemesterWhereInput | boolean
    connect?: SemesterWhereUniqueInput
    update?: XOR<XOR<SemesterUpdateToOneWithWhereWithoutStudentEnrollmentsInput, SemesterUpdateWithoutStudentEnrollmentsInput>, SemesterUncheckedUpdateWithoutStudentEnrollmentsInput>
  }

  export type ClassCreateNestedOneWithoutClassSchedulesInput = {
    create?: XOR<ClassCreateWithoutClassSchedulesInput, ClassUncheckedCreateWithoutClassSchedulesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutClassSchedulesInput
    connect?: ClassWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutClassSchedulesInput = {
    create?: XOR<SubjectCreateWithoutClassSchedulesInput, SubjectUncheckedCreateWithoutClassSchedulesInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutClassSchedulesInput
    connect?: SubjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClassSchedulesInput = {
    create?: XOR<UserCreateWithoutClassSchedulesInput, UserUncheckedCreateWithoutClassSchedulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutClassSchedulesInput
    connect?: UserWhereUniqueInput
  }

  export type ClassUpdateOneRequiredWithoutClassSchedulesNestedInput = {
    create?: XOR<ClassCreateWithoutClassSchedulesInput, ClassUncheckedCreateWithoutClassSchedulesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutClassSchedulesInput
    upsert?: ClassUpsertWithoutClassSchedulesInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutClassSchedulesInput, ClassUpdateWithoutClassSchedulesInput>, ClassUncheckedUpdateWithoutClassSchedulesInput>
  }

  export type SubjectUpdateOneRequiredWithoutClassSchedulesNestedInput = {
    create?: XOR<SubjectCreateWithoutClassSchedulesInput, SubjectUncheckedCreateWithoutClassSchedulesInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutClassSchedulesInput
    upsert?: SubjectUpsertWithoutClassSchedulesInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutClassSchedulesInput, SubjectUpdateWithoutClassSchedulesInput>, SubjectUncheckedUpdateWithoutClassSchedulesInput>
  }

  export type UserUpdateOneRequiredWithoutClassSchedulesNestedInput = {
    create?: XOR<UserCreateWithoutClassSchedulesInput, UserUncheckedCreateWithoutClassSchedulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutClassSchedulesInput
    upsert?: UserUpsertWithoutClassSchedulesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClassSchedulesInput, UserUpdateWithoutClassSchedulesInput>, UserUncheckedUpdateWithoutClassSchedulesInput>
  }

  export type UserCreateNestedOneWithoutAttendanceRecordsAsStudentInput = {
    create?: XOR<UserCreateWithoutAttendanceRecordsAsStudentInput, UserUncheckedCreateWithoutAttendanceRecordsAsStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceRecordsAsStudentInput
    connect?: UserWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutAttendanceRecordsInput = {
    create?: XOR<ClassCreateWithoutAttendanceRecordsInput, ClassUncheckedCreateWithoutAttendanceRecordsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutAttendanceRecordsInput
    connect?: ClassWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutAttendanceRecordsInput = {
    create?: XOR<SubjectCreateWithoutAttendanceRecordsInput, SubjectUncheckedCreateWithoutAttendanceRecordsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutAttendanceRecordsInput
    connect?: SubjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAttendanceRecordsMarkedInput = {
    create?: XOR<UserCreateWithoutAttendanceRecordsMarkedInput, UserUncheckedCreateWithoutAttendanceRecordsMarkedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceRecordsMarkedInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumAttendanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceStatus
  }

  export type UserUpdateOneRequiredWithoutAttendanceRecordsAsStudentNestedInput = {
    create?: XOR<UserCreateWithoutAttendanceRecordsAsStudentInput, UserUncheckedCreateWithoutAttendanceRecordsAsStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceRecordsAsStudentInput
    upsert?: UserUpsertWithoutAttendanceRecordsAsStudentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttendanceRecordsAsStudentInput, UserUpdateWithoutAttendanceRecordsAsStudentInput>, UserUncheckedUpdateWithoutAttendanceRecordsAsStudentInput>
  }

  export type ClassUpdateOneRequiredWithoutAttendanceRecordsNestedInput = {
    create?: XOR<ClassCreateWithoutAttendanceRecordsInput, ClassUncheckedCreateWithoutAttendanceRecordsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutAttendanceRecordsInput
    upsert?: ClassUpsertWithoutAttendanceRecordsInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutAttendanceRecordsInput, ClassUpdateWithoutAttendanceRecordsInput>, ClassUncheckedUpdateWithoutAttendanceRecordsInput>
  }

  export type SubjectUpdateOneRequiredWithoutAttendanceRecordsNestedInput = {
    create?: XOR<SubjectCreateWithoutAttendanceRecordsInput, SubjectUncheckedCreateWithoutAttendanceRecordsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutAttendanceRecordsInput
    upsert?: SubjectUpsertWithoutAttendanceRecordsInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutAttendanceRecordsInput, SubjectUpdateWithoutAttendanceRecordsInput>, SubjectUncheckedUpdateWithoutAttendanceRecordsInput>
  }

  export type UserUpdateOneRequiredWithoutAttendanceRecordsMarkedNestedInput = {
    create?: XOR<UserCreateWithoutAttendanceRecordsMarkedInput, UserUncheckedCreateWithoutAttendanceRecordsMarkedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceRecordsMarkedInput
    upsert?: UserUpsertWithoutAttendanceRecordsMarkedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttendanceRecordsMarkedInput, UserUpdateWithoutAttendanceRecordsMarkedInput>, UserUncheckedUpdateWithoutAttendanceRecordsMarkedInput>
  }

  export type UserCreateNestedOneWithoutAttendanceSummariesInput = {
    create?: XOR<UserCreateWithoutAttendanceSummariesInput, UserUncheckedCreateWithoutAttendanceSummariesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceSummariesInput
    connect?: UserWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutAttendanceSummariesInput = {
    create?: XOR<SubjectCreateWithoutAttendanceSummariesInput, SubjectUncheckedCreateWithoutAttendanceSummariesInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutAttendanceSummariesInput
    connect?: SubjectWhereUniqueInput
  }

  export type SemesterCreateNestedOneWithoutAttendanceSummariesInput = {
    create?: XOR<SemesterCreateWithoutAttendanceSummariesInput, SemesterUncheckedCreateWithoutAttendanceSummariesInput>
    connectOrCreate?: SemesterCreateOrConnectWithoutAttendanceSummariesInput
    connect?: SemesterWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAttendanceSummariesNestedInput = {
    create?: XOR<UserCreateWithoutAttendanceSummariesInput, UserUncheckedCreateWithoutAttendanceSummariesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceSummariesInput
    upsert?: UserUpsertWithoutAttendanceSummariesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttendanceSummariesInput, UserUpdateWithoutAttendanceSummariesInput>, UserUncheckedUpdateWithoutAttendanceSummariesInput>
  }

  export type SubjectUpdateOneRequiredWithoutAttendanceSummariesNestedInput = {
    create?: XOR<SubjectCreateWithoutAttendanceSummariesInput, SubjectUncheckedCreateWithoutAttendanceSummariesInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutAttendanceSummariesInput
    upsert?: SubjectUpsertWithoutAttendanceSummariesInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutAttendanceSummariesInput, SubjectUpdateWithoutAttendanceSummariesInput>, SubjectUncheckedUpdateWithoutAttendanceSummariesInput>
  }

  export type SemesterUpdateOneRequiredWithoutAttendanceSummariesNestedInput = {
    create?: XOR<SemesterCreateWithoutAttendanceSummariesInput, SemesterUncheckedCreateWithoutAttendanceSummariesInput>
    connectOrCreate?: SemesterCreateOrConnectWithoutAttendanceSummariesInput
    upsert?: SemesterUpsertWithoutAttendanceSummariesInput
    connect?: SemesterWhereUniqueInput
    update?: XOR<XOR<SemesterUpdateToOneWithWhereWithoutAttendanceSummariesInput, SemesterUpdateWithoutAttendanceSummariesInput>, SemesterUncheckedUpdateWithoutAttendanceSummariesInput>
  }

  export type ClassCreateNestedOneWithoutGradeCategoriesInput = {
    create?: XOR<ClassCreateWithoutGradeCategoriesInput, ClassUncheckedCreateWithoutGradeCategoriesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutGradeCategoriesInput
    connect?: ClassWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutGradeCategoriesInput = {
    create?: XOR<SubjectCreateWithoutGradeCategoriesInput, SubjectUncheckedCreateWithoutGradeCategoriesInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutGradeCategoriesInput
    connect?: SubjectWhereUniqueInput
  }

  export type GradeEntryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<GradeEntryCreateWithoutCategoryInput, GradeEntryUncheckedCreateWithoutCategoryInput> | GradeEntryCreateWithoutCategoryInput[] | GradeEntryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: GradeEntryCreateOrConnectWithoutCategoryInput | GradeEntryCreateOrConnectWithoutCategoryInput[]
    createMany?: GradeEntryCreateManyCategoryInputEnvelope
    connect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
  }

  export type GradeEntryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<GradeEntryCreateWithoutCategoryInput, GradeEntryUncheckedCreateWithoutCategoryInput> | GradeEntryCreateWithoutCategoryInput[] | GradeEntryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: GradeEntryCreateOrConnectWithoutCategoryInput | GradeEntryCreateOrConnectWithoutCategoryInput[]
    createMany?: GradeEntryCreateManyCategoryInputEnvelope
    connect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClassUpdateOneRequiredWithoutGradeCategoriesNestedInput = {
    create?: XOR<ClassCreateWithoutGradeCategoriesInput, ClassUncheckedCreateWithoutGradeCategoriesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutGradeCategoriesInput
    upsert?: ClassUpsertWithoutGradeCategoriesInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutGradeCategoriesInput, ClassUpdateWithoutGradeCategoriesInput>, ClassUncheckedUpdateWithoutGradeCategoriesInput>
  }

  export type SubjectUpdateOneRequiredWithoutGradeCategoriesNestedInput = {
    create?: XOR<SubjectCreateWithoutGradeCategoriesInput, SubjectUncheckedCreateWithoutGradeCategoriesInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutGradeCategoriesInput
    upsert?: SubjectUpsertWithoutGradeCategoriesInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutGradeCategoriesInput, SubjectUpdateWithoutGradeCategoriesInput>, SubjectUncheckedUpdateWithoutGradeCategoriesInput>
  }

  export type GradeEntryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<GradeEntryCreateWithoutCategoryInput, GradeEntryUncheckedCreateWithoutCategoryInput> | GradeEntryCreateWithoutCategoryInput[] | GradeEntryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: GradeEntryCreateOrConnectWithoutCategoryInput | GradeEntryCreateOrConnectWithoutCategoryInput[]
    upsert?: GradeEntryUpsertWithWhereUniqueWithoutCategoryInput | GradeEntryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: GradeEntryCreateManyCategoryInputEnvelope
    set?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    disconnect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    delete?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    connect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    update?: GradeEntryUpdateWithWhereUniqueWithoutCategoryInput | GradeEntryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: GradeEntryUpdateManyWithWhereWithoutCategoryInput | GradeEntryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: GradeEntryScalarWhereInput | GradeEntryScalarWhereInput[]
  }

  export type GradeEntryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<GradeEntryCreateWithoutCategoryInput, GradeEntryUncheckedCreateWithoutCategoryInput> | GradeEntryCreateWithoutCategoryInput[] | GradeEntryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: GradeEntryCreateOrConnectWithoutCategoryInput | GradeEntryCreateOrConnectWithoutCategoryInput[]
    upsert?: GradeEntryUpsertWithWhereUniqueWithoutCategoryInput | GradeEntryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: GradeEntryCreateManyCategoryInputEnvelope
    set?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    disconnect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    delete?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    connect?: GradeEntryWhereUniqueInput | GradeEntryWhereUniqueInput[]
    update?: GradeEntryUpdateWithWhereUniqueWithoutCategoryInput | GradeEntryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: GradeEntryUpdateManyWithWhereWithoutCategoryInput | GradeEntryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: GradeEntryScalarWhereInput | GradeEntryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutGradeEntriesAsStudentInput = {
    create?: XOR<UserCreateWithoutGradeEntriesAsStudentInput, UserUncheckedCreateWithoutGradeEntriesAsStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutGradeEntriesAsStudentInput
    connect?: UserWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutGradeEntriesInput = {
    create?: XOR<SubjectCreateWithoutGradeEntriesInput, SubjectUncheckedCreateWithoutGradeEntriesInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutGradeEntriesInput
    connect?: SubjectWhereUniqueInput
  }

  export type GradeCategoryCreateNestedOneWithoutGradeEntriesInput = {
    create?: XOR<GradeCategoryCreateWithoutGradeEntriesInput, GradeCategoryUncheckedCreateWithoutGradeEntriesInput>
    connectOrCreate?: GradeCategoryCreateOrConnectWithoutGradeEntriesInput
    connect?: GradeCategoryWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutGradeEntriesInput = {
    create?: XOR<ClassCreateWithoutGradeEntriesInput, ClassUncheckedCreateWithoutGradeEntriesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutGradeEntriesInput
    connect?: ClassWhereUniqueInput
  }

  export type AcademicYearCreateNestedOneWithoutGradeEntriesInput = {
    create?: XOR<AcademicYearCreateWithoutGradeEntriesInput, AcademicYearUncheckedCreateWithoutGradeEntriesInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutGradeEntriesInput
    connect?: AcademicYearWhereUniqueInput
  }

  export type SemesterCreateNestedOneWithoutGradeEntriesInput = {
    create?: XOR<SemesterCreateWithoutGradeEntriesInput, SemesterUncheckedCreateWithoutGradeEntriesInput>
    connectOrCreate?: SemesterCreateOrConnectWithoutGradeEntriesInput
    connect?: SemesterWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGradeEntriesCreatedInput = {
    create?: XOR<UserCreateWithoutGradeEntriesCreatedInput, UserUncheckedCreateWithoutGradeEntriesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutGradeEntriesCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutGradeEntriesAsStudentNestedInput = {
    create?: XOR<UserCreateWithoutGradeEntriesAsStudentInput, UserUncheckedCreateWithoutGradeEntriesAsStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutGradeEntriesAsStudentInput
    upsert?: UserUpsertWithoutGradeEntriesAsStudentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGradeEntriesAsStudentInput, UserUpdateWithoutGradeEntriesAsStudentInput>, UserUncheckedUpdateWithoutGradeEntriesAsStudentInput>
  }

  export type SubjectUpdateOneRequiredWithoutGradeEntriesNestedInput = {
    create?: XOR<SubjectCreateWithoutGradeEntriesInput, SubjectUncheckedCreateWithoutGradeEntriesInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutGradeEntriesInput
    upsert?: SubjectUpsertWithoutGradeEntriesInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutGradeEntriesInput, SubjectUpdateWithoutGradeEntriesInput>, SubjectUncheckedUpdateWithoutGradeEntriesInput>
  }

  export type GradeCategoryUpdateOneRequiredWithoutGradeEntriesNestedInput = {
    create?: XOR<GradeCategoryCreateWithoutGradeEntriesInput, GradeCategoryUncheckedCreateWithoutGradeEntriesInput>
    connectOrCreate?: GradeCategoryCreateOrConnectWithoutGradeEntriesInput
    upsert?: GradeCategoryUpsertWithoutGradeEntriesInput
    connect?: GradeCategoryWhereUniqueInput
    update?: XOR<XOR<GradeCategoryUpdateToOneWithWhereWithoutGradeEntriesInput, GradeCategoryUpdateWithoutGradeEntriesInput>, GradeCategoryUncheckedUpdateWithoutGradeEntriesInput>
  }

  export type ClassUpdateOneRequiredWithoutGradeEntriesNestedInput = {
    create?: XOR<ClassCreateWithoutGradeEntriesInput, ClassUncheckedCreateWithoutGradeEntriesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutGradeEntriesInput
    upsert?: ClassUpsertWithoutGradeEntriesInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutGradeEntriesInput, ClassUpdateWithoutGradeEntriesInput>, ClassUncheckedUpdateWithoutGradeEntriesInput>
  }

  export type AcademicYearUpdateOneRequiredWithoutGradeEntriesNestedInput = {
    create?: XOR<AcademicYearCreateWithoutGradeEntriesInput, AcademicYearUncheckedCreateWithoutGradeEntriesInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutGradeEntriesInput
    upsert?: AcademicYearUpsertWithoutGradeEntriesInput
    connect?: AcademicYearWhereUniqueInput
    update?: XOR<XOR<AcademicYearUpdateToOneWithWhereWithoutGradeEntriesInput, AcademicYearUpdateWithoutGradeEntriesInput>, AcademicYearUncheckedUpdateWithoutGradeEntriesInput>
  }

  export type SemesterUpdateOneRequiredWithoutGradeEntriesNestedInput = {
    create?: XOR<SemesterCreateWithoutGradeEntriesInput, SemesterUncheckedCreateWithoutGradeEntriesInput>
    connectOrCreate?: SemesterCreateOrConnectWithoutGradeEntriesInput
    upsert?: SemesterUpsertWithoutGradeEntriesInput
    connect?: SemesterWhereUniqueInput
    update?: XOR<XOR<SemesterUpdateToOneWithWhereWithoutGradeEntriesInput, SemesterUpdateWithoutGradeEntriesInput>, SemesterUncheckedUpdateWithoutGradeEntriesInput>
  }

  export type UserUpdateOneRequiredWithoutGradeEntriesCreatedNestedInput = {
    create?: XOR<UserCreateWithoutGradeEntriesCreatedInput, UserUncheckedCreateWithoutGradeEntriesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutGradeEntriesCreatedInput
    upsert?: UserUpsertWithoutGradeEntriesCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGradeEntriesCreatedInput, UserUpdateWithoutGradeEntriesCreatedInput>, UserUncheckedUpdateWithoutGradeEntriesCreatedInput>
  }

  export type UserCreateNestedOneWithoutGradeReportsInput = {
    create?: XOR<UserCreateWithoutGradeReportsInput, UserUncheckedCreateWithoutGradeReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGradeReportsInput
    connect?: UserWhereUniqueInput
  }

  export type SemesterCreateNestedOneWithoutGradeReportsInput = {
    create?: XOR<SemesterCreateWithoutGradeReportsInput, SemesterUncheckedCreateWithoutGradeReportsInput>
    connectOrCreate?: SemesterCreateOrConnectWithoutGradeReportsInput
    connect?: SemesterWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutGradeReportsNestedInput = {
    create?: XOR<UserCreateWithoutGradeReportsInput, UserUncheckedCreateWithoutGradeReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGradeReportsInput
    upsert?: UserUpsertWithoutGradeReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGradeReportsInput, UserUpdateWithoutGradeReportsInput>, UserUncheckedUpdateWithoutGradeReportsInput>
  }

  export type SemesterUpdateOneRequiredWithoutGradeReportsNestedInput = {
    create?: XOR<SemesterCreateWithoutGradeReportsInput, SemesterUncheckedCreateWithoutGradeReportsInput>
    connectOrCreate?: SemesterCreateOrConnectWithoutGradeReportsInput
    upsert?: SemesterUpsertWithoutGradeReportsInput
    connect?: SemesterWhereUniqueInput
    update?: XOR<XOR<SemesterUpdateToOneWithWhereWithoutGradeReportsInput, SemesterUpdateWithoutGradeReportsInput>, SemesterUncheckedUpdateWithoutGradeReportsInput>
  }

  export type AnnouncementCreatetargetRolesInput = {
    set: string[]
  }

  export type AnnouncementCreatetargetClassesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutAnnouncementsInput = {
    create?: XOR<UserCreateWithoutAnnouncementsInput, UserUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementsInput
    connect?: UserWhereUniqueInput
  }

  export type AnnouncementUpdatetargetRolesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AnnouncementUpdatetargetClassesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutAnnouncementsNestedInput = {
    create?: XOR<UserCreateWithoutAnnouncementsInput, UserUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementsInput
    upsert?: UserUpsertWithoutAnnouncementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnnouncementsInput, UserUpdateWithoutAnnouncementsInput>, UserUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type UserCreateNestedOneWithoutMessagesSentInput = {
    create?: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesSentInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessagesReceivedInput = {
    create?: XOR<UserCreateWithoutMessagesReceivedInput, UserUncheckedCreateWithoutMessagesReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type MessageCreateNestedOneWithoutChildMessagesInput = {
    create?: XOR<MessageCreateWithoutChildMessagesInput, MessageUncheckedCreateWithoutChildMessagesInput>
    connectOrCreate?: MessageCreateOrConnectWithoutChildMessagesInput
    connect?: MessageWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutParentMessageInput = {
    create?: XOR<MessageCreateWithoutParentMessageInput, MessageUncheckedCreateWithoutParentMessageInput> | MessageCreateWithoutParentMessageInput[] | MessageUncheckedCreateWithoutParentMessageInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutParentMessageInput | MessageCreateOrConnectWithoutParentMessageInput[]
    createMany?: MessageCreateManyParentMessageInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutParentMessageInput = {
    create?: XOR<MessageCreateWithoutParentMessageInput, MessageUncheckedCreateWithoutParentMessageInput> | MessageCreateWithoutParentMessageInput[] | MessageUncheckedCreateWithoutParentMessageInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutParentMessageInput | MessageCreateOrConnectWithoutParentMessageInput[]
    createMany?: MessageCreateManyParentMessageInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutMessagesSentNestedInput = {
    create?: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesSentInput
    upsert?: UserUpsertWithoutMessagesSentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesSentInput, UserUpdateWithoutMessagesSentInput>, UserUncheckedUpdateWithoutMessagesSentInput>
  }

  export type UserUpdateOneRequiredWithoutMessagesReceivedNestedInput = {
    create?: XOR<UserCreateWithoutMessagesReceivedInput, UserUncheckedCreateWithoutMessagesReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesReceivedInput
    upsert?: UserUpsertWithoutMessagesReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesReceivedInput, UserUpdateWithoutMessagesReceivedInput>, UserUncheckedUpdateWithoutMessagesReceivedInput>
  }

  export type MessageUpdateOneWithoutChildMessagesNestedInput = {
    create?: XOR<MessageCreateWithoutChildMessagesInput, MessageUncheckedCreateWithoutChildMessagesInput>
    connectOrCreate?: MessageCreateOrConnectWithoutChildMessagesInput
    upsert?: MessageUpsertWithoutChildMessagesInput
    disconnect?: MessageWhereInput | boolean
    delete?: MessageWhereInput | boolean
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutChildMessagesInput, MessageUpdateWithoutChildMessagesInput>, MessageUncheckedUpdateWithoutChildMessagesInput>
  }

  export type MessageUpdateManyWithoutParentMessageNestedInput = {
    create?: XOR<MessageCreateWithoutParentMessageInput, MessageUncheckedCreateWithoutParentMessageInput> | MessageCreateWithoutParentMessageInput[] | MessageUncheckedCreateWithoutParentMessageInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutParentMessageInput | MessageCreateOrConnectWithoutParentMessageInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutParentMessageInput | MessageUpsertWithWhereUniqueWithoutParentMessageInput[]
    createMany?: MessageCreateManyParentMessageInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutParentMessageInput | MessageUpdateWithWhereUniqueWithoutParentMessageInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutParentMessageInput | MessageUpdateManyWithWhereWithoutParentMessageInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutParentMessageNestedInput = {
    create?: XOR<MessageCreateWithoutParentMessageInput, MessageUncheckedCreateWithoutParentMessageInput> | MessageCreateWithoutParentMessageInput[] | MessageUncheckedCreateWithoutParentMessageInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutParentMessageInput | MessageCreateOrConnectWithoutParentMessageInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutParentMessageInput | MessageUpsertWithWhereUniqueWithoutParentMessageInput[]
    createMany?: MessageCreateManyParentMessageInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutParentMessageInput | MessageUpdateWithWhereUniqueWithoutParentMessageInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutParentMessageInput | MessageUpdateManyWithWhereWithoutParentMessageInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<ClassCreateWithoutDocumentsInput, ClassUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutDocumentsInput
    connect?: ClassWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<SubjectCreateWithoutDocumentsInput, SubjectUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutDocumentsInput
    connect?: SubjectWhereUniqueInput
  }

  export type DocumentPermissionCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentPermissionCreateWithoutDocumentInput, DocumentPermissionUncheckedCreateWithoutDocumentInput> | DocumentPermissionCreateWithoutDocumentInput[] | DocumentPermissionUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentPermissionCreateOrConnectWithoutDocumentInput | DocumentPermissionCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentPermissionCreateManyDocumentInputEnvelope
    connect?: DocumentPermissionWhereUniqueInput | DocumentPermissionWhereUniqueInput[]
  }

  export type DocumentPermissionUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentPermissionCreateWithoutDocumentInput, DocumentPermissionUncheckedCreateWithoutDocumentInput> | DocumentPermissionCreateWithoutDocumentInput[] | DocumentPermissionUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentPermissionCreateOrConnectWithoutDocumentInput | DocumentPermissionCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentPermissionCreateManyDocumentInputEnvelope
    connect?: DocumentPermissionWhereUniqueInput | DocumentPermissionWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    upsert?: UserUpsertWithoutDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentsInput, UserUpdateWithoutDocumentsInput>, UserUncheckedUpdateWithoutDocumentsInput>
  }

  export type ClassUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<ClassCreateWithoutDocumentsInput, ClassUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutDocumentsInput
    upsert?: ClassUpsertWithoutDocumentsInput
    disconnect?: ClassWhereInput | boolean
    delete?: ClassWhereInput | boolean
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutDocumentsInput, ClassUpdateWithoutDocumentsInput>, ClassUncheckedUpdateWithoutDocumentsInput>
  }

  export type SubjectUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<SubjectCreateWithoutDocumentsInput, SubjectUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutDocumentsInput
    upsert?: SubjectUpsertWithoutDocumentsInput
    disconnect?: SubjectWhereInput | boolean
    delete?: SubjectWhereInput | boolean
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutDocumentsInput, SubjectUpdateWithoutDocumentsInput>, SubjectUncheckedUpdateWithoutDocumentsInput>
  }

  export type DocumentPermissionUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentPermissionCreateWithoutDocumentInput, DocumentPermissionUncheckedCreateWithoutDocumentInput> | DocumentPermissionCreateWithoutDocumentInput[] | DocumentPermissionUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentPermissionCreateOrConnectWithoutDocumentInput | DocumentPermissionCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentPermissionUpsertWithWhereUniqueWithoutDocumentInput | DocumentPermissionUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentPermissionCreateManyDocumentInputEnvelope
    set?: DocumentPermissionWhereUniqueInput | DocumentPermissionWhereUniqueInput[]
    disconnect?: DocumentPermissionWhereUniqueInput | DocumentPermissionWhereUniqueInput[]
    delete?: DocumentPermissionWhereUniqueInput | DocumentPermissionWhereUniqueInput[]
    connect?: DocumentPermissionWhereUniqueInput | DocumentPermissionWhereUniqueInput[]
    update?: DocumentPermissionUpdateWithWhereUniqueWithoutDocumentInput | DocumentPermissionUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentPermissionUpdateManyWithWhereWithoutDocumentInput | DocumentPermissionUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentPermissionScalarWhereInput | DocumentPermissionScalarWhereInput[]
  }

  export type DocumentPermissionUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentPermissionCreateWithoutDocumentInput, DocumentPermissionUncheckedCreateWithoutDocumentInput> | DocumentPermissionCreateWithoutDocumentInput[] | DocumentPermissionUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentPermissionCreateOrConnectWithoutDocumentInput | DocumentPermissionCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentPermissionUpsertWithWhereUniqueWithoutDocumentInput | DocumentPermissionUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentPermissionCreateManyDocumentInputEnvelope
    set?: DocumentPermissionWhereUniqueInput | DocumentPermissionWhereUniqueInput[]
    disconnect?: DocumentPermissionWhereUniqueInput | DocumentPermissionWhereUniqueInput[]
    delete?: DocumentPermissionWhereUniqueInput | DocumentPermissionWhereUniqueInput[]
    connect?: DocumentPermissionWhereUniqueInput | DocumentPermissionWhereUniqueInput[]
    update?: DocumentPermissionUpdateWithWhereUniqueWithoutDocumentInput | DocumentPermissionUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentPermissionUpdateManyWithWhereWithoutDocumentInput | DocumentPermissionUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentPermissionScalarWhereInput | DocumentPermissionScalarWhereInput[]
  }

  export type DocumentCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<DocumentCreateWithoutPermissionsInput, DocumentUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutPermissionsInput
    connect?: DocumentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDocumentPermissionsInput = {
    create?: XOR<UserCreateWithoutDocumentPermissionsInput, UserUncheckedCreateWithoutDocumentPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentPermissionsInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<DocumentCreateWithoutPermissionsInput, DocumentUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutPermissionsInput
    upsert?: DocumentUpsertWithoutPermissionsInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutPermissionsInput, DocumentUpdateWithoutPermissionsInput>, DocumentUncheckedUpdateWithoutPermissionsInput>
  }

  export type UserUpdateOneRequiredWithoutDocumentPermissionsNestedInput = {
    create?: XOR<UserCreateWithoutDocumentPermissionsInput, UserUncheckedCreateWithoutDocumentPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentPermissionsInput
    upsert?: UserUpsertWithoutDocumentPermissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentPermissionsInput, UserUpdateWithoutDocumentPermissionsInput>, UserUncheckedUpdateWithoutDocumentPermissionsInput>
  }

  export type UserCreateNestedOneWithoutRegistrationRequestsInput = {
    create?: XOR<UserCreateWithoutRegistrationRequestsInput, UserUncheckedCreateWithoutRegistrationRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRegistrationRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type SemesterCreateNestedOneWithoutRegistrationRequestsInput = {
    create?: XOR<SemesterCreateWithoutRegistrationRequestsInput, SemesterUncheckedCreateWithoutRegistrationRequestsInput>
    connectOrCreate?: SemesterCreateOrConnectWithoutRegistrationRequestsInput
    connect?: SemesterWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRegistrationRequestsNestedInput = {
    create?: XOR<UserCreateWithoutRegistrationRequestsInput, UserUncheckedCreateWithoutRegistrationRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRegistrationRequestsInput
    upsert?: UserUpsertWithoutRegistrationRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRegistrationRequestsInput, UserUpdateWithoutRegistrationRequestsInput>, UserUncheckedUpdateWithoutRegistrationRequestsInput>
  }

  export type SemesterUpdateOneRequiredWithoutRegistrationRequestsNestedInput = {
    create?: XOR<SemesterCreateWithoutRegistrationRequestsInput, SemesterUncheckedCreateWithoutRegistrationRequestsInput>
    connectOrCreate?: SemesterCreateOrConnectWithoutRegistrationRequestsInput
    upsert?: SemesterUpsertWithoutRegistrationRequestsInput
    connect?: SemesterWhereUniqueInput
    update?: XOR<XOR<SemesterUpdateToOneWithWhereWithoutRegistrationRequestsInput, SemesterUpdateWithoutRegistrationRequestsInput>, SemesterUncheckedUpdateWithoutRegistrationRequestsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserSessionCreateWithoutUserInput = {
    sessionId?: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type UserSessionUncheckedCreateWithoutUserInput = {
    sessionId?: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type UserSessionCreateOrConnectWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateManyUserInputEnvelope = {
    data: UserSessionCreateManyUserInput | UserSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AnnouncementCreateWithoutAuthorInput = {
    id?: string
    title: string
    content: string
    targetRoles?: AnnouncementCreatetargetRolesInput | string[]
    targetClasses?: AnnouncementCreatetargetClassesInput | string[]
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type AnnouncementUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    content: string
    targetRoles?: AnnouncementCreatetargetRolesInput | string[]
    targetClasses?: AnnouncementCreatetargetClassesInput | string[]
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type AnnouncementCreateOrConnectWithoutAuthorInput = {
    where: AnnouncementWhereUniqueInput
    create: XOR<AnnouncementCreateWithoutAuthorInput, AnnouncementUncheckedCreateWithoutAuthorInput>
  }

  export type AnnouncementCreateManyAuthorInputEnvelope = {
    data: AnnouncementCreateManyAuthorInput | AnnouncementCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    subject: string
    content: string
    isRead?: boolean
    sentAt?: Date | string
    recipient: UserCreateNestedOneWithoutMessagesReceivedInput
    parentMessage?: MessageCreateNestedOneWithoutChildMessagesInput
    childMessages?: MessageCreateNestedManyWithoutParentMessageInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    recipientId: string
    subject: string
    content: string
    isRead?: boolean
    sentAt?: Date | string
    parentMessageId?: string | null
    childMessages?: MessageUncheckedCreateNestedManyWithoutParentMessageInput
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutRecipientInput = {
    id?: string
    subject: string
    content: string
    isRead?: boolean
    sentAt?: Date | string
    sender: UserCreateNestedOneWithoutMessagesSentInput
    parentMessage?: MessageCreateNestedOneWithoutChildMessagesInput
    childMessages?: MessageCreateNestedManyWithoutParentMessageInput
  }

  export type MessageUncheckedCreateWithoutRecipientInput = {
    id?: string
    senderId: string
    subject: string
    content: string
    isRead?: boolean
    sentAt?: Date | string
    parentMessageId?: string | null
    childMessages?: MessageUncheckedCreateNestedManyWithoutParentMessageInput
  }

  export type MessageCreateOrConnectWithoutRecipientInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput>
  }

  export type MessageCreateManyRecipientInputEnvelope = {
    data: MessageCreateManyRecipientInput | MessageCreateManyRecipientInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    content: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    content: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutUploadedByInput = {
    id?: string
    title: string
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    category: string
    uploadedAt?: Date | string
    class?: ClassCreateNestedOneWithoutDocumentsInput
    subject?: SubjectCreateNestedOneWithoutDocumentsInput
    permissions?: DocumentPermissionCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutUploadedByInput = {
    id?: string
    title: string
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    category: string
    classId?: string | null
    subjectId?: string | null
    uploadedAt?: Date | string
    permissions?: DocumentPermissionUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutUploadedByInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput>
  }

  export type DocumentCreateManyUploadedByInputEnvelope = {
    data: DocumentCreateManyUploadedByInput | DocumentCreateManyUploadedByInput[]
    skipDuplicates?: boolean
  }

  export type DocumentPermissionCreateWithoutUserInput = {
    id?: string
    permissionType: string
    document: DocumentCreateNestedOneWithoutPermissionsInput
  }

  export type DocumentPermissionUncheckedCreateWithoutUserInput = {
    id?: string
    documentId: string
    permissionType: string
  }

  export type DocumentPermissionCreateOrConnectWithoutUserInput = {
    where: DocumentPermissionWhereUniqueInput
    create: XOR<DocumentPermissionCreateWithoutUserInput, DocumentPermissionUncheckedCreateWithoutUserInput>
  }

  export type DocumentPermissionCreateManyUserInputEnvelope = {
    data: DocumentPermissionCreateManyUserInput | DocumentPermissionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TeacherSubjectCreateWithoutTeacherInput = {
    id?: string
    subject: SubjectCreateNestedOneWithoutTeacherSubjectsInput
    class: ClassCreateNestedOneWithoutTeacherSubjectsInput
    academicYear: AcademicYearCreateNestedOneWithoutTeacherSubjectsInput
  }

  export type TeacherSubjectUncheckedCreateWithoutTeacherInput = {
    id?: string
    subjectId: string
    classId: string
    academicYearId: string
  }

  export type TeacherSubjectCreateOrConnectWithoutTeacherInput = {
    where: TeacherSubjectWhereUniqueInput
    create: XOR<TeacherSubjectCreateWithoutTeacherInput, TeacherSubjectUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherSubjectCreateManyTeacherInputEnvelope = {
    data: TeacherSubjectCreateManyTeacherInput | TeacherSubjectCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type StudentEnrollmentCreateWithoutStudentInput = {
    id?: string
    enrollmentDate?: Date | string
    class: ClassCreateNestedOneWithoutStudentEnrollmentsInput
    academicYear: AcademicYearCreateNestedOneWithoutStudentEnrollmentsInput
    semester?: SemesterCreateNestedOneWithoutStudentEnrollmentsInput
  }

  export type StudentEnrollmentUncheckedCreateWithoutStudentInput = {
    id?: string
    classId: string
    academicYearId: string
    semesterId?: string | null
    enrollmentDate?: Date | string
  }

  export type StudentEnrollmentCreateOrConnectWithoutStudentInput = {
    where: StudentEnrollmentWhereUniqueInput
    create: XOR<StudentEnrollmentCreateWithoutStudentInput, StudentEnrollmentUncheckedCreateWithoutStudentInput>
  }

  export type StudentEnrollmentCreateManyStudentInputEnvelope = {
    data: StudentEnrollmentCreateManyStudentInput | StudentEnrollmentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type ClassScheduleCreateWithoutTeacherInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    class: ClassCreateNestedOneWithoutClassSchedulesInput
    subject: SubjectCreateNestedOneWithoutClassSchedulesInput
  }

  export type ClassScheduleUncheckedCreateWithoutTeacherInput = {
    id?: string
    classId: string
    subjectId: string
    dayOfWeek: number
    startTime: string
    endTime: string
  }

  export type ClassScheduleCreateOrConnectWithoutTeacherInput = {
    where: ClassScheduleWhereUniqueInput
    create: XOR<ClassScheduleCreateWithoutTeacherInput, ClassScheduleUncheckedCreateWithoutTeacherInput>
  }

  export type ClassScheduleCreateManyTeacherInputEnvelope = {
    data: ClassScheduleCreateManyTeacherInput | ClassScheduleCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceRecordCreateWithoutStudentInput = {
    id?: string
    date: Date | string
    period?: number | null
    status: $Enums.AttendanceStatus
    markedAt?: Date | string
    remarks?: string | null
    class: ClassCreateNestedOneWithoutAttendanceRecordsInput
    subject: SubjectCreateNestedOneWithoutAttendanceRecordsInput
    markedBy: UserCreateNestedOneWithoutAttendanceRecordsMarkedInput
  }

  export type AttendanceRecordUncheckedCreateWithoutStudentInput = {
    id?: string
    classId: string
    subjectId: string
    date: Date | string
    period?: number | null
    status: $Enums.AttendanceStatus
    markedById: string
    markedAt?: Date | string
    remarks?: string | null
  }

  export type AttendanceRecordCreateOrConnectWithoutStudentInput = {
    where: AttendanceRecordWhereUniqueInput
    create: XOR<AttendanceRecordCreateWithoutStudentInput, AttendanceRecordUncheckedCreateWithoutStudentInput>
  }

  export type AttendanceRecordCreateManyStudentInputEnvelope = {
    data: AttendanceRecordCreateManyStudentInput | AttendanceRecordCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceRecordCreateWithoutMarkedByInput = {
    id?: string
    date: Date | string
    period?: number | null
    status: $Enums.AttendanceStatus
    markedAt?: Date | string
    remarks?: string | null
    student: UserCreateNestedOneWithoutAttendanceRecordsAsStudentInput
    class: ClassCreateNestedOneWithoutAttendanceRecordsInput
    subject: SubjectCreateNestedOneWithoutAttendanceRecordsInput
  }

  export type AttendanceRecordUncheckedCreateWithoutMarkedByInput = {
    id?: string
    studentId: string
    classId: string
    subjectId: string
    date: Date | string
    period?: number | null
    status: $Enums.AttendanceStatus
    markedAt?: Date | string
    remarks?: string | null
  }

  export type AttendanceRecordCreateOrConnectWithoutMarkedByInput = {
    where: AttendanceRecordWhereUniqueInput
    create: XOR<AttendanceRecordCreateWithoutMarkedByInput, AttendanceRecordUncheckedCreateWithoutMarkedByInput>
  }

  export type AttendanceRecordCreateManyMarkedByInputEnvelope = {
    data: AttendanceRecordCreateManyMarkedByInput | AttendanceRecordCreateManyMarkedByInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceSummaryCreateWithoutStudentInput = {
    id?: string
    totalClasses: number
    presentCount: number
    absentCount: number
    lateCount: number
    subject: SubjectCreateNestedOneWithoutAttendanceSummariesInput
    semester: SemesterCreateNestedOneWithoutAttendanceSummariesInput
  }

  export type AttendanceSummaryUncheckedCreateWithoutStudentInput = {
    id?: string
    subjectId: string
    semesterId: string
    totalClasses: number
    presentCount: number
    absentCount: number
    lateCount: number
  }

  export type AttendanceSummaryCreateOrConnectWithoutStudentInput = {
    where: AttendanceSummaryWhereUniqueInput
    create: XOR<AttendanceSummaryCreateWithoutStudentInput, AttendanceSummaryUncheckedCreateWithoutStudentInput>
  }

  export type AttendanceSummaryCreateManyStudentInputEnvelope = {
    data: AttendanceSummaryCreateManyStudentInput | AttendanceSummaryCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type GradeEntryCreateWithoutStudentInput = {
    id?: string
    pointsEarned: number
    totalPoints: number
    date: Date | string
    subject: SubjectCreateNestedOneWithoutGradeEntriesInput
    category: GradeCategoryCreateNestedOneWithoutGradeEntriesInput
    class: ClassCreateNestedOneWithoutGradeEntriesInput
    academicYear: AcademicYearCreateNestedOneWithoutGradeEntriesInput
    semester: SemesterCreateNestedOneWithoutGradeEntriesInput
    createdBy: UserCreateNestedOneWithoutGradeEntriesCreatedInput
  }

  export type GradeEntryUncheckedCreateWithoutStudentInput = {
    id?: string
    subjectId: string
    categoryId: string
    classId: string
    academicYearId: string
    pointsEarned: number
    totalPoints: number
    date: Date | string
    semesterId: string
    createdById: string
  }

  export type GradeEntryCreateOrConnectWithoutStudentInput = {
    where: GradeEntryWhereUniqueInput
    create: XOR<GradeEntryCreateWithoutStudentInput, GradeEntryUncheckedCreateWithoutStudentInput>
  }

  export type GradeEntryCreateManyStudentInputEnvelope = {
    data: GradeEntryCreateManyStudentInput | GradeEntryCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type GradeEntryCreateWithoutCreatedByInput = {
    id?: string
    pointsEarned: number
    totalPoints: number
    date: Date | string
    student: UserCreateNestedOneWithoutGradeEntriesAsStudentInput
    subject: SubjectCreateNestedOneWithoutGradeEntriesInput
    category: GradeCategoryCreateNestedOneWithoutGradeEntriesInput
    class: ClassCreateNestedOneWithoutGradeEntriesInput
    academicYear: AcademicYearCreateNestedOneWithoutGradeEntriesInput
    semester: SemesterCreateNestedOneWithoutGradeEntriesInput
  }

  export type GradeEntryUncheckedCreateWithoutCreatedByInput = {
    id?: string
    studentId: string
    subjectId: string
    categoryId: string
    classId: string
    academicYearId: string
    pointsEarned: number
    totalPoints: number
    date: Date | string
    semesterId: string
  }

  export type GradeEntryCreateOrConnectWithoutCreatedByInput = {
    where: GradeEntryWhereUniqueInput
    create: XOR<GradeEntryCreateWithoutCreatedByInput, GradeEntryUncheckedCreateWithoutCreatedByInput>
  }

  export type GradeEntryCreateManyCreatedByInputEnvelope = {
    data: GradeEntryCreateManyCreatedByInput | GradeEntryCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type GradeReportCreateWithoutStudentInput = {
    id?: string
    overallGpa: number
    generatedAt?: Date | string
    semester: SemesterCreateNestedOneWithoutGradeReportsInput
  }

  export type GradeReportUncheckedCreateWithoutStudentInput = {
    id?: string
    semesterId: string
    overallGpa: number
    generatedAt?: Date | string
  }

  export type GradeReportCreateOrConnectWithoutStudentInput = {
    where: GradeReportWhereUniqueInput
    create: XOR<GradeReportCreateWithoutStudentInput, GradeReportUncheckedCreateWithoutStudentInput>
  }

  export type GradeReportCreateManyStudentInputEnvelope = {
    data: GradeReportCreateManyStudentInput | GradeReportCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentRegistrationRequestCreateWithoutStudentInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    approvedAt?: Date | string | null
    adminId?: string | null
    semester: SemesterCreateNestedOneWithoutRegistrationRequestsInput
  }

  export type StudentRegistrationRequestUncheckedCreateWithoutStudentInput = {
    id?: string
    semesterId: string
    status?: string
    createdAt?: Date | string
    approvedAt?: Date | string | null
    adminId?: string | null
  }

  export type StudentRegistrationRequestCreateOrConnectWithoutStudentInput = {
    where: StudentRegistrationRequestWhereUniqueInput
    create: XOR<StudentRegistrationRequestCreateWithoutStudentInput, StudentRegistrationRequestUncheckedCreateWithoutStudentInput>
  }

  export type StudentRegistrationRequestCreateManyStudentInputEnvelope = {
    data: StudentRegistrationRequestCreateManyStudentInput | StudentRegistrationRequestCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type UserSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    update: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    data: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithWhereWithoutUserInput = {
    where: UserSessionScalarWhereInput
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSessionScalarWhereInput = {
    AND?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    OR?: UserSessionScalarWhereInput[]
    NOT?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    sessionId?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
  }

  export type AnnouncementUpsertWithWhereUniqueWithoutAuthorInput = {
    where: AnnouncementWhereUniqueInput
    update: XOR<AnnouncementUpdateWithoutAuthorInput, AnnouncementUncheckedUpdateWithoutAuthorInput>
    create: XOR<AnnouncementCreateWithoutAuthorInput, AnnouncementUncheckedCreateWithoutAuthorInput>
  }

  export type AnnouncementUpdateWithWhereUniqueWithoutAuthorInput = {
    where: AnnouncementWhereUniqueInput
    data: XOR<AnnouncementUpdateWithoutAuthorInput, AnnouncementUncheckedUpdateWithoutAuthorInput>
  }

  export type AnnouncementUpdateManyWithWhereWithoutAuthorInput = {
    where: AnnouncementScalarWhereInput
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyWithoutAuthorInput>
  }

  export type AnnouncementScalarWhereInput = {
    AND?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
    OR?: AnnouncementScalarWhereInput[]
    NOT?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
    id?: StringFilter<"Announcement"> | string
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    authorId?: StringFilter<"Announcement"> | string
    targetRoles?: StringNullableListFilter<"Announcement">
    targetClasses?: StringNullableListFilter<"Announcement">
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Announcement"> | Date | string | null
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    recipientId?: StringFilter<"Message"> | string
    subject?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    sentAt?: DateTimeFilter<"Message"> | Date | string
    parentMessageId?: StringNullableFilter<"Message"> | string | null
  }

  export type MessageUpsertWithWhereUniqueWithoutRecipientInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutRecipientInput, MessageUncheckedUpdateWithoutRecipientInput>
    create: XOR<MessageCreateWithoutRecipientInput, MessageUncheckedCreateWithoutRecipientInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutRecipientInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutRecipientInput, MessageUncheckedUpdateWithoutRecipientInput>
  }

  export type MessageUpdateManyWithWhereWithoutRecipientInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutRecipientInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutUploadedByInput, DocumentUncheckedUpdateWithoutUploadedByInput>
    create: XOR<DocumentCreateWithoutUploadedByInput, DocumentUncheckedCreateWithoutUploadedByInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutUploadedByInput, DocumentUncheckedUpdateWithoutUploadedByInput>
  }

  export type DocumentUpdateManyWithWhereWithoutUploadedByInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    title?: StringFilter<"Document"> | string
    fileName?: StringFilter<"Document"> | string
    filePath?: StringFilter<"Document"> | string
    fileSize?: IntFilter<"Document"> | number
    mimeType?: StringFilter<"Document"> | string
    uploadedById?: StringFilter<"Document"> | string
    category?: StringFilter<"Document"> | string
    classId?: StringNullableFilter<"Document"> | string | null
    subjectId?: StringNullableFilter<"Document"> | string | null
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
  }

  export type DocumentPermissionUpsertWithWhereUniqueWithoutUserInput = {
    where: DocumentPermissionWhereUniqueInput
    update: XOR<DocumentPermissionUpdateWithoutUserInput, DocumentPermissionUncheckedUpdateWithoutUserInput>
    create: XOR<DocumentPermissionCreateWithoutUserInput, DocumentPermissionUncheckedCreateWithoutUserInput>
  }

  export type DocumentPermissionUpdateWithWhereUniqueWithoutUserInput = {
    where: DocumentPermissionWhereUniqueInput
    data: XOR<DocumentPermissionUpdateWithoutUserInput, DocumentPermissionUncheckedUpdateWithoutUserInput>
  }

  export type DocumentPermissionUpdateManyWithWhereWithoutUserInput = {
    where: DocumentPermissionScalarWhereInput
    data: XOR<DocumentPermissionUpdateManyMutationInput, DocumentPermissionUncheckedUpdateManyWithoutUserInput>
  }

  export type DocumentPermissionScalarWhereInput = {
    AND?: DocumentPermissionScalarWhereInput | DocumentPermissionScalarWhereInput[]
    OR?: DocumentPermissionScalarWhereInput[]
    NOT?: DocumentPermissionScalarWhereInput | DocumentPermissionScalarWhereInput[]
    id?: StringFilter<"DocumentPermission"> | string
    documentId?: StringFilter<"DocumentPermission"> | string
    userId?: StringFilter<"DocumentPermission"> | string
    permissionType?: StringFilter<"DocumentPermission"> | string
  }

  export type TeacherSubjectUpsertWithWhereUniqueWithoutTeacherInput = {
    where: TeacherSubjectWhereUniqueInput
    update: XOR<TeacherSubjectUpdateWithoutTeacherInput, TeacherSubjectUncheckedUpdateWithoutTeacherInput>
    create: XOR<TeacherSubjectCreateWithoutTeacherInput, TeacherSubjectUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherSubjectUpdateWithWhereUniqueWithoutTeacherInput = {
    where: TeacherSubjectWhereUniqueInput
    data: XOR<TeacherSubjectUpdateWithoutTeacherInput, TeacherSubjectUncheckedUpdateWithoutTeacherInput>
  }

  export type TeacherSubjectUpdateManyWithWhereWithoutTeacherInput = {
    where: TeacherSubjectScalarWhereInput
    data: XOR<TeacherSubjectUpdateManyMutationInput, TeacherSubjectUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TeacherSubjectScalarWhereInput = {
    AND?: TeacherSubjectScalarWhereInput | TeacherSubjectScalarWhereInput[]
    OR?: TeacherSubjectScalarWhereInput[]
    NOT?: TeacherSubjectScalarWhereInput | TeacherSubjectScalarWhereInput[]
    id?: StringFilter<"TeacherSubject"> | string
    teacherId?: StringFilter<"TeacherSubject"> | string
    subjectId?: StringFilter<"TeacherSubject"> | string
    classId?: StringFilter<"TeacherSubject"> | string
    academicYearId?: StringFilter<"TeacherSubject"> | string
  }

  export type StudentEnrollmentUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentEnrollmentWhereUniqueInput
    update: XOR<StudentEnrollmentUpdateWithoutStudentInput, StudentEnrollmentUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentEnrollmentCreateWithoutStudentInput, StudentEnrollmentUncheckedCreateWithoutStudentInput>
  }

  export type StudentEnrollmentUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentEnrollmentWhereUniqueInput
    data: XOR<StudentEnrollmentUpdateWithoutStudentInput, StudentEnrollmentUncheckedUpdateWithoutStudentInput>
  }

  export type StudentEnrollmentUpdateManyWithWhereWithoutStudentInput = {
    where: StudentEnrollmentScalarWhereInput
    data: XOR<StudentEnrollmentUpdateManyMutationInput, StudentEnrollmentUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentEnrollmentScalarWhereInput = {
    AND?: StudentEnrollmentScalarWhereInput | StudentEnrollmentScalarWhereInput[]
    OR?: StudentEnrollmentScalarWhereInput[]
    NOT?: StudentEnrollmentScalarWhereInput | StudentEnrollmentScalarWhereInput[]
    id?: StringFilter<"StudentEnrollment"> | string
    studentId?: StringFilter<"StudentEnrollment"> | string
    classId?: StringFilter<"StudentEnrollment"> | string
    academicYearId?: StringFilter<"StudentEnrollment"> | string
    semesterId?: StringNullableFilter<"StudentEnrollment"> | string | null
    enrollmentDate?: DateTimeFilter<"StudentEnrollment"> | Date | string
  }

  export type ClassScheduleUpsertWithWhereUniqueWithoutTeacherInput = {
    where: ClassScheduleWhereUniqueInput
    update: XOR<ClassScheduleUpdateWithoutTeacherInput, ClassScheduleUncheckedUpdateWithoutTeacherInput>
    create: XOR<ClassScheduleCreateWithoutTeacherInput, ClassScheduleUncheckedCreateWithoutTeacherInput>
  }

  export type ClassScheduleUpdateWithWhereUniqueWithoutTeacherInput = {
    where: ClassScheduleWhereUniqueInput
    data: XOR<ClassScheduleUpdateWithoutTeacherInput, ClassScheduleUncheckedUpdateWithoutTeacherInput>
  }

  export type ClassScheduleUpdateManyWithWhereWithoutTeacherInput = {
    where: ClassScheduleScalarWhereInput
    data: XOR<ClassScheduleUpdateManyMutationInput, ClassScheduleUncheckedUpdateManyWithoutTeacherInput>
  }

  export type ClassScheduleScalarWhereInput = {
    AND?: ClassScheduleScalarWhereInput | ClassScheduleScalarWhereInput[]
    OR?: ClassScheduleScalarWhereInput[]
    NOT?: ClassScheduleScalarWhereInput | ClassScheduleScalarWhereInput[]
    id?: StringFilter<"ClassSchedule"> | string
    classId?: StringFilter<"ClassSchedule"> | string
    subjectId?: StringFilter<"ClassSchedule"> | string
    teacherId?: StringFilter<"ClassSchedule"> | string
    dayOfWeek?: IntFilter<"ClassSchedule"> | number
    startTime?: StringFilter<"ClassSchedule"> | string
    endTime?: StringFilter<"ClassSchedule"> | string
  }

  export type AttendanceRecordUpsertWithWhereUniqueWithoutStudentInput = {
    where: AttendanceRecordWhereUniqueInput
    update: XOR<AttendanceRecordUpdateWithoutStudentInput, AttendanceRecordUncheckedUpdateWithoutStudentInput>
    create: XOR<AttendanceRecordCreateWithoutStudentInput, AttendanceRecordUncheckedCreateWithoutStudentInput>
  }

  export type AttendanceRecordUpdateWithWhereUniqueWithoutStudentInput = {
    where: AttendanceRecordWhereUniqueInput
    data: XOR<AttendanceRecordUpdateWithoutStudentInput, AttendanceRecordUncheckedUpdateWithoutStudentInput>
  }

  export type AttendanceRecordUpdateManyWithWhereWithoutStudentInput = {
    where: AttendanceRecordScalarWhereInput
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyWithoutStudentInput>
  }

  export type AttendanceRecordScalarWhereInput = {
    AND?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
    OR?: AttendanceRecordScalarWhereInput[]
    NOT?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
    id?: StringFilter<"AttendanceRecord"> | string
    studentId?: StringFilter<"AttendanceRecord"> | string
    classId?: StringFilter<"AttendanceRecord"> | string
    subjectId?: StringFilter<"AttendanceRecord"> | string
    date?: DateTimeFilter<"AttendanceRecord"> | Date | string
    period?: IntNullableFilter<"AttendanceRecord"> | number | null
    status?: EnumAttendanceStatusFilter<"AttendanceRecord"> | $Enums.AttendanceStatus
    markedById?: StringFilter<"AttendanceRecord"> | string
    markedAt?: DateTimeFilter<"AttendanceRecord"> | Date | string
    remarks?: StringNullableFilter<"AttendanceRecord"> | string | null
  }

  export type AttendanceRecordUpsertWithWhereUniqueWithoutMarkedByInput = {
    where: AttendanceRecordWhereUniqueInput
    update: XOR<AttendanceRecordUpdateWithoutMarkedByInput, AttendanceRecordUncheckedUpdateWithoutMarkedByInput>
    create: XOR<AttendanceRecordCreateWithoutMarkedByInput, AttendanceRecordUncheckedCreateWithoutMarkedByInput>
  }

  export type AttendanceRecordUpdateWithWhereUniqueWithoutMarkedByInput = {
    where: AttendanceRecordWhereUniqueInput
    data: XOR<AttendanceRecordUpdateWithoutMarkedByInput, AttendanceRecordUncheckedUpdateWithoutMarkedByInput>
  }

  export type AttendanceRecordUpdateManyWithWhereWithoutMarkedByInput = {
    where: AttendanceRecordScalarWhereInput
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyWithoutMarkedByInput>
  }

  export type AttendanceSummaryUpsertWithWhereUniqueWithoutStudentInput = {
    where: AttendanceSummaryWhereUniqueInput
    update: XOR<AttendanceSummaryUpdateWithoutStudentInput, AttendanceSummaryUncheckedUpdateWithoutStudentInput>
    create: XOR<AttendanceSummaryCreateWithoutStudentInput, AttendanceSummaryUncheckedCreateWithoutStudentInput>
  }

  export type AttendanceSummaryUpdateWithWhereUniqueWithoutStudentInput = {
    where: AttendanceSummaryWhereUniqueInput
    data: XOR<AttendanceSummaryUpdateWithoutStudentInput, AttendanceSummaryUncheckedUpdateWithoutStudentInput>
  }

  export type AttendanceSummaryUpdateManyWithWhereWithoutStudentInput = {
    where: AttendanceSummaryScalarWhereInput
    data: XOR<AttendanceSummaryUpdateManyMutationInput, AttendanceSummaryUncheckedUpdateManyWithoutStudentInput>
  }

  export type AttendanceSummaryScalarWhereInput = {
    AND?: AttendanceSummaryScalarWhereInput | AttendanceSummaryScalarWhereInput[]
    OR?: AttendanceSummaryScalarWhereInput[]
    NOT?: AttendanceSummaryScalarWhereInput | AttendanceSummaryScalarWhereInput[]
    id?: StringFilter<"AttendanceSummary"> | string
    studentId?: StringFilter<"AttendanceSummary"> | string
    subjectId?: StringFilter<"AttendanceSummary"> | string
    semesterId?: StringFilter<"AttendanceSummary"> | string
    totalClasses?: IntFilter<"AttendanceSummary"> | number
    presentCount?: IntFilter<"AttendanceSummary"> | number
    absentCount?: IntFilter<"AttendanceSummary"> | number
    lateCount?: IntFilter<"AttendanceSummary"> | number
  }

  export type GradeEntryUpsertWithWhereUniqueWithoutStudentInput = {
    where: GradeEntryWhereUniqueInput
    update: XOR<GradeEntryUpdateWithoutStudentInput, GradeEntryUncheckedUpdateWithoutStudentInput>
    create: XOR<GradeEntryCreateWithoutStudentInput, GradeEntryUncheckedCreateWithoutStudentInput>
  }

  export type GradeEntryUpdateWithWhereUniqueWithoutStudentInput = {
    where: GradeEntryWhereUniqueInput
    data: XOR<GradeEntryUpdateWithoutStudentInput, GradeEntryUncheckedUpdateWithoutStudentInput>
  }

  export type GradeEntryUpdateManyWithWhereWithoutStudentInput = {
    where: GradeEntryScalarWhereInput
    data: XOR<GradeEntryUpdateManyMutationInput, GradeEntryUncheckedUpdateManyWithoutStudentInput>
  }

  export type GradeEntryScalarWhereInput = {
    AND?: GradeEntryScalarWhereInput | GradeEntryScalarWhereInput[]
    OR?: GradeEntryScalarWhereInput[]
    NOT?: GradeEntryScalarWhereInput | GradeEntryScalarWhereInput[]
    id?: StringFilter<"GradeEntry"> | string
    studentId?: StringFilter<"GradeEntry"> | string
    subjectId?: StringFilter<"GradeEntry"> | string
    categoryId?: StringFilter<"GradeEntry"> | string
    classId?: StringFilter<"GradeEntry"> | string
    academicYearId?: StringFilter<"GradeEntry"> | string
    pointsEarned?: FloatFilter<"GradeEntry"> | number
    totalPoints?: FloatFilter<"GradeEntry"> | number
    date?: DateTimeFilter<"GradeEntry"> | Date | string
    semesterId?: StringFilter<"GradeEntry"> | string
    createdById?: StringFilter<"GradeEntry"> | string
  }

  export type GradeEntryUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: GradeEntryWhereUniqueInput
    update: XOR<GradeEntryUpdateWithoutCreatedByInput, GradeEntryUncheckedUpdateWithoutCreatedByInput>
    create: XOR<GradeEntryCreateWithoutCreatedByInput, GradeEntryUncheckedCreateWithoutCreatedByInput>
  }

  export type GradeEntryUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: GradeEntryWhereUniqueInput
    data: XOR<GradeEntryUpdateWithoutCreatedByInput, GradeEntryUncheckedUpdateWithoutCreatedByInput>
  }

  export type GradeEntryUpdateManyWithWhereWithoutCreatedByInput = {
    where: GradeEntryScalarWhereInput
    data: XOR<GradeEntryUpdateManyMutationInput, GradeEntryUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type GradeReportUpsertWithWhereUniqueWithoutStudentInput = {
    where: GradeReportWhereUniqueInput
    update: XOR<GradeReportUpdateWithoutStudentInput, GradeReportUncheckedUpdateWithoutStudentInput>
    create: XOR<GradeReportCreateWithoutStudentInput, GradeReportUncheckedCreateWithoutStudentInput>
  }

  export type GradeReportUpdateWithWhereUniqueWithoutStudentInput = {
    where: GradeReportWhereUniqueInput
    data: XOR<GradeReportUpdateWithoutStudentInput, GradeReportUncheckedUpdateWithoutStudentInput>
  }

  export type GradeReportUpdateManyWithWhereWithoutStudentInput = {
    where: GradeReportScalarWhereInput
    data: XOR<GradeReportUpdateManyMutationInput, GradeReportUncheckedUpdateManyWithoutStudentInput>
  }

  export type GradeReportScalarWhereInput = {
    AND?: GradeReportScalarWhereInput | GradeReportScalarWhereInput[]
    OR?: GradeReportScalarWhereInput[]
    NOT?: GradeReportScalarWhereInput | GradeReportScalarWhereInput[]
    id?: StringFilter<"GradeReport"> | string
    studentId?: StringFilter<"GradeReport"> | string
    semesterId?: StringFilter<"GradeReport"> | string
    overallGpa?: FloatFilter<"GradeReport"> | number
    generatedAt?: DateTimeFilter<"GradeReport"> | Date | string
  }

  export type StudentRegistrationRequestUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentRegistrationRequestWhereUniqueInput
    update: XOR<StudentRegistrationRequestUpdateWithoutStudentInput, StudentRegistrationRequestUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentRegistrationRequestCreateWithoutStudentInput, StudentRegistrationRequestUncheckedCreateWithoutStudentInput>
  }

  export type StudentRegistrationRequestUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentRegistrationRequestWhereUniqueInput
    data: XOR<StudentRegistrationRequestUpdateWithoutStudentInput, StudentRegistrationRequestUncheckedUpdateWithoutStudentInput>
  }

  export type StudentRegistrationRequestUpdateManyWithWhereWithoutStudentInput = {
    where: StudentRegistrationRequestScalarWhereInput
    data: XOR<StudentRegistrationRequestUpdateManyMutationInput, StudentRegistrationRequestUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentRegistrationRequestScalarWhereInput = {
    AND?: StudentRegistrationRequestScalarWhereInput | StudentRegistrationRequestScalarWhereInput[]
    OR?: StudentRegistrationRequestScalarWhereInput[]
    NOT?: StudentRegistrationRequestScalarWhereInput | StudentRegistrationRequestScalarWhereInput[]
    id?: StringFilter<"StudentRegistrationRequest"> | string
    studentId?: StringFilter<"StudentRegistrationRequest"> | string
    semesterId?: StringFilter<"StudentRegistrationRequest"> | string
    status?: StringFilter<"StudentRegistrationRequest"> | string
    createdAt?: DateTimeFilter<"StudentRegistrationRequest"> | Date | string
    approvedAt?: DateTimeNullableFilter<"StudentRegistrationRequest"> | Date | string | null
    adminId?: StringNullableFilter<"StudentRegistrationRequest"> | string | null
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestCreateNestedManyWithoutStudentInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryUncheckedCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportUncheckedCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUpdateManyWithoutStudentNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUncheckedUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SemesterCreateWithoutAcademicYearInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    registrationOpen?: boolean
    minAverage?: number | null
    noFailedSubjects?: boolean | null
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutSemesterInput
    gradeReports?: GradeReportCreateNestedManyWithoutSemesterInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutSemesterInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutSemesterInput
    registrationRequests?: StudentRegistrationRequestCreateNestedManyWithoutSemesterInput
  }

  export type SemesterUncheckedCreateWithoutAcademicYearInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    registrationOpen?: boolean
    minAverage?: number | null
    noFailedSubjects?: boolean | null
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutSemesterInput
    gradeReports?: GradeReportUncheckedCreateNestedManyWithoutSemesterInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutSemesterInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutSemesterInput
    registrationRequests?: StudentRegistrationRequestUncheckedCreateNestedManyWithoutSemesterInput
  }

  export type SemesterCreateOrConnectWithoutAcademicYearInput = {
    where: SemesterWhereUniqueInput
    create: XOR<SemesterCreateWithoutAcademicYearInput, SemesterUncheckedCreateWithoutAcademicYearInput>
  }

  export type SemesterCreateManyAcademicYearInputEnvelope = {
    data: SemesterCreateManyAcademicYearInput | SemesterCreateManyAcademicYearInput[]
    skipDuplicates?: boolean
  }

  export type ClassCreateWithoutAcademicYearInput = {
    id?: string
    grade: GradeCreateNestedOneWithoutClassesInput
    classSection: ClassSectionCreateNestedOneWithoutClassesInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutClassInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutClassInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClassInput
    documents?: DocumentCreateNestedManyWithoutClassInput
    gradeCategories?: GradeCategoryCreateNestedManyWithoutClassInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutAcademicYearInput = {
    id?: string
    gradeId: string
    classSectionId: string
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutClassInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutClassInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClassInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClassInput
    gradeCategories?: GradeCategoryUncheckedCreateNestedManyWithoutClassInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutAcademicYearInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutAcademicYearInput, ClassUncheckedCreateWithoutAcademicYearInput>
  }

  export type ClassCreateManyAcademicYearInputEnvelope = {
    data: ClassCreateManyAcademicYearInput | ClassCreateManyAcademicYearInput[]
    skipDuplicates?: boolean
  }

  export type TeacherSubjectCreateWithoutAcademicYearInput = {
    id?: string
    teacher: UserCreateNestedOneWithoutTeacherSubjectsInput
    subject: SubjectCreateNestedOneWithoutTeacherSubjectsInput
    class: ClassCreateNestedOneWithoutTeacherSubjectsInput
  }

  export type TeacherSubjectUncheckedCreateWithoutAcademicYearInput = {
    id?: string
    teacherId: string
    subjectId: string
    classId: string
  }

  export type TeacherSubjectCreateOrConnectWithoutAcademicYearInput = {
    where: TeacherSubjectWhereUniqueInput
    create: XOR<TeacherSubjectCreateWithoutAcademicYearInput, TeacherSubjectUncheckedCreateWithoutAcademicYearInput>
  }

  export type TeacherSubjectCreateManyAcademicYearInputEnvelope = {
    data: TeacherSubjectCreateManyAcademicYearInput | TeacherSubjectCreateManyAcademicYearInput[]
    skipDuplicates?: boolean
  }

  export type StudentEnrollmentCreateWithoutAcademicYearInput = {
    id?: string
    enrollmentDate?: Date | string
    student: UserCreateNestedOneWithoutStudentEnrollmentsInput
    class: ClassCreateNestedOneWithoutStudentEnrollmentsInput
    semester?: SemesterCreateNestedOneWithoutStudentEnrollmentsInput
  }

  export type StudentEnrollmentUncheckedCreateWithoutAcademicYearInput = {
    id?: string
    studentId: string
    classId: string
    semesterId?: string | null
    enrollmentDate?: Date | string
  }

  export type StudentEnrollmentCreateOrConnectWithoutAcademicYearInput = {
    where: StudentEnrollmentWhereUniqueInput
    create: XOR<StudentEnrollmentCreateWithoutAcademicYearInput, StudentEnrollmentUncheckedCreateWithoutAcademicYearInput>
  }

  export type StudentEnrollmentCreateManyAcademicYearInputEnvelope = {
    data: StudentEnrollmentCreateManyAcademicYearInput | StudentEnrollmentCreateManyAcademicYearInput[]
    skipDuplicates?: boolean
  }

  export type GradeEntryCreateWithoutAcademicYearInput = {
    id?: string
    pointsEarned: number
    totalPoints: number
    date: Date | string
    student: UserCreateNestedOneWithoutGradeEntriesAsStudentInput
    subject: SubjectCreateNestedOneWithoutGradeEntriesInput
    category: GradeCategoryCreateNestedOneWithoutGradeEntriesInput
    class: ClassCreateNestedOneWithoutGradeEntriesInput
    semester: SemesterCreateNestedOneWithoutGradeEntriesInput
    createdBy: UserCreateNestedOneWithoutGradeEntriesCreatedInput
  }

  export type GradeEntryUncheckedCreateWithoutAcademicYearInput = {
    id?: string
    studentId: string
    subjectId: string
    categoryId: string
    classId: string
    pointsEarned: number
    totalPoints: number
    date: Date | string
    semesterId: string
    createdById: string
  }

  export type GradeEntryCreateOrConnectWithoutAcademicYearInput = {
    where: GradeEntryWhereUniqueInput
    create: XOR<GradeEntryCreateWithoutAcademicYearInput, GradeEntryUncheckedCreateWithoutAcademicYearInput>
  }

  export type GradeEntryCreateManyAcademicYearInputEnvelope = {
    data: GradeEntryCreateManyAcademicYearInput | GradeEntryCreateManyAcademicYearInput[]
    skipDuplicates?: boolean
  }

  export type SemesterUpsertWithWhereUniqueWithoutAcademicYearInput = {
    where: SemesterWhereUniqueInput
    update: XOR<SemesterUpdateWithoutAcademicYearInput, SemesterUncheckedUpdateWithoutAcademicYearInput>
    create: XOR<SemesterCreateWithoutAcademicYearInput, SemesterUncheckedCreateWithoutAcademicYearInput>
  }

  export type SemesterUpdateWithWhereUniqueWithoutAcademicYearInput = {
    where: SemesterWhereUniqueInput
    data: XOR<SemesterUpdateWithoutAcademicYearInput, SemesterUncheckedUpdateWithoutAcademicYearInput>
  }

  export type SemesterUpdateManyWithWhereWithoutAcademicYearInput = {
    where: SemesterScalarWhereInput
    data: XOR<SemesterUpdateManyMutationInput, SemesterUncheckedUpdateManyWithoutAcademicYearInput>
  }

  export type SemesterScalarWhereInput = {
    AND?: SemesterScalarWhereInput | SemesterScalarWhereInput[]
    OR?: SemesterScalarWhereInput[]
    NOT?: SemesterScalarWhereInput | SemesterScalarWhereInput[]
    id?: StringFilter<"Semester"> | string
    name?: StringFilter<"Semester"> | string
    academicYearId?: StringFilter<"Semester"> | string
    startDate?: DateTimeFilter<"Semester"> | Date | string
    endDate?: DateTimeFilter<"Semester"> | Date | string
    isCurrent?: BoolFilter<"Semester"> | boolean
    registrationOpen?: BoolFilter<"Semester"> | boolean
    minAverage?: FloatNullableFilter<"Semester"> | number | null
    noFailedSubjects?: BoolNullableFilter<"Semester"> | boolean | null
  }

  export type ClassUpsertWithWhereUniqueWithoutAcademicYearInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutAcademicYearInput, ClassUncheckedUpdateWithoutAcademicYearInput>
    create: XOR<ClassCreateWithoutAcademicYearInput, ClassUncheckedCreateWithoutAcademicYearInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutAcademicYearInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutAcademicYearInput, ClassUncheckedUpdateWithoutAcademicYearInput>
  }

  export type ClassUpdateManyWithWhereWithoutAcademicYearInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutAcademicYearInput>
  }

  export type ClassScalarWhereInput = {
    AND?: ClassScalarWhereInput | ClassScalarWhereInput[]
    OR?: ClassScalarWhereInput[]
    NOT?: ClassScalarWhereInput | ClassScalarWhereInput[]
    id?: StringFilter<"Class"> | string
    gradeId?: StringFilter<"Class"> | string
    classSectionId?: StringFilter<"Class"> | string
    academicYearId?: StringFilter<"Class"> | string
  }

  export type TeacherSubjectUpsertWithWhereUniqueWithoutAcademicYearInput = {
    where: TeacherSubjectWhereUniqueInput
    update: XOR<TeacherSubjectUpdateWithoutAcademicYearInput, TeacherSubjectUncheckedUpdateWithoutAcademicYearInput>
    create: XOR<TeacherSubjectCreateWithoutAcademicYearInput, TeacherSubjectUncheckedCreateWithoutAcademicYearInput>
  }

  export type TeacherSubjectUpdateWithWhereUniqueWithoutAcademicYearInput = {
    where: TeacherSubjectWhereUniqueInput
    data: XOR<TeacherSubjectUpdateWithoutAcademicYearInput, TeacherSubjectUncheckedUpdateWithoutAcademicYearInput>
  }

  export type TeacherSubjectUpdateManyWithWhereWithoutAcademicYearInput = {
    where: TeacherSubjectScalarWhereInput
    data: XOR<TeacherSubjectUpdateManyMutationInput, TeacherSubjectUncheckedUpdateManyWithoutAcademicYearInput>
  }

  export type StudentEnrollmentUpsertWithWhereUniqueWithoutAcademicYearInput = {
    where: StudentEnrollmentWhereUniqueInput
    update: XOR<StudentEnrollmentUpdateWithoutAcademicYearInput, StudentEnrollmentUncheckedUpdateWithoutAcademicYearInput>
    create: XOR<StudentEnrollmentCreateWithoutAcademicYearInput, StudentEnrollmentUncheckedCreateWithoutAcademicYearInput>
  }

  export type StudentEnrollmentUpdateWithWhereUniqueWithoutAcademicYearInput = {
    where: StudentEnrollmentWhereUniqueInput
    data: XOR<StudentEnrollmentUpdateWithoutAcademicYearInput, StudentEnrollmentUncheckedUpdateWithoutAcademicYearInput>
  }

  export type StudentEnrollmentUpdateManyWithWhereWithoutAcademicYearInput = {
    where: StudentEnrollmentScalarWhereInput
    data: XOR<StudentEnrollmentUpdateManyMutationInput, StudentEnrollmentUncheckedUpdateManyWithoutAcademicYearInput>
  }

  export type GradeEntryUpsertWithWhereUniqueWithoutAcademicYearInput = {
    where: GradeEntryWhereUniqueInput
    update: XOR<GradeEntryUpdateWithoutAcademicYearInput, GradeEntryUncheckedUpdateWithoutAcademicYearInput>
    create: XOR<GradeEntryCreateWithoutAcademicYearInput, GradeEntryUncheckedCreateWithoutAcademicYearInput>
  }

  export type GradeEntryUpdateWithWhereUniqueWithoutAcademicYearInput = {
    where: GradeEntryWhereUniqueInput
    data: XOR<GradeEntryUpdateWithoutAcademicYearInput, GradeEntryUncheckedUpdateWithoutAcademicYearInput>
  }

  export type GradeEntryUpdateManyWithWhereWithoutAcademicYearInput = {
    where: GradeEntryScalarWhereInput
    data: XOR<GradeEntryUpdateManyMutationInput, GradeEntryUncheckedUpdateManyWithoutAcademicYearInput>
  }

  export type AcademicYearCreateWithoutSemestersInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    createdBy: string
    classes?: ClassCreateNestedManyWithoutAcademicYearInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutAcademicYearInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutAcademicYearInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearUncheckedCreateWithoutSemestersInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    createdBy: string
    classes?: ClassUncheckedCreateNestedManyWithoutAcademicYearInput
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutAcademicYearInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutAcademicYearInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearCreateOrConnectWithoutSemestersInput = {
    where: AcademicYearWhereUniqueInput
    create: XOR<AcademicYearCreateWithoutSemestersInput, AcademicYearUncheckedCreateWithoutSemestersInput>
  }

  export type AttendanceSummaryCreateWithoutSemesterInput = {
    id?: string
    totalClasses: number
    presentCount: number
    absentCount: number
    lateCount: number
    student: UserCreateNestedOneWithoutAttendanceSummariesInput
    subject: SubjectCreateNestedOneWithoutAttendanceSummariesInput
  }

  export type AttendanceSummaryUncheckedCreateWithoutSemesterInput = {
    id?: string
    studentId: string
    subjectId: string
    totalClasses: number
    presentCount: number
    absentCount: number
    lateCount: number
  }

  export type AttendanceSummaryCreateOrConnectWithoutSemesterInput = {
    where: AttendanceSummaryWhereUniqueInput
    create: XOR<AttendanceSummaryCreateWithoutSemesterInput, AttendanceSummaryUncheckedCreateWithoutSemesterInput>
  }

  export type AttendanceSummaryCreateManySemesterInputEnvelope = {
    data: AttendanceSummaryCreateManySemesterInput | AttendanceSummaryCreateManySemesterInput[]
    skipDuplicates?: boolean
  }

  export type GradeReportCreateWithoutSemesterInput = {
    id?: string
    overallGpa: number
    generatedAt?: Date | string
    student: UserCreateNestedOneWithoutGradeReportsInput
  }

  export type GradeReportUncheckedCreateWithoutSemesterInput = {
    id?: string
    studentId: string
    overallGpa: number
    generatedAt?: Date | string
  }

  export type GradeReportCreateOrConnectWithoutSemesterInput = {
    where: GradeReportWhereUniqueInput
    create: XOR<GradeReportCreateWithoutSemesterInput, GradeReportUncheckedCreateWithoutSemesterInput>
  }

  export type GradeReportCreateManySemesterInputEnvelope = {
    data: GradeReportCreateManySemesterInput | GradeReportCreateManySemesterInput[]
    skipDuplicates?: boolean
  }

  export type GradeEntryCreateWithoutSemesterInput = {
    id?: string
    pointsEarned: number
    totalPoints: number
    date: Date | string
    student: UserCreateNestedOneWithoutGradeEntriesAsStudentInput
    subject: SubjectCreateNestedOneWithoutGradeEntriesInput
    category: GradeCategoryCreateNestedOneWithoutGradeEntriesInput
    class: ClassCreateNestedOneWithoutGradeEntriesInput
    academicYear: AcademicYearCreateNestedOneWithoutGradeEntriesInput
    createdBy: UserCreateNestedOneWithoutGradeEntriesCreatedInput
  }

  export type GradeEntryUncheckedCreateWithoutSemesterInput = {
    id?: string
    studentId: string
    subjectId: string
    categoryId: string
    classId: string
    academicYearId: string
    pointsEarned: number
    totalPoints: number
    date: Date | string
    createdById: string
  }

  export type GradeEntryCreateOrConnectWithoutSemesterInput = {
    where: GradeEntryWhereUniqueInput
    create: XOR<GradeEntryCreateWithoutSemesterInput, GradeEntryUncheckedCreateWithoutSemesterInput>
  }

  export type GradeEntryCreateManySemesterInputEnvelope = {
    data: GradeEntryCreateManySemesterInput | GradeEntryCreateManySemesterInput[]
    skipDuplicates?: boolean
  }

  export type StudentEnrollmentCreateWithoutSemesterInput = {
    id?: string
    enrollmentDate?: Date | string
    student: UserCreateNestedOneWithoutStudentEnrollmentsInput
    class: ClassCreateNestedOneWithoutStudentEnrollmentsInput
    academicYear: AcademicYearCreateNestedOneWithoutStudentEnrollmentsInput
  }

  export type StudentEnrollmentUncheckedCreateWithoutSemesterInput = {
    id?: string
    studentId: string
    classId: string
    academicYearId: string
    enrollmentDate?: Date | string
  }

  export type StudentEnrollmentCreateOrConnectWithoutSemesterInput = {
    where: StudentEnrollmentWhereUniqueInput
    create: XOR<StudentEnrollmentCreateWithoutSemesterInput, StudentEnrollmentUncheckedCreateWithoutSemesterInput>
  }

  export type StudentEnrollmentCreateManySemesterInputEnvelope = {
    data: StudentEnrollmentCreateManySemesterInput | StudentEnrollmentCreateManySemesterInput[]
    skipDuplicates?: boolean
  }

  export type StudentRegistrationRequestCreateWithoutSemesterInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    approvedAt?: Date | string | null
    adminId?: string | null
    student: UserCreateNestedOneWithoutRegistrationRequestsInput
  }

  export type StudentRegistrationRequestUncheckedCreateWithoutSemesterInput = {
    id?: string
    studentId: string
    status?: string
    createdAt?: Date | string
    approvedAt?: Date | string | null
    adminId?: string | null
  }

  export type StudentRegistrationRequestCreateOrConnectWithoutSemesterInput = {
    where: StudentRegistrationRequestWhereUniqueInput
    create: XOR<StudentRegistrationRequestCreateWithoutSemesterInput, StudentRegistrationRequestUncheckedCreateWithoutSemesterInput>
  }

  export type StudentRegistrationRequestCreateManySemesterInputEnvelope = {
    data: StudentRegistrationRequestCreateManySemesterInput | StudentRegistrationRequestCreateManySemesterInput[]
    skipDuplicates?: boolean
  }

  export type AcademicYearUpsertWithoutSemestersInput = {
    update: XOR<AcademicYearUpdateWithoutSemestersInput, AcademicYearUncheckedUpdateWithoutSemestersInput>
    create: XOR<AcademicYearCreateWithoutSemestersInput, AcademicYearUncheckedCreateWithoutSemestersInput>
    where?: AcademicYearWhereInput
  }

  export type AcademicYearUpdateToOneWithWhereWithoutSemestersInput = {
    where?: AcademicYearWhereInput
    data: XOR<AcademicYearUpdateWithoutSemestersInput, AcademicYearUncheckedUpdateWithoutSemestersInput>
  }

  export type AcademicYearUpdateWithoutSemestersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    classes?: ClassUpdateManyWithoutAcademicYearNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutAcademicYearNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutAcademicYearNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutAcademicYearNestedInput
  }

  export type AcademicYearUncheckedUpdateWithoutSemestersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    classes?: ClassUncheckedUpdateManyWithoutAcademicYearNestedInput
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutAcademicYearNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutAcademicYearNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutAcademicYearNestedInput
  }

  export type AttendanceSummaryUpsertWithWhereUniqueWithoutSemesterInput = {
    where: AttendanceSummaryWhereUniqueInput
    update: XOR<AttendanceSummaryUpdateWithoutSemesterInput, AttendanceSummaryUncheckedUpdateWithoutSemesterInput>
    create: XOR<AttendanceSummaryCreateWithoutSemesterInput, AttendanceSummaryUncheckedCreateWithoutSemesterInput>
  }

  export type AttendanceSummaryUpdateWithWhereUniqueWithoutSemesterInput = {
    where: AttendanceSummaryWhereUniqueInput
    data: XOR<AttendanceSummaryUpdateWithoutSemesterInput, AttendanceSummaryUncheckedUpdateWithoutSemesterInput>
  }

  export type AttendanceSummaryUpdateManyWithWhereWithoutSemesterInput = {
    where: AttendanceSummaryScalarWhereInput
    data: XOR<AttendanceSummaryUpdateManyMutationInput, AttendanceSummaryUncheckedUpdateManyWithoutSemesterInput>
  }

  export type GradeReportUpsertWithWhereUniqueWithoutSemesterInput = {
    where: GradeReportWhereUniqueInput
    update: XOR<GradeReportUpdateWithoutSemesterInput, GradeReportUncheckedUpdateWithoutSemesterInput>
    create: XOR<GradeReportCreateWithoutSemesterInput, GradeReportUncheckedCreateWithoutSemesterInput>
  }

  export type GradeReportUpdateWithWhereUniqueWithoutSemesterInput = {
    where: GradeReportWhereUniqueInput
    data: XOR<GradeReportUpdateWithoutSemesterInput, GradeReportUncheckedUpdateWithoutSemesterInput>
  }

  export type GradeReportUpdateManyWithWhereWithoutSemesterInput = {
    where: GradeReportScalarWhereInput
    data: XOR<GradeReportUpdateManyMutationInput, GradeReportUncheckedUpdateManyWithoutSemesterInput>
  }

  export type GradeEntryUpsertWithWhereUniqueWithoutSemesterInput = {
    where: GradeEntryWhereUniqueInput
    update: XOR<GradeEntryUpdateWithoutSemesterInput, GradeEntryUncheckedUpdateWithoutSemesterInput>
    create: XOR<GradeEntryCreateWithoutSemesterInput, GradeEntryUncheckedCreateWithoutSemesterInput>
  }

  export type GradeEntryUpdateWithWhereUniqueWithoutSemesterInput = {
    where: GradeEntryWhereUniqueInput
    data: XOR<GradeEntryUpdateWithoutSemesterInput, GradeEntryUncheckedUpdateWithoutSemesterInput>
  }

  export type GradeEntryUpdateManyWithWhereWithoutSemesterInput = {
    where: GradeEntryScalarWhereInput
    data: XOR<GradeEntryUpdateManyMutationInput, GradeEntryUncheckedUpdateManyWithoutSemesterInput>
  }

  export type StudentEnrollmentUpsertWithWhereUniqueWithoutSemesterInput = {
    where: StudentEnrollmentWhereUniqueInput
    update: XOR<StudentEnrollmentUpdateWithoutSemesterInput, StudentEnrollmentUncheckedUpdateWithoutSemesterInput>
    create: XOR<StudentEnrollmentCreateWithoutSemesterInput, StudentEnrollmentUncheckedCreateWithoutSemesterInput>
  }

  export type StudentEnrollmentUpdateWithWhereUniqueWithoutSemesterInput = {
    where: StudentEnrollmentWhereUniqueInput
    data: XOR<StudentEnrollmentUpdateWithoutSemesterInput, StudentEnrollmentUncheckedUpdateWithoutSemesterInput>
  }

  export type StudentEnrollmentUpdateManyWithWhereWithoutSemesterInput = {
    where: StudentEnrollmentScalarWhereInput
    data: XOR<StudentEnrollmentUpdateManyMutationInput, StudentEnrollmentUncheckedUpdateManyWithoutSemesterInput>
  }

  export type StudentRegistrationRequestUpsertWithWhereUniqueWithoutSemesterInput = {
    where: StudentRegistrationRequestWhereUniqueInput
    update: XOR<StudentRegistrationRequestUpdateWithoutSemesterInput, StudentRegistrationRequestUncheckedUpdateWithoutSemesterInput>
    create: XOR<StudentRegistrationRequestCreateWithoutSemesterInput, StudentRegistrationRequestUncheckedCreateWithoutSemesterInput>
  }

  export type StudentRegistrationRequestUpdateWithWhereUniqueWithoutSemesterInput = {
    where: StudentRegistrationRequestWhereUniqueInput
    data: XOR<StudentRegistrationRequestUpdateWithoutSemesterInput, StudentRegistrationRequestUncheckedUpdateWithoutSemesterInput>
  }

  export type StudentRegistrationRequestUpdateManyWithWhereWithoutSemesterInput = {
    where: StudentRegistrationRequestScalarWhereInput
    data: XOR<StudentRegistrationRequestUpdateManyMutationInput, StudentRegistrationRequestUncheckedUpdateManyWithoutSemesterInput>
  }

  export type GradeCreateWithoutClassSectionsInput = {
    id?: string
    name: string
    level: number
    subjects?: SubjectCreateNestedManyWithoutGradeInput
    classes?: ClassCreateNestedManyWithoutGradeInput
  }

  export type GradeUncheckedCreateWithoutClassSectionsInput = {
    id?: string
    name: string
    level: number
    subjects?: SubjectUncheckedCreateNestedManyWithoutGradeInput
    classes?: ClassUncheckedCreateNestedManyWithoutGradeInput
  }

  export type GradeCreateOrConnectWithoutClassSectionsInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutClassSectionsInput, GradeUncheckedCreateWithoutClassSectionsInput>
  }

  export type ClassCreateWithoutClassSectionInput = {
    id?: string
    grade: GradeCreateNestedOneWithoutClassesInput
    academicYear: AcademicYearCreateNestedOneWithoutClassesInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutClassInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutClassInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClassInput
    documents?: DocumentCreateNestedManyWithoutClassInput
    gradeCategories?: GradeCategoryCreateNestedManyWithoutClassInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutClassSectionInput = {
    id?: string
    gradeId: string
    academicYearId: string
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutClassInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutClassInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClassInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClassInput
    gradeCategories?: GradeCategoryUncheckedCreateNestedManyWithoutClassInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutClassSectionInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutClassSectionInput, ClassUncheckedCreateWithoutClassSectionInput>
  }

  export type ClassCreateManyClassSectionInputEnvelope = {
    data: ClassCreateManyClassSectionInput | ClassCreateManyClassSectionInput[]
    skipDuplicates?: boolean
  }

  export type GradeUpsertWithoutClassSectionsInput = {
    update: XOR<GradeUpdateWithoutClassSectionsInput, GradeUncheckedUpdateWithoutClassSectionsInput>
    create: XOR<GradeCreateWithoutClassSectionsInput, GradeUncheckedCreateWithoutClassSectionsInput>
    where?: GradeWhereInput
  }

  export type GradeUpdateToOneWithWhereWithoutClassSectionsInput = {
    where?: GradeWhereInput
    data: XOR<GradeUpdateWithoutClassSectionsInput, GradeUncheckedUpdateWithoutClassSectionsInput>
  }

  export type GradeUpdateWithoutClassSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    subjects?: SubjectUpdateManyWithoutGradeNestedInput
    classes?: ClassUpdateManyWithoutGradeNestedInput
  }

  export type GradeUncheckedUpdateWithoutClassSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    subjects?: SubjectUncheckedUpdateManyWithoutGradeNestedInput
    classes?: ClassUncheckedUpdateManyWithoutGradeNestedInput
  }

  export type ClassUpsertWithWhereUniqueWithoutClassSectionInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutClassSectionInput, ClassUncheckedUpdateWithoutClassSectionInput>
    create: XOR<ClassCreateWithoutClassSectionInput, ClassUncheckedCreateWithoutClassSectionInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutClassSectionInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutClassSectionInput, ClassUncheckedUpdateWithoutClassSectionInput>
  }

  export type ClassUpdateManyWithWhereWithoutClassSectionInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutClassSectionInput>
  }

  export type ClassSectionCreateWithoutGradeInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassCreateNestedManyWithoutClassSectionInput
  }

  export type ClassSectionUncheckedCreateWithoutGradeInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassUncheckedCreateNestedManyWithoutClassSectionInput
  }

  export type ClassSectionCreateOrConnectWithoutGradeInput = {
    where: ClassSectionWhereUniqueInput
    create: XOR<ClassSectionCreateWithoutGradeInput, ClassSectionUncheckedCreateWithoutGradeInput>
  }

  export type ClassSectionCreateManyGradeInputEnvelope = {
    data: ClassSectionCreateManyGradeInput | ClassSectionCreateManyGradeInput[]
    skipDuplicates?: boolean
  }

  export type SubjectCreateWithoutGradeInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutSubjectInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutSubjectInput
    gradeCategories?: GradeCategoryCreateNestedManyWithoutSubjectInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutSubjectInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutSubjectInput
    documents?: DocumentCreateNestedManyWithoutSubjectInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutGradeInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutSubjectInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutSubjectInput
    gradeCategories?: GradeCategoryUncheckedCreateNestedManyWithoutSubjectInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutSubjectInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutSubjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSubjectInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutGradeInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutGradeInput, SubjectUncheckedCreateWithoutGradeInput>
  }

  export type SubjectCreateManyGradeInputEnvelope = {
    data: SubjectCreateManyGradeInput | SubjectCreateManyGradeInput[]
    skipDuplicates?: boolean
  }

  export type ClassCreateWithoutGradeInput = {
    id?: string
    classSection: ClassSectionCreateNestedOneWithoutClassesInput
    academicYear: AcademicYearCreateNestedOneWithoutClassesInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutClassInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutClassInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClassInput
    documents?: DocumentCreateNestedManyWithoutClassInput
    gradeCategories?: GradeCategoryCreateNestedManyWithoutClassInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutGradeInput = {
    id?: string
    classSectionId: string
    academicYearId: string
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutClassInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutClassInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClassInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClassInput
    gradeCategories?: GradeCategoryUncheckedCreateNestedManyWithoutClassInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutGradeInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutGradeInput, ClassUncheckedCreateWithoutGradeInput>
  }

  export type ClassCreateManyGradeInputEnvelope = {
    data: ClassCreateManyGradeInput | ClassCreateManyGradeInput[]
    skipDuplicates?: boolean
  }

  export type ClassSectionUpsertWithWhereUniqueWithoutGradeInput = {
    where: ClassSectionWhereUniqueInput
    update: XOR<ClassSectionUpdateWithoutGradeInput, ClassSectionUncheckedUpdateWithoutGradeInput>
    create: XOR<ClassSectionCreateWithoutGradeInput, ClassSectionUncheckedCreateWithoutGradeInput>
  }

  export type ClassSectionUpdateWithWhereUniqueWithoutGradeInput = {
    where: ClassSectionWhereUniqueInput
    data: XOR<ClassSectionUpdateWithoutGradeInput, ClassSectionUncheckedUpdateWithoutGradeInput>
  }

  export type ClassSectionUpdateManyWithWhereWithoutGradeInput = {
    where: ClassSectionScalarWhereInput
    data: XOR<ClassSectionUpdateManyMutationInput, ClassSectionUncheckedUpdateManyWithoutGradeInput>
  }

  export type ClassSectionScalarWhereInput = {
    AND?: ClassSectionScalarWhereInput | ClassSectionScalarWhereInput[]
    OR?: ClassSectionScalarWhereInput[]
    NOT?: ClassSectionScalarWhereInput | ClassSectionScalarWhereInput[]
    id?: StringFilter<"ClassSection"> | string
    name?: StringFilter<"ClassSection"> | string
    gradeId?: StringFilter<"ClassSection"> | string
    createdAt?: DateTimeFilter<"ClassSection"> | Date | string
    updatedAt?: DateTimeFilter<"ClassSection"> | Date | string
  }

  export type SubjectUpsertWithWhereUniqueWithoutGradeInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutGradeInput, SubjectUncheckedUpdateWithoutGradeInput>
    create: XOR<SubjectCreateWithoutGradeInput, SubjectUncheckedCreateWithoutGradeInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutGradeInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutGradeInput, SubjectUncheckedUpdateWithoutGradeInput>
  }

  export type SubjectUpdateManyWithWhereWithoutGradeInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutGradeInput>
  }

  export type SubjectScalarWhereInput = {
    AND?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
    OR?: SubjectScalarWhereInput[]
    NOT?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
    id?: StringFilter<"Subject"> | string
    name?: StringFilter<"Subject"> | string
    code?: StringFilter<"Subject"> | string
    description?: StringNullableFilter<"Subject"> | string | null
    gradeId?: StringFilter<"Subject"> | string
  }

  export type ClassUpsertWithWhereUniqueWithoutGradeInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutGradeInput, ClassUncheckedUpdateWithoutGradeInput>
    create: XOR<ClassCreateWithoutGradeInput, ClassUncheckedCreateWithoutGradeInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutGradeInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutGradeInput, ClassUncheckedUpdateWithoutGradeInput>
  }

  export type ClassUpdateManyWithWhereWithoutGradeInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutGradeInput>
  }

  export type GradeCreateWithoutSubjectsInput = {
    id?: string
    name: string
    level: number
    classSections?: ClassSectionCreateNestedManyWithoutGradeInput
    classes?: ClassCreateNestedManyWithoutGradeInput
  }

  export type GradeUncheckedCreateWithoutSubjectsInput = {
    id?: string
    name: string
    level: number
    classSections?: ClassSectionUncheckedCreateNestedManyWithoutGradeInput
    classes?: ClassUncheckedCreateNestedManyWithoutGradeInput
  }

  export type GradeCreateOrConnectWithoutSubjectsInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutSubjectsInput, GradeUncheckedCreateWithoutSubjectsInput>
  }

  export type TeacherSubjectCreateWithoutSubjectInput = {
    id?: string
    teacher: UserCreateNestedOneWithoutTeacherSubjectsInput
    class: ClassCreateNestedOneWithoutTeacherSubjectsInput
    academicYear: AcademicYearCreateNestedOneWithoutTeacherSubjectsInput
  }

  export type TeacherSubjectUncheckedCreateWithoutSubjectInput = {
    id?: string
    teacherId: string
    classId: string
    academicYearId: string
  }

  export type TeacherSubjectCreateOrConnectWithoutSubjectInput = {
    where: TeacherSubjectWhereUniqueInput
    create: XOR<TeacherSubjectCreateWithoutSubjectInput, TeacherSubjectUncheckedCreateWithoutSubjectInput>
  }

  export type TeacherSubjectCreateManySubjectInputEnvelope = {
    data: TeacherSubjectCreateManySubjectInput | TeacherSubjectCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type ClassScheduleCreateWithoutSubjectInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    class: ClassCreateNestedOneWithoutClassSchedulesInput
    teacher: UserCreateNestedOneWithoutClassSchedulesInput
  }

  export type ClassScheduleUncheckedCreateWithoutSubjectInput = {
    id?: string
    classId: string
    teacherId: string
    dayOfWeek: number
    startTime: string
    endTime: string
  }

  export type ClassScheduleCreateOrConnectWithoutSubjectInput = {
    where: ClassScheduleWhereUniqueInput
    create: XOR<ClassScheduleCreateWithoutSubjectInput, ClassScheduleUncheckedCreateWithoutSubjectInput>
  }

  export type ClassScheduleCreateManySubjectInputEnvelope = {
    data: ClassScheduleCreateManySubjectInput | ClassScheduleCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type GradeCategoryCreateWithoutSubjectInput = {
    id?: string
    name: string
    weight: number
    class: ClassCreateNestedOneWithoutGradeCategoriesInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutCategoryInput
  }

  export type GradeCategoryUncheckedCreateWithoutSubjectInput = {
    id?: string
    name: string
    weight: number
    classId: string
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type GradeCategoryCreateOrConnectWithoutSubjectInput = {
    where: GradeCategoryWhereUniqueInput
    create: XOR<GradeCategoryCreateWithoutSubjectInput, GradeCategoryUncheckedCreateWithoutSubjectInput>
  }

  export type GradeCategoryCreateManySubjectInputEnvelope = {
    data: GradeCategoryCreateManySubjectInput | GradeCategoryCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type GradeEntryCreateWithoutSubjectInput = {
    id?: string
    pointsEarned: number
    totalPoints: number
    date: Date | string
    student: UserCreateNestedOneWithoutGradeEntriesAsStudentInput
    category: GradeCategoryCreateNestedOneWithoutGradeEntriesInput
    class: ClassCreateNestedOneWithoutGradeEntriesInput
    academicYear: AcademicYearCreateNestedOneWithoutGradeEntriesInput
    semester: SemesterCreateNestedOneWithoutGradeEntriesInput
    createdBy: UserCreateNestedOneWithoutGradeEntriesCreatedInput
  }

  export type GradeEntryUncheckedCreateWithoutSubjectInput = {
    id?: string
    studentId: string
    categoryId: string
    classId: string
    academicYearId: string
    pointsEarned: number
    totalPoints: number
    date: Date | string
    semesterId: string
    createdById: string
  }

  export type GradeEntryCreateOrConnectWithoutSubjectInput = {
    where: GradeEntryWhereUniqueInput
    create: XOR<GradeEntryCreateWithoutSubjectInput, GradeEntryUncheckedCreateWithoutSubjectInput>
  }

  export type GradeEntryCreateManySubjectInputEnvelope = {
    data: GradeEntryCreateManySubjectInput | GradeEntryCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceRecordCreateWithoutSubjectInput = {
    id?: string
    date: Date | string
    period?: number | null
    status: $Enums.AttendanceStatus
    markedAt?: Date | string
    remarks?: string | null
    student: UserCreateNestedOneWithoutAttendanceRecordsAsStudentInput
    class: ClassCreateNestedOneWithoutAttendanceRecordsInput
    markedBy: UserCreateNestedOneWithoutAttendanceRecordsMarkedInput
  }

  export type AttendanceRecordUncheckedCreateWithoutSubjectInput = {
    id?: string
    studentId: string
    classId: string
    date: Date | string
    period?: number | null
    status: $Enums.AttendanceStatus
    markedById: string
    markedAt?: Date | string
    remarks?: string | null
  }

  export type AttendanceRecordCreateOrConnectWithoutSubjectInput = {
    where: AttendanceRecordWhereUniqueInput
    create: XOR<AttendanceRecordCreateWithoutSubjectInput, AttendanceRecordUncheckedCreateWithoutSubjectInput>
  }

  export type AttendanceRecordCreateManySubjectInputEnvelope = {
    data: AttendanceRecordCreateManySubjectInput | AttendanceRecordCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutSubjectInput = {
    id?: string
    title: string
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    category: string
    uploadedAt?: Date | string
    uploadedBy: UserCreateNestedOneWithoutDocumentsInput
    class?: ClassCreateNestedOneWithoutDocumentsInput
    permissions?: DocumentPermissionCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutSubjectInput = {
    id?: string
    title: string
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedById: string
    category: string
    classId?: string | null
    uploadedAt?: Date | string
    permissions?: DocumentPermissionUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutSubjectInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutSubjectInput, DocumentUncheckedCreateWithoutSubjectInput>
  }

  export type DocumentCreateManySubjectInputEnvelope = {
    data: DocumentCreateManySubjectInput | DocumentCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceSummaryCreateWithoutSubjectInput = {
    id?: string
    totalClasses: number
    presentCount: number
    absentCount: number
    lateCount: number
    student: UserCreateNestedOneWithoutAttendanceSummariesInput
    semester: SemesterCreateNestedOneWithoutAttendanceSummariesInput
  }

  export type AttendanceSummaryUncheckedCreateWithoutSubjectInput = {
    id?: string
    studentId: string
    semesterId: string
    totalClasses: number
    presentCount: number
    absentCount: number
    lateCount: number
  }

  export type AttendanceSummaryCreateOrConnectWithoutSubjectInput = {
    where: AttendanceSummaryWhereUniqueInput
    create: XOR<AttendanceSummaryCreateWithoutSubjectInput, AttendanceSummaryUncheckedCreateWithoutSubjectInput>
  }

  export type AttendanceSummaryCreateManySubjectInputEnvelope = {
    data: AttendanceSummaryCreateManySubjectInput | AttendanceSummaryCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type GradeUpsertWithoutSubjectsInput = {
    update: XOR<GradeUpdateWithoutSubjectsInput, GradeUncheckedUpdateWithoutSubjectsInput>
    create: XOR<GradeCreateWithoutSubjectsInput, GradeUncheckedCreateWithoutSubjectsInput>
    where?: GradeWhereInput
  }

  export type GradeUpdateToOneWithWhereWithoutSubjectsInput = {
    where?: GradeWhereInput
    data: XOR<GradeUpdateWithoutSubjectsInput, GradeUncheckedUpdateWithoutSubjectsInput>
  }

  export type GradeUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    classSections?: ClassSectionUpdateManyWithoutGradeNestedInput
    classes?: ClassUpdateManyWithoutGradeNestedInput
  }

  export type GradeUncheckedUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    classSections?: ClassSectionUncheckedUpdateManyWithoutGradeNestedInput
    classes?: ClassUncheckedUpdateManyWithoutGradeNestedInput
  }

  export type TeacherSubjectUpsertWithWhereUniqueWithoutSubjectInput = {
    where: TeacherSubjectWhereUniqueInput
    update: XOR<TeacherSubjectUpdateWithoutSubjectInput, TeacherSubjectUncheckedUpdateWithoutSubjectInput>
    create: XOR<TeacherSubjectCreateWithoutSubjectInput, TeacherSubjectUncheckedCreateWithoutSubjectInput>
  }

  export type TeacherSubjectUpdateWithWhereUniqueWithoutSubjectInput = {
    where: TeacherSubjectWhereUniqueInput
    data: XOR<TeacherSubjectUpdateWithoutSubjectInput, TeacherSubjectUncheckedUpdateWithoutSubjectInput>
  }

  export type TeacherSubjectUpdateManyWithWhereWithoutSubjectInput = {
    where: TeacherSubjectScalarWhereInput
    data: XOR<TeacherSubjectUpdateManyMutationInput, TeacherSubjectUncheckedUpdateManyWithoutSubjectInput>
  }

  export type ClassScheduleUpsertWithWhereUniqueWithoutSubjectInput = {
    where: ClassScheduleWhereUniqueInput
    update: XOR<ClassScheduleUpdateWithoutSubjectInput, ClassScheduleUncheckedUpdateWithoutSubjectInput>
    create: XOR<ClassScheduleCreateWithoutSubjectInput, ClassScheduleUncheckedCreateWithoutSubjectInput>
  }

  export type ClassScheduleUpdateWithWhereUniqueWithoutSubjectInput = {
    where: ClassScheduleWhereUniqueInput
    data: XOR<ClassScheduleUpdateWithoutSubjectInput, ClassScheduleUncheckedUpdateWithoutSubjectInput>
  }

  export type ClassScheduleUpdateManyWithWhereWithoutSubjectInput = {
    where: ClassScheduleScalarWhereInput
    data: XOR<ClassScheduleUpdateManyMutationInput, ClassScheduleUncheckedUpdateManyWithoutSubjectInput>
  }

  export type GradeCategoryUpsertWithWhereUniqueWithoutSubjectInput = {
    where: GradeCategoryWhereUniqueInput
    update: XOR<GradeCategoryUpdateWithoutSubjectInput, GradeCategoryUncheckedUpdateWithoutSubjectInput>
    create: XOR<GradeCategoryCreateWithoutSubjectInput, GradeCategoryUncheckedCreateWithoutSubjectInput>
  }

  export type GradeCategoryUpdateWithWhereUniqueWithoutSubjectInput = {
    where: GradeCategoryWhereUniqueInput
    data: XOR<GradeCategoryUpdateWithoutSubjectInput, GradeCategoryUncheckedUpdateWithoutSubjectInput>
  }

  export type GradeCategoryUpdateManyWithWhereWithoutSubjectInput = {
    where: GradeCategoryScalarWhereInput
    data: XOR<GradeCategoryUpdateManyMutationInput, GradeCategoryUncheckedUpdateManyWithoutSubjectInput>
  }

  export type GradeCategoryScalarWhereInput = {
    AND?: GradeCategoryScalarWhereInput | GradeCategoryScalarWhereInput[]
    OR?: GradeCategoryScalarWhereInput[]
    NOT?: GradeCategoryScalarWhereInput | GradeCategoryScalarWhereInput[]
    id?: StringFilter<"GradeCategory"> | string
    name?: StringFilter<"GradeCategory"> | string
    weight?: FloatFilter<"GradeCategory"> | number
    classId?: StringFilter<"GradeCategory"> | string
    subjectId?: StringFilter<"GradeCategory"> | string
  }

  export type GradeEntryUpsertWithWhereUniqueWithoutSubjectInput = {
    where: GradeEntryWhereUniqueInput
    update: XOR<GradeEntryUpdateWithoutSubjectInput, GradeEntryUncheckedUpdateWithoutSubjectInput>
    create: XOR<GradeEntryCreateWithoutSubjectInput, GradeEntryUncheckedCreateWithoutSubjectInput>
  }

  export type GradeEntryUpdateWithWhereUniqueWithoutSubjectInput = {
    where: GradeEntryWhereUniqueInput
    data: XOR<GradeEntryUpdateWithoutSubjectInput, GradeEntryUncheckedUpdateWithoutSubjectInput>
  }

  export type GradeEntryUpdateManyWithWhereWithoutSubjectInput = {
    where: GradeEntryScalarWhereInput
    data: XOR<GradeEntryUpdateManyMutationInput, GradeEntryUncheckedUpdateManyWithoutSubjectInput>
  }

  export type AttendanceRecordUpsertWithWhereUniqueWithoutSubjectInput = {
    where: AttendanceRecordWhereUniqueInput
    update: XOR<AttendanceRecordUpdateWithoutSubjectInput, AttendanceRecordUncheckedUpdateWithoutSubjectInput>
    create: XOR<AttendanceRecordCreateWithoutSubjectInput, AttendanceRecordUncheckedCreateWithoutSubjectInput>
  }

  export type AttendanceRecordUpdateWithWhereUniqueWithoutSubjectInput = {
    where: AttendanceRecordWhereUniqueInput
    data: XOR<AttendanceRecordUpdateWithoutSubjectInput, AttendanceRecordUncheckedUpdateWithoutSubjectInput>
  }

  export type AttendanceRecordUpdateManyWithWhereWithoutSubjectInput = {
    where: AttendanceRecordScalarWhereInput
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyWithoutSubjectInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutSubjectInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutSubjectInput, DocumentUncheckedUpdateWithoutSubjectInput>
    create: XOR<DocumentCreateWithoutSubjectInput, DocumentUncheckedCreateWithoutSubjectInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutSubjectInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutSubjectInput, DocumentUncheckedUpdateWithoutSubjectInput>
  }

  export type DocumentUpdateManyWithWhereWithoutSubjectInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutSubjectInput>
  }

  export type AttendanceSummaryUpsertWithWhereUniqueWithoutSubjectInput = {
    where: AttendanceSummaryWhereUniqueInput
    update: XOR<AttendanceSummaryUpdateWithoutSubjectInput, AttendanceSummaryUncheckedUpdateWithoutSubjectInput>
    create: XOR<AttendanceSummaryCreateWithoutSubjectInput, AttendanceSummaryUncheckedCreateWithoutSubjectInput>
  }

  export type AttendanceSummaryUpdateWithWhereUniqueWithoutSubjectInput = {
    where: AttendanceSummaryWhereUniqueInput
    data: XOR<AttendanceSummaryUpdateWithoutSubjectInput, AttendanceSummaryUncheckedUpdateWithoutSubjectInput>
  }

  export type AttendanceSummaryUpdateManyWithWhereWithoutSubjectInput = {
    where: AttendanceSummaryScalarWhereInput
    data: XOR<AttendanceSummaryUpdateManyMutationInput, AttendanceSummaryUncheckedUpdateManyWithoutSubjectInput>
  }

  export type GradeCreateWithoutClassesInput = {
    id?: string
    name: string
    level: number
    classSections?: ClassSectionCreateNestedManyWithoutGradeInput
    subjects?: SubjectCreateNestedManyWithoutGradeInput
  }

  export type GradeUncheckedCreateWithoutClassesInput = {
    id?: string
    name: string
    level: number
    classSections?: ClassSectionUncheckedCreateNestedManyWithoutGradeInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutGradeInput
  }

  export type GradeCreateOrConnectWithoutClassesInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutClassesInput, GradeUncheckedCreateWithoutClassesInput>
  }

  export type ClassSectionCreateWithoutClassesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    grade: GradeCreateNestedOneWithoutClassSectionsInput
  }

  export type ClassSectionUncheckedCreateWithoutClassesInput = {
    id?: string
    name: string
    gradeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassSectionCreateOrConnectWithoutClassesInput = {
    where: ClassSectionWhereUniqueInput
    create: XOR<ClassSectionCreateWithoutClassesInput, ClassSectionUncheckedCreateWithoutClassesInput>
  }

  export type AcademicYearCreateWithoutClassesInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    createdBy: string
    semesters?: SemesterCreateNestedManyWithoutAcademicYearInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutAcademicYearInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutAcademicYearInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearUncheckedCreateWithoutClassesInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    createdBy: string
    semesters?: SemesterUncheckedCreateNestedManyWithoutAcademicYearInput
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutAcademicYearInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutAcademicYearInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearCreateOrConnectWithoutClassesInput = {
    where: AcademicYearWhereUniqueInput
    create: XOR<AcademicYearCreateWithoutClassesInput, AcademicYearUncheckedCreateWithoutClassesInput>
  }

  export type TeacherSubjectCreateWithoutClassInput = {
    id?: string
    teacher: UserCreateNestedOneWithoutTeacherSubjectsInput
    subject: SubjectCreateNestedOneWithoutTeacherSubjectsInput
    academicYear: AcademicYearCreateNestedOneWithoutTeacherSubjectsInput
  }

  export type TeacherSubjectUncheckedCreateWithoutClassInput = {
    id?: string
    teacherId: string
    subjectId: string
    academicYearId: string
  }

  export type TeacherSubjectCreateOrConnectWithoutClassInput = {
    where: TeacherSubjectWhereUniqueInput
    create: XOR<TeacherSubjectCreateWithoutClassInput, TeacherSubjectUncheckedCreateWithoutClassInput>
  }

  export type TeacherSubjectCreateManyClassInputEnvelope = {
    data: TeacherSubjectCreateManyClassInput | TeacherSubjectCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type StudentEnrollmentCreateWithoutClassInput = {
    id?: string
    enrollmentDate?: Date | string
    student: UserCreateNestedOneWithoutStudentEnrollmentsInput
    academicYear: AcademicYearCreateNestedOneWithoutStudentEnrollmentsInput
    semester?: SemesterCreateNestedOneWithoutStudentEnrollmentsInput
  }

  export type StudentEnrollmentUncheckedCreateWithoutClassInput = {
    id?: string
    studentId: string
    academicYearId: string
    semesterId?: string | null
    enrollmentDate?: Date | string
  }

  export type StudentEnrollmentCreateOrConnectWithoutClassInput = {
    where: StudentEnrollmentWhereUniqueInput
    create: XOR<StudentEnrollmentCreateWithoutClassInput, StudentEnrollmentUncheckedCreateWithoutClassInput>
  }

  export type StudentEnrollmentCreateManyClassInputEnvelope = {
    data: StudentEnrollmentCreateManyClassInput | StudentEnrollmentCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type ClassScheduleCreateWithoutClassInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    subject: SubjectCreateNestedOneWithoutClassSchedulesInput
    teacher: UserCreateNestedOneWithoutClassSchedulesInput
  }

  export type ClassScheduleUncheckedCreateWithoutClassInput = {
    id?: string
    subjectId: string
    teacherId: string
    dayOfWeek: number
    startTime: string
    endTime: string
  }

  export type ClassScheduleCreateOrConnectWithoutClassInput = {
    where: ClassScheduleWhereUniqueInput
    create: XOR<ClassScheduleCreateWithoutClassInput, ClassScheduleUncheckedCreateWithoutClassInput>
  }

  export type ClassScheduleCreateManyClassInputEnvelope = {
    data: ClassScheduleCreateManyClassInput | ClassScheduleCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceRecordCreateWithoutClassInput = {
    id?: string
    date: Date | string
    period?: number | null
    status: $Enums.AttendanceStatus
    markedAt?: Date | string
    remarks?: string | null
    student: UserCreateNestedOneWithoutAttendanceRecordsAsStudentInput
    subject: SubjectCreateNestedOneWithoutAttendanceRecordsInput
    markedBy: UserCreateNestedOneWithoutAttendanceRecordsMarkedInput
  }

  export type AttendanceRecordUncheckedCreateWithoutClassInput = {
    id?: string
    studentId: string
    subjectId: string
    date: Date | string
    period?: number | null
    status: $Enums.AttendanceStatus
    markedById: string
    markedAt?: Date | string
    remarks?: string | null
  }

  export type AttendanceRecordCreateOrConnectWithoutClassInput = {
    where: AttendanceRecordWhereUniqueInput
    create: XOR<AttendanceRecordCreateWithoutClassInput, AttendanceRecordUncheckedCreateWithoutClassInput>
  }

  export type AttendanceRecordCreateManyClassInputEnvelope = {
    data: AttendanceRecordCreateManyClassInput | AttendanceRecordCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutClassInput = {
    id?: string
    title: string
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    category: string
    uploadedAt?: Date | string
    uploadedBy: UserCreateNestedOneWithoutDocumentsInput
    subject?: SubjectCreateNestedOneWithoutDocumentsInput
    permissions?: DocumentPermissionCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutClassInput = {
    id?: string
    title: string
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedById: string
    category: string
    subjectId?: string | null
    uploadedAt?: Date | string
    permissions?: DocumentPermissionUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutClassInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutClassInput, DocumentUncheckedCreateWithoutClassInput>
  }

  export type DocumentCreateManyClassInputEnvelope = {
    data: DocumentCreateManyClassInput | DocumentCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type GradeCategoryCreateWithoutClassInput = {
    id?: string
    name: string
    weight: number
    subject: SubjectCreateNestedOneWithoutGradeCategoriesInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutCategoryInput
  }

  export type GradeCategoryUncheckedCreateWithoutClassInput = {
    id?: string
    name: string
    weight: number
    subjectId: string
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type GradeCategoryCreateOrConnectWithoutClassInput = {
    where: GradeCategoryWhereUniqueInput
    create: XOR<GradeCategoryCreateWithoutClassInput, GradeCategoryUncheckedCreateWithoutClassInput>
  }

  export type GradeCategoryCreateManyClassInputEnvelope = {
    data: GradeCategoryCreateManyClassInput | GradeCategoryCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type GradeEntryCreateWithoutClassInput = {
    id?: string
    pointsEarned: number
    totalPoints: number
    date: Date | string
    student: UserCreateNestedOneWithoutGradeEntriesAsStudentInput
    subject: SubjectCreateNestedOneWithoutGradeEntriesInput
    category: GradeCategoryCreateNestedOneWithoutGradeEntriesInput
    academicYear: AcademicYearCreateNestedOneWithoutGradeEntriesInput
    semester: SemesterCreateNestedOneWithoutGradeEntriesInput
    createdBy: UserCreateNestedOneWithoutGradeEntriesCreatedInput
  }

  export type GradeEntryUncheckedCreateWithoutClassInput = {
    id?: string
    studentId: string
    subjectId: string
    categoryId: string
    academicYearId: string
    pointsEarned: number
    totalPoints: number
    date: Date | string
    semesterId: string
    createdById: string
  }

  export type GradeEntryCreateOrConnectWithoutClassInput = {
    where: GradeEntryWhereUniqueInput
    create: XOR<GradeEntryCreateWithoutClassInput, GradeEntryUncheckedCreateWithoutClassInput>
  }

  export type GradeEntryCreateManyClassInputEnvelope = {
    data: GradeEntryCreateManyClassInput | GradeEntryCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type GradeUpsertWithoutClassesInput = {
    update: XOR<GradeUpdateWithoutClassesInput, GradeUncheckedUpdateWithoutClassesInput>
    create: XOR<GradeCreateWithoutClassesInput, GradeUncheckedCreateWithoutClassesInput>
    where?: GradeWhereInput
  }

  export type GradeUpdateToOneWithWhereWithoutClassesInput = {
    where?: GradeWhereInput
    data: XOR<GradeUpdateWithoutClassesInput, GradeUncheckedUpdateWithoutClassesInput>
  }

  export type GradeUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    classSections?: ClassSectionUpdateManyWithoutGradeNestedInput
    subjects?: SubjectUpdateManyWithoutGradeNestedInput
  }

  export type GradeUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    classSections?: ClassSectionUncheckedUpdateManyWithoutGradeNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutGradeNestedInput
  }

  export type ClassSectionUpsertWithoutClassesInput = {
    update: XOR<ClassSectionUpdateWithoutClassesInput, ClassSectionUncheckedUpdateWithoutClassesInput>
    create: XOR<ClassSectionCreateWithoutClassesInput, ClassSectionUncheckedCreateWithoutClassesInput>
    where?: ClassSectionWhereInput
  }

  export type ClassSectionUpdateToOneWithWhereWithoutClassesInput = {
    where?: ClassSectionWhereInput
    data: XOR<ClassSectionUpdateWithoutClassesInput, ClassSectionUncheckedUpdateWithoutClassesInput>
  }

  export type ClassSectionUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: GradeUpdateOneRequiredWithoutClassSectionsNestedInput
  }

  export type ClassSectionUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicYearUpsertWithoutClassesInput = {
    update: XOR<AcademicYearUpdateWithoutClassesInput, AcademicYearUncheckedUpdateWithoutClassesInput>
    create: XOR<AcademicYearCreateWithoutClassesInput, AcademicYearUncheckedCreateWithoutClassesInput>
    where?: AcademicYearWhereInput
  }

  export type AcademicYearUpdateToOneWithWhereWithoutClassesInput = {
    where?: AcademicYearWhereInput
    data: XOR<AcademicYearUpdateWithoutClassesInput, AcademicYearUncheckedUpdateWithoutClassesInput>
  }

  export type AcademicYearUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    semesters?: SemesterUpdateManyWithoutAcademicYearNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutAcademicYearNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutAcademicYearNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutAcademicYearNestedInput
  }

  export type AcademicYearUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    semesters?: SemesterUncheckedUpdateManyWithoutAcademicYearNestedInput
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutAcademicYearNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutAcademicYearNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutAcademicYearNestedInput
  }

  export type TeacherSubjectUpsertWithWhereUniqueWithoutClassInput = {
    where: TeacherSubjectWhereUniqueInput
    update: XOR<TeacherSubjectUpdateWithoutClassInput, TeacherSubjectUncheckedUpdateWithoutClassInput>
    create: XOR<TeacherSubjectCreateWithoutClassInput, TeacherSubjectUncheckedCreateWithoutClassInput>
  }

  export type TeacherSubjectUpdateWithWhereUniqueWithoutClassInput = {
    where: TeacherSubjectWhereUniqueInput
    data: XOR<TeacherSubjectUpdateWithoutClassInput, TeacherSubjectUncheckedUpdateWithoutClassInput>
  }

  export type TeacherSubjectUpdateManyWithWhereWithoutClassInput = {
    where: TeacherSubjectScalarWhereInput
    data: XOR<TeacherSubjectUpdateManyMutationInput, TeacherSubjectUncheckedUpdateManyWithoutClassInput>
  }

  export type StudentEnrollmentUpsertWithWhereUniqueWithoutClassInput = {
    where: StudentEnrollmentWhereUniqueInput
    update: XOR<StudentEnrollmentUpdateWithoutClassInput, StudentEnrollmentUncheckedUpdateWithoutClassInput>
    create: XOR<StudentEnrollmentCreateWithoutClassInput, StudentEnrollmentUncheckedCreateWithoutClassInput>
  }

  export type StudentEnrollmentUpdateWithWhereUniqueWithoutClassInput = {
    where: StudentEnrollmentWhereUniqueInput
    data: XOR<StudentEnrollmentUpdateWithoutClassInput, StudentEnrollmentUncheckedUpdateWithoutClassInput>
  }

  export type StudentEnrollmentUpdateManyWithWhereWithoutClassInput = {
    where: StudentEnrollmentScalarWhereInput
    data: XOR<StudentEnrollmentUpdateManyMutationInput, StudentEnrollmentUncheckedUpdateManyWithoutClassInput>
  }

  export type ClassScheduleUpsertWithWhereUniqueWithoutClassInput = {
    where: ClassScheduleWhereUniqueInput
    update: XOR<ClassScheduleUpdateWithoutClassInput, ClassScheduleUncheckedUpdateWithoutClassInput>
    create: XOR<ClassScheduleCreateWithoutClassInput, ClassScheduleUncheckedCreateWithoutClassInput>
  }

  export type ClassScheduleUpdateWithWhereUniqueWithoutClassInput = {
    where: ClassScheduleWhereUniqueInput
    data: XOR<ClassScheduleUpdateWithoutClassInput, ClassScheduleUncheckedUpdateWithoutClassInput>
  }

  export type ClassScheduleUpdateManyWithWhereWithoutClassInput = {
    where: ClassScheduleScalarWhereInput
    data: XOR<ClassScheduleUpdateManyMutationInput, ClassScheduleUncheckedUpdateManyWithoutClassInput>
  }

  export type AttendanceRecordUpsertWithWhereUniqueWithoutClassInput = {
    where: AttendanceRecordWhereUniqueInput
    update: XOR<AttendanceRecordUpdateWithoutClassInput, AttendanceRecordUncheckedUpdateWithoutClassInput>
    create: XOR<AttendanceRecordCreateWithoutClassInput, AttendanceRecordUncheckedCreateWithoutClassInput>
  }

  export type AttendanceRecordUpdateWithWhereUniqueWithoutClassInput = {
    where: AttendanceRecordWhereUniqueInput
    data: XOR<AttendanceRecordUpdateWithoutClassInput, AttendanceRecordUncheckedUpdateWithoutClassInput>
  }

  export type AttendanceRecordUpdateManyWithWhereWithoutClassInput = {
    where: AttendanceRecordScalarWhereInput
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyWithoutClassInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutClassInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutClassInput, DocumentUncheckedUpdateWithoutClassInput>
    create: XOR<DocumentCreateWithoutClassInput, DocumentUncheckedCreateWithoutClassInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutClassInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutClassInput, DocumentUncheckedUpdateWithoutClassInput>
  }

  export type DocumentUpdateManyWithWhereWithoutClassInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutClassInput>
  }

  export type GradeCategoryUpsertWithWhereUniqueWithoutClassInput = {
    where: GradeCategoryWhereUniqueInput
    update: XOR<GradeCategoryUpdateWithoutClassInput, GradeCategoryUncheckedUpdateWithoutClassInput>
    create: XOR<GradeCategoryCreateWithoutClassInput, GradeCategoryUncheckedCreateWithoutClassInput>
  }

  export type GradeCategoryUpdateWithWhereUniqueWithoutClassInput = {
    where: GradeCategoryWhereUniqueInput
    data: XOR<GradeCategoryUpdateWithoutClassInput, GradeCategoryUncheckedUpdateWithoutClassInput>
  }

  export type GradeCategoryUpdateManyWithWhereWithoutClassInput = {
    where: GradeCategoryScalarWhereInput
    data: XOR<GradeCategoryUpdateManyMutationInput, GradeCategoryUncheckedUpdateManyWithoutClassInput>
  }

  export type GradeEntryUpsertWithWhereUniqueWithoutClassInput = {
    where: GradeEntryWhereUniqueInput
    update: XOR<GradeEntryUpdateWithoutClassInput, GradeEntryUncheckedUpdateWithoutClassInput>
    create: XOR<GradeEntryCreateWithoutClassInput, GradeEntryUncheckedCreateWithoutClassInput>
  }

  export type GradeEntryUpdateWithWhereUniqueWithoutClassInput = {
    where: GradeEntryWhereUniqueInput
    data: XOR<GradeEntryUpdateWithoutClassInput, GradeEntryUncheckedUpdateWithoutClassInput>
  }

  export type GradeEntryUpdateManyWithWhereWithoutClassInput = {
    where: GradeEntryScalarWhereInput
    data: XOR<GradeEntryUpdateManyMutationInput, GradeEntryUncheckedUpdateManyWithoutClassInput>
  }

  export type UserCreateWithoutTeacherSubjectsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionCreateNestedManyWithoutUserInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestCreateNestedManyWithoutStudentInput
  }

  export type UserUncheckedCreateWithoutTeacherSubjectsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryUncheckedCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportUncheckedCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type UserCreateOrConnectWithoutTeacherSubjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeacherSubjectsInput, UserUncheckedCreateWithoutTeacherSubjectsInput>
  }

  export type SubjectCreateWithoutTeacherSubjectsInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    grade: GradeCreateNestedOneWithoutSubjectsInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutSubjectInput
    gradeCategories?: GradeCategoryCreateNestedManyWithoutSubjectInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutSubjectInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutSubjectInput
    documents?: DocumentCreateNestedManyWithoutSubjectInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutTeacherSubjectsInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    gradeId: string
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutSubjectInput
    gradeCategories?: GradeCategoryUncheckedCreateNestedManyWithoutSubjectInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutSubjectInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutSubjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSubjectInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutTeacherSubjectsInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutTeacherSubjectsInput, SubjectUncheckedCreateWithoutTeacherSubjectsInput>
  }

  export type ClassCreateWithoutTeacherSubjectsInput = {
    id?: string
    grade: GradeCreateNestedOneWithoutClassesInput
    classSection: ClassSectionCreateNestedOneWithoutClassesInput
    academicYear: AcademicYearCreateNestedOneWithoutClassesInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutClassInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClassInput
    documents?: DocumentCreateNestedManyWithoutClassInput
    gradeCategories?: GradeCategoryCreateNestedManyWithoutClassInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutTeacherSubjectsInput = {
    id?: string
    gradeId: string
    classSectionId: string
    academicYearId: string
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutClassInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClassInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClassInput
    gradeCategories?: GradeCategoryUncheckedCreateNestedManyWithoutClassInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutTeacherSubjectsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutTeacherSubjectsInput, ClassUncheckedCreateWithoutTeacherSubjectsInput>
  }

  export type AcademicYearCreateWithoutTeacherSubjectsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    createdBy: string
    semesters?: SemesterCreateNestedManyWithoutAcademicYearInput
    classes?: ClassCreateNestedManyWithoutAcademicYearInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutAcademicYearInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearUncheckedCreateWithoutTeacherSubjectsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    createdBy: string
    semesters?: SemesterUncheckedCreateNestedManyWithoutAcademicYearInput
    classes?: ClassUncheckedCreateNestedManyWithoutAcademicYearInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutAcademicYearInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearCreateOrConnectWithoutTeacherSubjectsInput = {
    where: AcademicYearWhereUniqueInput
    create: XOR<AcademicYearCreateWithoutTeacherSubjectsInput, AcademicYearUncheckedCreateWithoutTeacherSubjectsInput>
  }

  export type UserUpsertWithoutTeacherSubjectsInput = {
    update: XOR<UserUpdateWithoutTeacherSubjectsInput, UserUncheckedUpdateWithoutTeacherSubjectsInput>
    create: XOR<UserCreateWithoutTeacherSubjectsInput, UserUncheckedCreateWithoutTeacherSubjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeacherSubjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeacherSubjectsInput, UserUncheckedUpdateWithoutTeacherSubjectsInput>
  }

  export type UserUpdateWithoutTeacherSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUpdateManyWithoutUserNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUpdateManyWithoutStudentNestedInput
  }

  export type UserUncheckedUpdateWithoutTeacherSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUncheckedUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SubjectUpsertWithoutTeacherSubjectsInput = {
    update: XOR<SubjectUpdateWithoutTeacherSubjectsInput, SubjectUncheckedUpdateWithoutTeacherSubjectsInput>
    create: XOR<SubjectCreateWithoutTeacherSubjectsInput, SubjectUncheckedCreateWithoutTeacherSubjectsInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutTeacherSubjectsInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutTeacherSubjectsInput, SubjectUncheckedUpdateWithoutTeacherSubjectsInput>
  }

  export type SubjectUpdateWithoutTeacherSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: GradeUpdateOneRequiredWithoutSubjectsNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutSubjectNestedInput
    gradeCategories?: GradeCategoryUpdateManyWithoutSubjectNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutSubjectNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutSubjectNestedInput
    documents?: DocumentUpdateManyWithoutSubjectNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutTeacherSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: StringFieldUpdateOperationsInput | string
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutSubjectNestedInput
    gradeCategories?: GradeCategoryUncheckedUpdateManyWithoutSubjectNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutSubjectNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutSubjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSubjectNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type ClassUpsertWithoutTeacherSubjectsInput = {
    update: XOR<ClassUpdateWithoutTeacherSubjectsInput, ClassUncheckedUpdateWithoutTeacherSubjectsInput>
    create: XOR<ClassCreateWithoutTeacherSubjectsInput, ClassUncheckedCreateWithoutTeacherSubjectsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutTeacherSubjectsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutTeacherSubjectsInput, ClassUncheckedUpdateWithoutTeacherSubjectsInput>
  }

  export type ClassUpdateWithoutTeacherSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: GradeUpdateOneRequiredWithoutClassesNestedInput
    classSection?: ClassSectionUpdateOneRequiredWithoutClassesNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutClassesNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutClassNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClassNestedInput
    documents?: DocumentUpdateManyWithoutClassNestedInput
    gradeCategories?: GradeCategoryUpdateManyWithoutClassNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutTeacherSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    classSectionId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutClassNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClassNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClassNestedInput
    gradeCategories?: GradeCategoryUncheckedUpdateManyWithoutClassNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutClassNestedInput
  }

  export type AcademicYearUpsertWithoutTeacherSubjectsInput = {
    update: XOR<AcademicYearUpdateWithoutTeacherSubjectsInput, AcademicYearUncheckedUpdateWithoutTeacherSubjectsInput>
    create: XOR<AcademicYearCreateWithoutTeacherSubjectsInput, AcademicYearUncheckedCreateWithoutTeacherSubjectsInput>
    where?: AcademicYearWhereInput
  }

  export type AcademicYearUpdateToOneWithWhereWithoutTeacherSubjectsInput = {
    where?: AcademicYearWhereInput
    data: XOR<AcademicYearUpdateWithoutTeacherSubjectsInput, AcademicYearUncheckedUpdateWithoutTeacherSubjectsInput>
  }

  export type AcademicYearUpdateWithoutTeacherSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    semesters?: SemesterUpdateManyWithoutAcademicYearNestedInput
    classes?: ClassUpdateManyWithoutAcademicYearNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutAcademicYearNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutAcademicYearNestedInput
  }

  export type AcademicYearUncheckedUpdateWithoutTeacherSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    semesters?: SemesterUncheckedUpdateManyWithoutAcademicYearNestedInput
    classes?: ClassUncheckedUpdateManyWithoutAcademicYearNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutAcademicYearNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutAcademicYearNestedInput
  }

  export type UserCreateWithoutStudentEnrollmentsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestCreateNestedManyWithoutStudentInput
  }

  export type UserUncheckedCreateWithoutStudentEnrollmentsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryUncheckedCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportUncheckedCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type UserCreateOrConnectWithoutStudentEnrollmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentEnrollmentsInput, UserUncheckedCreateWithoutStudentEnrollmentsInput>
  }

  export type ClassCreateWithoutStudentEnrollmentsInput = {
    id?: string
    grade: GradeCreateNestedOneWithoutClassesInput
    classSection: ClassSectionCreateNestedOneWithoutClassesInput
    academicYear: AcademicYearCreateNestedOneWithoutClassesInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutClassInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClassInput
    documents?: DocumentCreateNestedManyWithoutClassInput
    gradeCategories?: GradeCategoryCreateNestedManyWithoutClassInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutStudentEnrollmentsInput = {
    id?: string
    gradeId: string
    classSectionId: string
    academicYearId: string
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutClassInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClassInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClassInput
    gradeCategories?: GradeCategoryUncheckedCreateNestedManyWithoutClassInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutStudentEnrollmentsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutStudentEnrollmentsInput, ClassUncheckedCreateWithoutStudentEnrollmentsInput>
  }

  export type AcademicYearCreateWithoutStudentEnrollmentsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    createdBy: string
    semesters?: SemesterCreateNestedManyWithoutAcademicYearInput
    classes?: ClassCreateNestedManyWithoutAcademicYearInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutAcademicYearInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearUncheckedCreateWithoutStudentEnrollmentsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    createdBy: string
    semesters?: SemesterUncheckedCreateNestedManyWithoutAcademicYearInput
    classes?: ClassUncheckedCreateNestedManyWithoutAcademicYearInput
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutAcademicYearInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearCreateOrConnectWithoutStudentEnrollmentsInput = {
    where: AcademicYearWhereUniqueInput
    create: XOR<AcademicYearCreateWithoutStudentEnrollmentsInput, AcademicYearUncheckedCreateWithoutStudentEnrollmentsInput>
  }

  export type SemesterCreateWithoutStudentEnrollmentsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    registrationOpen?: boolean
    minAverage?: number | null
    noFailedSubjects?: boolean | null
    academicYear: AcademicYearCreateNestedOneWithoutSemestersInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutSemesterInput
    gradeReports?: GradeReportCreateNestedManyWithoutSemesterInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutSemesterInput
    registrationRequests?: StudentRegistrationRequestCreateNestedManyWithoutSemesterInput
  }

  export type SemesterUncheckedCreateWithoutStudentEnrollmentsInput = {
    id?: string
    name: string
    academicYearId: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    registrationOpen?: boolean
    minAverage?: number | null
    noFailedSubjects?: boolean | null
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutSemesterInput
    gradeReports?: GradeReportUncheckedCreateNestedManyWithoutSemesterInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutSemesterInput
    registrationRequests?: StudentRegistrationRequestUncheckedCreateNestedManyWithoutSemesterInput
  }

  export type SemesterCreateOrConnectWithoutStudentEnrollmentsInput = {
    where: SemesterWhereUniqueInput
    create: XOR<SemesterCreateWithoutStudentEnrollmentsInput, SemesterUncheckedCreateWithoutStudentEnrollmentsInput>
  }

  export type UserUpsertWithoutStudentEnrollmentsInput = {
    update: XOR<UserUpdateWithoutStudentEnrollmentsInput, UserUncheckedUpdateWithoutStudentEnrollmentsInput>
    create: XOR<UserCreateWithoutStudentEnrollmentsInput, UserUncheckedCreateWithoutStudentEnrollmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudentEnrollmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudentEnrollmentsInput, UserUncheckedUpdateWithoutStudentEnrollmentsInput>
  }

  export type UserUpdateWithoutStudentEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUpdateManyWithoutStudentNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUncheckedUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ClassUpsertWithoutStudentEnrollmentsInput = {
    update: XOR<ClassUpdateWithoutStudentEnrollmentsInput, ClassUncheckedUpdateWithoutStudentEnrollmentsInput>
    create: XOR<ClassCreateWithoutStudentEnrollmentsInput, ClassUncheckedCreateWithoutStudentEnrollmentsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutStudentEnrollmentsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutStudentEnrollmentsInput, ClassUncheckedUpdateWithoutStudentEnrollmentsInput>
  }

  export type ClassUpdateWithoutStudentEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: GradeUpdateOneRequiredWithoutClassesNestedInput
    classSection?: ClassSectionUpdateOneRequiredWithoutClassesNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutClassesNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutClassNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClassNestedInput
    documents?: DocumentUpdateManyWithoutClassNestedInput
    gradeCategories?: GradeCategoryUpdateManyWithoutClassNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutStudentEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    classSectionId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutClassNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClassNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClassNestedInput
    gradeCategories?: GradeCategoryUncheckedUpdateManyWithoutClassNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutClassNestedInput
  }

  export type AcademicYearUpsertWithoutStudentEnrollmentsInput = {
    update: XOR<AcademicYearUpdateWithoutStudentEnrollmentsInput, AcademicYearUncheckedUpdateWithoutStudentEnrollmentsInput>
    create: XOR<AcademicYearCreateWithoutStudentEnrollmentsInput, AcademicYearUncheckedCreateWithoutStudentEnrollmentsInput>
    where?: AcademicYearWhereInput
  }

  export type AcademicYearUpdateToOneWithWhereWithoutStudentEnrollmentsInput = {
    where?: AcademicYearWhereInput
    data: XOR<AcademicYearUpdateWithoutStudentEnrollmentsInput, AcademicYearUncheckedUpdateWithoutStudentEnrollmentsInput>
  }

  export type AcademicYearUpdateWithoutStudentEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    semesters?: SemesterUpdateManyWithoutAcademicYearNestedInput
    classes?: ClassUpdateManyWithoutAcademicYearNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutAcademicYearNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutAcademicYearNestedInput
  }

  export type AcademicYearUncheckedUpdateWithoutStudentEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    semesters?: SemesterUncheckedUpdateManyWithoutAcademicYearNestedInput
    classes?: ClassUncheckedUpdateManyWithoutAcademicYearNestedInput
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutAcademicYearNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutAcademicYearNestedInput
  }

  export type SemesterUpsertWithoutStudentEnrollmentsInput = {
    update: XOR<SemesterUpdateWithoutStudentEnrollmentsInput, SemesterUncheckedUpdateWithoutStudentEnrollmentsInput>
    create: XOR<SemesterCreateWithoutStudentEnrollmentsInput, SemesterUncheckedCreateWithoutStudentEnrollmentsInput>
    where?: SemesterWhereInput
  }

  export type SemesterUpdateToOneWithWhereWithoutStudentEnrollmentsInput = {
    where?: SemesterWhereInput
    data: XOR<SemesterUpdateWithoutStudentEnrollmentsInput, SemesterUncheckedUpdateWithoutStudentEnrollmentsInput>
  }

  export type SemesterUpdateWithoutStudentEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    registrationOpen?: BoolFieldUpdateOperationsInput | boolean
    minAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    noFailedSubjects?: NullableBoolFieldUpdateOperationsInput | boolean | null
    academicYear?: AcademicYearUpdateOneRequiredWithoutSemestersNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutSemesterNestedInput
    gradeReports?: GradeReportUpdateManyWithoutSemesterNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutSemesterNestedInput
    registrationRequests?: StudentRegistrationRequestUpdateManyWithoutSemesterNestedInput
  }

  export type SemesterUncheckedUpdateWithoutStudentEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    registrationOpen?: BoolFieldUpdateOperationsInput | boolean
    minAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    noFailedSubjects?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutSemesterNestedInput
    gradeReports?: GradeReportUncheckedUpdateManyWithoutSemesterNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutSemesterNestedInput
    registrationRequests?: StudentRegistrationRequestUncheckedUpdateManyWithoutSemesterNestedInput
  }

  export type ClassCreateWithoutClassSchedulesInput = {
    id?: string
    grade: GradeCreateNestedOneWithoutClassesInput
    classSection: ClassSectionCreateNestedOneWithoutClassesInput
    academicYear: AcademicYearCreateNestedOneWithoutClassesInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutClassInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClassInput
    documents?: DocumentCreateNestedManyWithoutClassInput
    gradeCategories?: GradeCategoryCreateNestedManyWithoutClassInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutClassSchedulesInput = {
    id?: string
    gradeId: string
    classSectionId: string
    academicYearId: string
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutClassInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClassInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClassInput
    gradeCategories?: GradeCategoryUncheckedCreateNestedManyWithoutClassInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutClassSchedulesInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutClassSchedulesInput, ClassUncheckedCreateWithoutClassSchedulesInput>
  }

  export type SubjectCreateWithoutClassSchedulesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    grade: GradeCreateNestedOneWithoutSubjectsInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutSubjectInput
    gradeCategories?: GradeCategoryCreateNestedManyWithoutSubjectInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutSubjectInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutSubjectInput
    documents?: DocumentCreateNestedManyWithoutSubjectInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutClassSchedulesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    gradeId: string
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutSubjectInput
    gradeCategories?: GradeCategoryUncheckedCreateNestedManyWithoutSubjectInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutSubjectInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutSubjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSubjectInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutClassSchedulesInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutClassSchedulesInput, SubjectUncheckedCreateWithoutClassSchedulesInput>
  }

  export type UserCreateWithoutClassSchedulesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    attendanceRecordsAsStudent?: AttendanceRecordCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestCreateNestedManyWithoutStudentInput
  }

  export type UserUncheckedCreateWithoutClassSchedulesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryUncheckedCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportUncheckedCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type UserCreateOrConnectWithoutClassSchedulesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClassSchedulesInput, UserUncheckedCreateWithoutClassSchedulesInput>
  }

  export type ClassUpsertWithoutClassSchedulesInput = {
    update: XOR<ClassUpdateWithoutClassSchedulesInput, ClassUncheckedUpdateWithoutClassSchedulesInput>
    create: XOR<ClassCreateWithoutClassSchedulesInput, ClassUncheckedCreateWithoutClassSchedulesInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutClassSchedulesInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutClassSchedulesInput, ClassUncheckedUpdateWithoutClassSchedulesInput>
  }

  export type ClassUpdateWithoutClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: GradeUpdateOneRequiredWithoutClassesNestedInput
    classSection?: ClassSectionUpdateOneRequiredWithoutClassesNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutClassesNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutClassNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClassNestedInput
    documents?: DocumentUpdateManyWithoutClassNestedInput
    gradeCategories?: GradeCategoryUpdateManyWithoutClassNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    classSectionId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutClassNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClassNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClassNestedInput
    gradeCategories?: GradeCategoryUncheckedUpdateManyWithoutClassNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutClassNestedInput
  }

  export type SubjectUpsertWithoutClassSchedulesInput = {
    update: XOR<SubjectUpdateWithoutClassSchedulesInput, SubjectUncheckedUpdateWithoutClassSchedulesInput>
    create: XOR<SubjectCreateWithoutClassSchedulesInput, SubjectUncheckedCreateWithoutClassSchedulesInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutClassSchedulesInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutClassSchedulesInput, SubjectUncheckedUpdateWithoutClassSchedulesInput>
  }

  export type SubjectUpdateWithoutClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: GradeUpdateOneRequiredWithoutSubjectsNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutSubjectNestedInput
    gradeCategories?: GradeCategoryUpdateManyWithoutSubjectNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutSubjectNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutSubjectNestedInput
    documents?: DocumentUpdateManyWithoutSubjectNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: StringFieldUpdateOperationsInput | string
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    gradeCategories?: GradeCategoryUncheckedUpdateManyWithoutSubjectNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutSubjectNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutSubjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSubjectNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type UserUpsertWithoutClassSchedulesInput = {
    update: XOR<UserUpdateWithoutClassSchedulesInput, UserUncheckedUpdateWithoutClassSchedulesInput>
    create: XOR<UserCreateWithoutClassSchedulesInput, UserUncheckedCreateWithoutClassSchedulesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClassSchedulesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClassSchedulesInput, UserUncheckedUpdateWithoutClassSchedulesInput>
  }

  export type UserUpdateWithoutClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUpdateManyWithoutStudentNestedInput
  }

  export type UserUncheckedUpdateWithoutClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUncheckedUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type UserCreateWithoutAttendanceRecordsAsStudentInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutTeacherInput
    attendanceRecordsMarked?: AttendanceRecordCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestCreateNestedManyWithoutStudentInput
  }

  export type UserUncheckedCreateWithoutAttendanceRecordsAsStudentInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutTeacherInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryUncheckedCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportUncheckedCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type UserCreateOrConnectWithoutAttendanceRecordsAsStudentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttendanceRecordsAsStudentInput, UserUncheckedCreateWithoutAttendanceRecordsAsStudentInput>
  }

  export type ClassCreateWithoutAttendanceRecordsInput = {
    id?: string
    grade: GradeCreateNestedOneWithoutClassesInput
    classSection: ClassSectionCreateNestedOneWithoutClassesInput
    academicYear: AcademicYearCreateNestedOneWithoutClassesInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutClassInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutClassInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutClassInput
    documents?: DocumentCreateNestedManyWithoutClassInput
    gradeCategories?: GradeCategoryCreateNestedManyWithoutClassInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutAttendanceRecordsInput = {
    id?: string
    gradeId: string
    classSectionId: string
    academicYearId: string
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutClassInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutClassInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutClassInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClassInput
    gradeCategories?: GradeCategoryUncheckedCreateNestedManyWithoutClassInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutAttendanceRecordsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutAttendanceRecordsInput, ClassUncheckedCreateWithoutAttendanceRecordsInput>
  }

  export type SubjectCreateWithoutAttendanceRecordsInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    grade: GradeCreateNestedOneWithoutSubjectsInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutSubjectInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutSubjectInput
    gradeCategories?: GradeCategoryCreateNestedManyWithoutSubjectInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutSubjectInput
    documents?: DocumentCreateNestedManyWithoutSubjectInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutAttendanceRecordsInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    gradeId: string
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutSubjectInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutSubjectInput
    gradeCategories?: GradeCategoryUncheckedCreateNestedManyWithoutSubjectInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutSubjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSubjectInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutAttendanceRecordsInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutAttendanceRecordsInput, SubjectUncheckedCreateWithoutAttendanceRecordsInput>
  }

  export type UserCreateWithoutAttendanceRecordsMarkedInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordCreateNestedManyWithoutStudentInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestCreateNestedManyWithoutStudentInput
  }

  export type UserUncheckedCreateWithoutAttendanceRecordsMarkedInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryUncheckedCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportUncheckedCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type UserCreateOrConnectWithoutAttendanceRecordsMarkedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttendanceRecordsMarkedInput, UserUncheckedCreateWithoutAttendanceRecordsMarkedInput>
  }

  export type UserUpsertWithoutAttendanceRecordsAsStudentInput = {
    update: XOR<UserUpdateWithoutAttendanceRecordsAsStudentInput, UserUncheckedUpdateWithoutAttendanceRecordsAsStudentInput>
    create: XOR<UserCreateWithoutAttendanceRecordsAsStudentInput, UserUncheckedCreateWithoutAttendanceRecordsAsStudentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttendanceRecordsAsStudentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttendanceRecordsAsStudentInput, UserUncheckedUpdateWithoutAttendanceRecordsAsStudentInput>
  }

  export type UserUpdateWithoutAttendanceRecordsAsStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutTeacherNestedInput
    attendanceRecordsMarked?: AttendanceRecordUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUpdateManyWithoutStudentNestedInput
  }

  export type UserUncheckedUpdateWithoutAttendanceRecordsAsStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUncheckedUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ClassUpsertWithoutAttendanceRecordsInput = {
    update: XOR<ClassUpdateWithoutAttendanceRecordsInput, ClassUncheckedUpdateWithoutAttendanceRecordsInput>
    create: XOR<ClassCreateWithoutAttendanceRecordsInput, ClassUncheckedCreateWithoutAttendanceRecordsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutAttendanceRecordsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutAttendanceRecordsInput, ClassUncheckedUpdateWithoutAttendanceRecordsInput>
  }

  export type ClassUpdateWithoutAttendanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: GradeUpdateOneRequiredWithoutClassesNestedInput
    classSection?: ClassSectionUpdateOneRequiredWithoutClassesNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutClassesNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutClassNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutClassNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutClassNestedInput
    documents?: DocumentUpdateManyWithoutClassNestedInput
    gradeCategories?: GradeCategoryUpdateManyWithoutClassNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutAttendanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    classSectionId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutClassNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutClassNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutClassNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClassNestedInput
    gradeCategories?: GradeCategoryUncheckedUpdateManyWithoutClassNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutClassNestedInput
  }

  export type SubjectUpsertWithoutAttendanceRecordsInput = {
    update: XOR<SubjectUpdateWithoutAttendanceRecordsInput, SubjectUncheckedUpdateWithoutAttendanceRecordsInput>
    create: XOR<SubjectCreateWithoutAttendanceRecordsInput, SubjectUncheckedCreateWithoutAttendanceRecordsInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutAttendanceRecordsInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutAttendanceRecordsInput, SubjectUncheckedUpdateWithoutAttendanceRecordsInput>
  }

  export type SubjectUpdateWithoutAttendanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: GradeUpdateOneRequiredWithoutSubjectsNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutSubjectNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutSubjectNestedInput
    gradeCategories?: GradeCategoryUpdateManyWithoutSubjectNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutSubjectNestedInput
    documents?: DocumentUpdateManyWithoutSubjectNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutAttendanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: StringFieldUpdateOperationsInput | string
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutSubjectNestedInput
    gradeCategories?: GradeCategoryUncheckedUpdateManyWithoutSubjectNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutSubjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSubjectNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type UserUpsertWithoutAttendanceRecordsMarkedInput = {
    update: XOR<UserUpdateWithoutAttendanceRecordsMarkedInput, UserUncheckedUpdateWithoutAttendanceRecordsMarkedInput>
    create: XOR<UserCreateWithoutAttendanceRecordsMarkedInput, UserUncheckedCreateWithoutAttendanceRecordsMarkedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttendanceRecordsMarkedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttendanceRecordsMarkedInput, UserUncheckedUpdateWithoutAttendanceRecordsMarkedInput>
  }

  export type UserUpdateWithoutAttendanceRecordsMarkedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUpdateManyWithoutStudentNestedInput
  }

  export type UserUncheckedUpdateWithoutAttendanceRecordsMarkedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUncheckedUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type UserCreateWithoutAttendanceSummariesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordCreateNestedManyWithoutMarkedByInput
    gradeEntriesAsStudent?: GradeEntryCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestCreateNestedManyWithoutStudentInput
  }

  export type UserUncheckedCreateWithoutAttendanceSummariesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedCreateNestedManyWithoutMarkedByInput
    gradeEntriesAsStudent?: GradeEntryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryUncheckedCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportUncheckedCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type UserCreateOrConnectWithoutAttendanceSummariesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttendanceSummariesInput, UserUncheckedCreateWithoutAttendanceSummariesInput>
  }

  export type SubjectCreateWithoutAttendanceSummariesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    grade: GradeCreateNestedOneWithoutSubjectsInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutSubjectInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutSubjectInput
    gradeCategories?: GradeCategoryCreateNestedManyWithoutSubjectInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutSubjectInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutSubjectInput
    documents?: DocumentCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutAttendanceSummariesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    gradeId: string
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutSubjectInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutSubjectInput
    gradeCategories?: GradeCategoryUncheckedCreateNestedManyWithoutSubjectInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutSubjectInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutSubjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutAttendanceSummariesInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutAttendanceSummariesInput, SubjectUncheckedCreateWithoutAttendanceSummariesInput>
  }

  export type SemesterCreateWithoutAttendanceSummariesInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    registrationOpen?: boolean
    minAverage?: number | null
    noFailedSubjects?: boolean | null
    academicYear: AcademicYearCreateNestedOneWithoutSemestersInput
    gradeReports?: GradeReportCreateNestedManyWithoutSemesterInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutSemesterInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutSemesterInput
    registrationRequests?: StudentRegistrationRequestCreateNestedManyWithoutSemesterInput
  }

  export type SemesterUncheckedCreateWithoutAttendanceSummariesInput = {
    id?: string
    name: string
    academicYearId: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    registrationOpen?: boolean
    minAverage?: number | null
    noFailedSubjects?: boolean | null
    gradeReports?: GradeReportUncheckedCreateNestedManyWithoutSemesterInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutSemesterInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutSemesterInput
    registrationRequests?: StudentRegistrationRequestUncheckedCreateNestedManyWithoutSemesterInput
  }

  export type SemesterCreateOrConnectWithoutAttendanceSummariesInput = {
    where: SemesterWhereUniqueInput
    create: XOR<SemesterCreateWithoutAttendanceSummariesInput, SemesterUncheckedCreateWithoutAttendanceSummariesInput>
  }

  export type UserUpsertWithoutAttendanceSummariesInput = {
    update: XOR<UserUpdateWithoutAttendanceSummariesInput, UserUncheckedUpdateWithoutAttendanceSummariesInput>
    create: XOR<UserCreateWithoutAttendanceSummariesInput, UserUncheckedCreateWithoutAttendanceSummariesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttendanceSummariesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttendanceSummariesInput, UserUncheckedUpdateWithoutAttendanceSummariesInput>
  }

  export type UserUpdateWithoutAttendanceSummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUpdateManyWithoutMarkedByNestedInput
    gradeEntriesAsStudent?: GradeEntryUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUpdateManyWithoutStudentNestedInput
  }

  export type UserUncheckedUpdateWithoutAttendanceSummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedUpdateManyWithoutMarkedByNestedInput
    gradeEntriesAsStudent?: GradeEntryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUncheckedUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SubjectUpsertWithoutAttendanceSummariesInput = {
    update: XOR<SubjectUpdateWithoutAttendanceSummariesInput, SubjectUncheckedUpdateWithoutAttendanceSummariesInput>
    create: XOR<SubjectCreateWithoutAttendanceSummariesInput, SubjectUncheckedCreateWithoutAttendanceSummariesInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutAttendanceSummariesInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutAttendanceSummariesInput, SubjectUncheckedUpdateWithoutAttendanceSummariesInput>
  }

  export type SubjectUpdateWithoutAttendanceSummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: GradeUpdateOneRequiredWithoutSubjectsNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutSubjectNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutSubjectNestedInput
    gradeCategories?: GradeCategoryUpdateManyWithoutSubjectNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutSubjectNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutSubjectNestedInput
    documents?: DocumentUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutAttendanceSummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: StringFieldUpdateOperationsInput | string
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutSubjectNestedInput
    gradeCategories?: GradeCategoryUncheckedUpdateManyWithoutSubjectNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutSubjectNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutSubjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SemesterUpsertWithoutAttendanceSummariesInput = {
    update: XOR<SemesterUpdateWithoutAttendanceSummariesInput, SemesterUncheckedUpdateWithoutAttendanceSummariesInput>
    create: XOR<SemesterCreateWithoutAttendanceSummariesInput, SemesterUncheckedCreateWithoutAttendanceSummariesInput>
    where?: SemesterWhereInput
  }

  export type SemesterUpdateToOneWithWhereWithoutAttendanceSummariesInput = {
    where?: SemesterWhereInput
    data: XOR<SemesterUpdateWithoutAttendanceSummariesInput, SemesterUncheckedUpdateWithoutAttendanceSummariesInput>
  }

  export type SemesterUpdateWithoutAttendanceSummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    registrationOpen?: BoolFieldUpdateOperationsInput | boolean
    minAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    noFailedSubjects?: NullableBoolFieldUpdateOperationsInput | boolean | null
    academicYear?: AcademicYearUpdateOneRequiredWithoutSemestersNestedInput
    gradeReports?: GradeReportUpdateManyWithoutSemesterNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutSemesterNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutSemesterNestedInput
    registrationRequests?: StudentRegistrationRequestUpdateManyWithoutSemesterNestedInput
  }

  export type SemesterUncheckedUpdateWithoutAttendanceSummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    registrationOpen?: BoolFieldUpdateOperationsInput | boolean
    minAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    noFailedSubjects?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gradeReports?: GradeReportUncheckedUpdateManyWithoutSemesterNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutSemesterNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutSemesterNestedInput
    registrationRequests?: StudentRegistrationRequestUncheckedUpdateManyWithoutSemesterNestedInput
  }

  export type ClassCreateWithoutGradeCategoriesInput = {
    id?: string
    grade: GradeCreateNestedOneWithoutClassesInput
    classSection: ClassSectionCreateNestedOneWithoutClassesInput
    academicYear: AcademicYearCreateNestedOneWithoutClassesInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutClassInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutClassInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClassInput
    documents?: DocumentCreateNestedManyWithoutClassInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutGradeCategoriesInput = {
    id?: string
    gradeId: string
    classSectionId: string
    academicYearId: string
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutClassInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutClassInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClassInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClassInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutGradeCategoriesInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutGradeCategoriesInput, ClassUncheckedCreateWithoutGradeCategoriesInput>
  }

  export type SubjectCreateWithoutGradeCategoriesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    grade: GradeCreateNestedOneWithoutSubjectsInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutSubjectInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutSubjectInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutSubjectInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutSubjectInput
    documents?: DocumentCreateNestedManyWithoutSubjectInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutGradeCategoriesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    gradeId: string
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutSubjectInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutSubjectInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutSubjectInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutSubjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSubjectInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutGradeCategoriesInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutGradeCategoriesInput, SubjectUncheckedCreateWithoutGradeCategoriesInput>
  }

  export type GradeEntryCreateWithoutCategoryInput = {
    id?: string
    pointsEarned: number
    totalPoints: number
    date: Date | string
    student: UserCreateNestedOneWithoutGradeEntriesAsStudentInput
    subject: SubjectCreateNestedOneWithoutGradeEntriesInput
    class: ClassCreateNestedOneWithoutGradeEntriesInput
    academicYear: AcademicYearCreateNestedOneWithoutGradeEntriesInput
    semester: SemesterCreateNestedOneWithoutGradeEntriesInput
    createdBy: UserCreateNestedOneWithoutGradeEntriesCreatedInput
  }

  export type GradeEntryUncheckedCreateWithoutCategoryInput = {
    id?: string
    studentId: string
    subjectId: string
    classId: string
    academicYearId: string
    pointsEarned: number
    totalPoints: number
    date: Date | string
    semesterId: string
    createdById: string
  }

  export type GradeEntryCreateOrConnectWithoutCategoryInput = {
    where: GradeEntryWhereUniqueInput
    create: XOR<GradeEntryCreateWithoutCategoryInput, GradeEntryUncheckedCreateWithoutCategoryInput>
  }

  export type GradeEntryCreateManyCategoryInputEnvelope = {
    data: GradeEntryCreateManyCategoryInput | GradeEntryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ClassUpsertWithoutGradeCategoriesInput = {
    update: XOR<ClassUpdateWithoutGradeCategoriesInput, ClassUncheckedUpdateWithoutGradeCategoriesInput>
    create: XOR<ClassCreateWithoutGradeCategoriesInput, ClassUncheckedCreateWithoutGradeCategoriesInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutGradeCategoriesInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutGradeCategoriesInput, ClassUncheckedUpdateWithoutGradeCategoriesInput>
  }

  export type ClassUpdateWithoutGradeCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: GradeUpdateOneRequiredWithoutClassesNestedInput
    classSection?: ClassSectionUpdateOneRequiredWithoutClassesNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutClassesNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutClassNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutClassNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClassNestedInput
    documents?: DocumentUpdateManyWithoutClassNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutGradeCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    classSectionId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutClassNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutClassNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClassNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClassNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutClassNestedInput
  }

  export type SubjectUpsertWithoutGradeCategoriesInput = {
    update: XOR<SubjectUpdateWithoutGradeCategoriesInput, SubjectUncheckedUpdateWithoutGradeCategoriesInput>
    create: XOR<SubjectCreateWithoutGradeCategoriesInput, SubjectUncheckedCreateWithoutGradeCategoriesInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutGradeCategoriesInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutGradeCategoriesInput, SubjectUncheckedUpdateWithoutGradeCategoriesInput>
  }

  export type SubjectUpdateWithoutGradeCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: GradeUpdateOneRequiredWithoutSubjectsNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutSubjectNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutSubjectNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutSubjectNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutSubjectNestedInput
    documents?: DocumentUpdateManyWithoutSubjectNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutGradeCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: StringFieldUpdateOperationsInput | string
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutSubjectNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutSubjectNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutSubjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSubjectNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type GradeEntryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: GradeEntryWhereUniqueInput
    update: XOR<GradeEntryUpdateWithoutCategoryInput, GradeEntryUncheckedUpdateWithoutCategoryInput>
    create: XOR<GradeEntryCreateWithoutCategoryInput, GradeEntryUncheckedCreateWithoutCategoryInput>
  }

  export type GradeEntryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: GradeEntryWhereUniqueInput
    data: XOR<GradeEntryUpdateWithoutCategoryInput, GradeEntryUncheckedUpdateWithoutCategoryInput>
  }

  export type GradeEntryUpdateManyWithWhereWithoutCategoryInput = {
    where: GradeEntryScalarWhereInput
    data: XOR<GradeEntryUpdateManyMutationInput, GradeEntryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type UserCreateWithoutGradeEntriesAsStudentInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestCreateNestedManyWithoutStudentInput
  }

  export type UserUncheckedCreateWithoutGradeEntriesAsStudentInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryUncheckedCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportUncheckedCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type UserCreateOrConnectWithoutGradeEntriesAsStudentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGradeEntriesAsStudentInput, UserUncheckedCreateWithoutGradeEntriesAsStudentInput>
  }

  export type SubjectCreateWithoutGradeEntriesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    grade: GradeCreateNestedOneWithoutSubjectsInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutSubjectInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutSubjectInput
    gradeCategories?: GradeCategoryCreateNestedManyWithoutSubjectInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutSubjectInput
    documents?: DocumentCreateNestedManyWithoutSubjectInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutGradeEntriesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    gradeId: string
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutSubjectInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutSubjectInput
    gradeCategories?: GradeCategoryUncheckedCreateNestedManyWithoutSubjectInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutSubjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutSubjectInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutGradeEntriesInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutGradeEntriesInput, SubjectUncheckedCreateWithoutGradeEntriesInput>
  }

  export type GradeCategoryCreateWithoutGradeEntriesInput = {
    id?: string
    name: string
    weight: number
    class: ClassCreateNestedOneWithoutGradeCategoriesInput
    subject: SubjectCreateNestedOneWithoutGradeCategoriesInput
  }

  export type GradeCategoryUncheckedCreateWithoutGradeEntriesInput = {
    id?: string
    name: string
    weight: number
    classId: string
    subjectId: string
  }

  export type GradeCategoryCreateOrConnectWithoutGradeEntriesInput = {
    where: GradeCategoryWhereUniqueInput
    create: XOR<GradeCategoryCreateWithoutGradeEntriesInput, GradeCategoryUncheckedCreateWithoutGradeEntriesInput>
  }

  export type ClassCreateWithoutGradeEntriesInput = {
    id?: string
    grade: GradeCreateNestedOneWithoutClassesInput
    classSection: ClassSectionCreateNestedOneWithoutClassesInput
    academicYear: AcademicYearCreateNestedOneWithoutClassesInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutClassInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutClassInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClassInput
    documents?: DocumentCreateNestedManyWithoutClassInput
    gradeCategories?: GradeCategoryCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutGradeEntriesInput = {
    id?: string
    gradeId: string
    classSectionId: string
    academicYearId: string
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutClassInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutClassInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClassInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClassInput
    gradeCategories?: GradeCategoryUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutGradeEntriesInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutGradeEntriesInput, ClassUncheckedCreateWithoutGradeEntriesInput>
  }

  export type AcademicYearCreateWithoutGradeEntriesInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    createdBy: string
    semesters?: SemesterCreateNestedManyWithoutAcademicYearInput
    classes?: ClassCreateNestedManyWithoutAcademicYearInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutAcademicYearInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearUncheckedCreateWithoutGradeEntriesInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    createdBy: string
    semesters?: SemesterUncheckedCreateNestedManyWithoutAcademicYearInput
    classes?: ClassUncheckedCreateNestedManyWithoutAcademicYearInput
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutAcademicYearInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearCreateOrConnectWithoutGradeEntriesInput = {
    where: AcademicYearWhereUniqueInput
    create: XOR<AcademicYearCreateWithoutGradeEntriesInput, AcademicYearUncheckedCreateWithoutGradeEntriesInput>
  }

  export type SemesterCreateWithoutGradeEntriesInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    registrationOpen?: boolean
    minAverage?: number | null
    noFailedSubjects?: boolean | null
    academicYear: AcademicYearCreateNestedOneWithoutSemestersInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutSemesterInput
    gradeReports?: GradeReportCreateNestedManyWithoutSemesterInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutSemesterInput
    registrationRequests?: StudentRegistrationRequestCreateNestedManyWithoutSemesterInput
  }

  export type SemesterUncheckedCreateWithoutGradeEntriesInput = {
    id?: string
    name: string
    academicYearId: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    registrationOpen?: boolean
    minAverage?: number | null
    noFailedSubjects?: boolean | null
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutSemesterInput
    gradeReports?: GradeReportUncheckedCreateNestedManyWithoutSemesterInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutSemesterInput
    registrationRequests?: StudentRegistrationRequestUncheckedCreateNestedManyWithoutSemesterInput
  }

  export type SemesterCreateOrConnectWithoutGradeEntriesInput = {
    where: SemesterWhereUniqueInput
    create: XOR<SemesterCreateWithoutGradeEntriesInput, SemesterUncheckedCreateWithoutGradeEntriesInput>
  }

  export type UserCreateWithoutGradeEntriesCreatedInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryCreateNestedManyWithoutStudentInput
    gradeReports?: GradeReportCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestCreateNestedManyWithoutStudentInput
  }

  export type UserUncheckedCreateWithoutGradeEntriesCreatedInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryUncheckedCreateNestedManyWithoutStudentInput
    gradeReports?: GradeReportUncheckedCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type UserCreateOrConnectWithoutGradeEntriesCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGradeEntriesCreatedInput, UserUncheckedCreateWithoutGradeEntriesCreatedInput>
  }

  export type UserUpsertWithoutGradeEntriesAsStudentInput = {
    update: XOR<UserUpdateWithoutGradeEntriesAsStudentInput, UserUncheckedUpdateWithoutGradeEntriesAsStudentInput>
    create: XOR<UserCreateWithoutGradeEntriesAsStudentInput, UserUncheckedCreateWithoutGradeEntriesAsStudentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGradeEntriesAsStudentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGradeEntriesAsStudentInput, UserUncheckedUpdateWithoutGradeEntriesAsStudentInput>
  }

  export type UserUpdateWithoutGradeEntriesAsStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUpdateManyWithoutStudentNestedInput
  }

  export type UserUncheckedUpdateWithoutGradeEntriesAsStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUncheckedUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SubjectUpsertWithoutGradeEntriesInput = {
    update: XOR<SubjectUpdateWithoutGradeEntriesInput, SubjectUncheckedUpdateWithoutGradeEntriesInput>
    create: XOR<SubjectCreateWithoutGradeEntriesInput, SubjectUncheckedCreateWithoutGradeEntriesInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutGradeEntriesInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutGradeEntriesInput, SubjectUncheckedUpdateWithoutGradeEntriesInput>
  }

  export type SubjectUpdateWithoutGradeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: GradeUpdateOneRequiredWithoutSubjectsNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutSubjectNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutSubjectNestedInput
    gradeCategories?: GradeCategoryUpdateManyWithoutSubjectNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutSubjectNestedInput
    documents?: DocumentUpdateManyWithoutSubjectNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutGradeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: StringFieldUpdateOperationsInput | string
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutSubjectNestedInput
    gradeCategories?: GradeCategoryUncheckedUpdateManyWithoutSubjectNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutSubjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSubjectNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type GradeCategoryUpsertWithoutGradeEntriesInput = {
    update: XOR<GradeCategoryUpdateWithoutGradeEntriesInput, GradeCategoryUncheckedUpdateWithoutGradeEntriesInput>
    create: XOR<GradeCategoryCreateWithoutGradeEntriesInput, GradeCategoryUncheckedCreateWithoutGradeEntriesInput>
    where?: GradeCategoryWhereInput
  }

  export type GradeCategoryUpdateToOneWithWhereWithoutGradeEntriesInput = {
    where?: GradeCategoryWhereInput
    data: XOR<GradeCategoryUpdateWithoutGradeEntriesInput, GradeCategoryUncheckedUpdateWithoutGradeEntriesInput>
  }

  export type GradeCategoryUpdateWithoutGradeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    class?: ClassUpdateOneRequiredWithoutGradeCategoriesNestedInput
    subject?: SubjectUpdateOneRequiredWithoutGradeCategoriesNestedInput
  }

  export type GradeCategoryUncheckedUpdateWithoutGradeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
  }

  export type ClassUpsertWithoutGradeEntriesInput = {
    update: XOR<ClassUpdateWithoutGradeEntriesInput, ClassUncheckedUpdateWithoutGradeEntriesInput>
    create: XOR<ClassCreateWithoutGradeEntriesInput, ClassUncheckedCreateWithoutGradeEntriesInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutGradeEntriesInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutGradeEntriesInput, ClassUncheckedUpdateWithoutGradeEntriesInput>
  }

  export type ClassUpdateWithoutGradeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: GradeUpdateOneRequiredWithoutClassesNestedInput
    classSection?: ClassSectionUpdateOneRequiredWithoutClassesNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutClassesNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutClassNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutClassNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClassNestedInput
    documents?: DocumentUpdateManyWithoutClassNestedInput
    gradeCategories?: GradeCategoryUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutGradeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    classSectionId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutClassNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutClassNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClassNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClassNestedInput
    gradeCategories?: GradeCategoryUncheckedUpdateManyWithoutClassNestedInput
  }

  export type AcademicYearUpsertWithoutGradeEntriesInput = {
    update: XOR<AcademicYearUpdateWithoutGradeEntriesInput, AcademicYearUncheckedUpdateWithoutGradeEntriesInput>
    create: XOR<AcademicYearCreateWithoutGradeEntriesInput, AcademicYearUncheckedCreateWithoutGradeEntriesInput>
    where?: AcademicYearWhereInput
  }

  export type AcademicYearUpdateToOneWithWhereWithoutGradeEntriesInput = {
    where?: AcademicYearWhereInput
    data: XOR<AcademicYearUpdateWithoutGradeEntriesInput, AcademicYearUncheckedUpdateWithoutGradeEntriesInput>
  }

  export type AcademicYearUpdateWithoutGradeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    semesters?: SemesterUpdateManyWithoutAcademicYearNestedInput
    classes?: ClassUpdateManyWithoutAcademicYearNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutAcademicYearNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutAcademicYearNestedInput
  }

  export type AcademicYearUncheckedUpdateWithoutGradeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    semesters?: SemesterUncheckedUpdateManyWithoutAcademicYearNestedInput
    classes?: ClassUncheckedUpdateManyWithoutAcademicYearNestedInput
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutAcademicYearNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutAcademicYearNestedInput
  }

  export type SemesterUpsertWithoutGradeEntriesInput = {
    update: XOR<SemesterUpdateWithoutGradeEntriesInput, SemesterUncheckedUpdateWithoutGradeEntriesInput>
    create: XOR<SemesterCreateWithoutGradeEntriesInput, SemesterUncheckedCreateWithoutGradeEntriesInput>
    where?: SemesterWhereInput
  }

  export type SemesterUpdateToOneWithWhereWithoutGradeEntriesInput = {
    where?: SemesterWhereInput
    data: XOR<SemesterUpdateWithoutGradeEntriesInput, SemesterUncheckedUpdateWithoutGradeEntriesInput>
  }

  export type SemesterUpdateWithoutGradeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    registrationOpen?: BoolFieldUpdateOperationsInput | boolean
    minAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    noFailedSubjects?: NullableBoolFieldUpdateOperationsInput | boolean | null
    academicYear?: AcademicYearUpdateOneRequiredWithoutSemestersNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutSemesterNestedInput
    gradeReports?: GradeReportUpdateManyWithoutSemesterNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutSemesterNestedInput
    registrationRequests?: StudentRegistrationRequestUpdateManyWithoutSemesterNestedInput
  }

  export type SemesterUncheckedUpdateWithoutGradeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    registrationOpen?: BoolFieldUpdateOperationsInput | boolean
    minAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    noFailedSubjects?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutSemesterNestedInput
    gradeReports?: GradeReportUncheckedUpdateManyWithoutSemesterNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutSemesterNestedInput
    registrationRequests?: StudentRegistrationRequestUncheckedUpdateManyWithoutSemesterNestedInput
  }

  export type UserUpsertWithoutGradeEntriesCreatedInput = {
    update: XOR<UserUpdateWithoutGradeEntriesCreatedInput, UserUncheckedUpdateWithoutGradeEntriesCreatedInput>
    create: XOR<UserCreateWithoutGradeEntriesCreatedInput, UserUncheckedCreateWithoutGradeEntriesCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGradeEntriesCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGradeEntriesCreatedInput, UserUncheckedUpdateWithoutGradeEntriesCreatedInput>
  }

  export type UserUpdateWithoutGradeEntriesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUpdateManyWithoutStudentNestedInput
    gradeReports?: GradeReportUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUpdateManyWithoutStudentNestedInput
  }

  export type UserUncheckedUpdateWithoutGradeEntriesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUncheckedUpdateManyWithoutStudentNestedInput
    gradeReports?: GradeReportUncheckedUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type UserCreateWithoutGradeReportsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryCreateNestedManyWithoutCreatedByInput
    registrationRequests?: StudentRegistrationRequestCreateNestedManyWithoutStudentInput
  }

  export type UserUncheckedCreateWithoutGradeReportsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryUncheckedCreateNestedManyWithoutCreatedByInput
    registrationRequests?: StudentRegistrationRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type UserCreateOrConnectWithoutGradeReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGradeReportsInput, UserUncheckedCreateWithoutGradeReportsInput>
  }

  export type SemesterCreateWithoutGradeReportsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    registrationOpen?: boolean
    minAverage?: number | null
    noFailedSubjects?: boolean | null
    academicYear: AcademicYearCreateNestedOneWithoutSemestersInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutSemesterInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutSemesterInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutSemesterInput
    registrationRequests?: StudentRegistrationRequestCreateNestedManyWithoutSemesterInput
  }

  export type SemesterUncheckedCreateWithoutGradeReportsInput = {
    id?: string
    name: string
    academicYearId: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    registrationOpen?: boolean
    minAverage?: number | null
    noFailedSubjects?: boolean | null
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutSemesterInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutSemesterInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutSemesterInput
    registrationRequests?: StudentRegistrationRequestUncheckedCreateNestedManyWithoutSemesterInput
  }

  export type SemesterCreateOrConnectWithoutGradeReportsInput = {
    where: SemesterWhereUniqueInput
    create: XOR<SemesterCreateWithoutGradeReportsInput, SemesterUncheckedCreateWithoutGradeReportsInput>
  }

  export type UserUpsertWithoutGradeReportsInput = {
    update: XOR<UserUpdateWithoutGradeReportsInput, UserUncheckedUpdateWithoutGradeReportsInput>
    create: XOR<UserCreateWithoutGradeReportsInput, UserUncheckedCreateWithoutGradeReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGradeReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGradeReportsInput, UserUncheckedUpdateWithoutGradeReportsInput>
  }

  export type UserUpdateWithoutGradeReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUpdateManyWithoutCreatedByNestedInput
    registrationRequests?: StudentRegistrationRequestUpdateManyWithoutStudentNestedInput
  }

  export type UserUncheckedUpdateWithoutGradeReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    registrationRequests?: StudentRegistrationRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SemesterUpsertWithoutGradeReportsInput = {
    update: XOR<SemesterUpdateWithoutGradeReportsInput, SemesterUncheckedUpdateWithoutGradeReportsInput>
    create: XOR<SemesterCreateWithoutGradeReportsInput, SemesterUncheckedCreateWithoutGradeReportsInput>
    where?: SemesterWhereInput
  }

  export type SemesterUpdateToOneWithWhereWithoutGradeReportsInput = {
    where?: SemesterWhereInput
    data: XOR<SemesterUpdateWithoutGradeReportsInput, SemesterUncheckedUpdateWithoutGradeReportsInput>
  }

  export type SemesterUpdateWithoutGradeReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    registrationOpen?: BoolFieldUpdateOperationsInput | boolean
    minAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    noFailedSubjects?: NullableBoolFieldUpdateOperationsInput | boolean | null
    academicYear?: AcademicYearUpdateOneRequiredWithoutSemestersNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutSemesterNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutSemesterNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutSemesterNestedInput
    registrationRequests?: StudentRegistrationRequestUpdateManyWithoutSemesterNestedInput
  }

  export type SemesterUncheckedUpdateWithoutGradeReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    registrationOpen?: BoolFieldUpdateOperationsInput | boolean
    minAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    noFailedSubjects?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutSemesterNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutSemesterNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutSemesterNestedInput
    registrationRequests?: StudentRegistrationRequestUncheckedUpdateManyWithoutSemesterNestedInput
  }

  export type UserCreateWithoutAnnouncementsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestCreateNestedManyWithoutStudentInput
  }

  export type UserUncheckedCreateWithoutAnnouncementsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryUncheckedCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportUncheckedCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type UserCreateOrConnectWithoutAnnouncementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnnouncementsInput, UserUncheckedCreateWithoutAnnouncementsInput>
  }

  export type UserUpsertWithoutAnnouncementsInput = {
    update: XOR<UserUpdateWithoutAnnouncementsInput, UserUncheckedUpdateWithoutAnnouncementsInput>
    create: XOR<UserCreateWithoutAnnouncementsInput, UserUncheckedCreateWithoutAnnouncementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnnouncementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnnouncementsInput, UserUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type UserUpdateWithoutAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUpdateManyWithoutStudentNestedInput
  }

  export type UserUncheckedUpdateWithoutAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUncheckedUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type UserCreateWithoutMessagesSentInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput
    messagesReceived?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestCreateNestedManyWithoutStudentInput
  }

  export type UserUncheckedCreateWithoutMessagesSentInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryUncheckedCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportUncheckedCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type UserCreateOrConnectWithoutMessagesSentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
  }

  export type UserCreateWithoutMessagesReceivedInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestCreateNestedManyWithoutStudentInput
  }

  export type UserUncheckedCreateWithoutMessagesReceivedInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryUncheckedCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportUncheckedCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type UserCreateOrConnectWithoutMessagesReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesReceivedInput, UserUncheckedCreateWithoutMessagesReceivedInput>
  }

  export type MessageCreateWithoutChildMessagesInput = {
    id?: string
    subject: string
    content: string
    isRead?: boolean
    sentAt?: Date | string
    sender: UserCreateNestedOneWithoutMessagesSentInput
    recipient: UserCreateNestedOneWithoutMessagesReceivedInput
    parentMessage?: MessageCreateNestedOneWithoutChildMessagesInput
  }

  export type MessageUncheckedCreateWithoutChildMessagesInput = {
    id?: string
    senderId: string
    recipientId: string
    subject: string
    content: string
    isRead?: boolean
    sentAt?: Date | string
    parentMessageId?: string | null
  }

  export type MessageCreateOrConnectWithoutChildMessagesInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutChildMessagesInput, MessageUncheckedCreateWithoutChildMessagesInput>
  }

  export type MessageCreateWithoutParentMessageInput = {
    id?: string
    subject: string
    content: string
    isRead?: boolean
    sentAt?: Date | string
    sender: UserCreateNestedOneWithoutMessagesSentInput
    recipient: UserCreateNestedOneWithoutMessagesReceivedInput
    childMessages?: MessageCreateNestedManyWithoutParentMessageInput
  }

  export type MessageUncheckedCreateWithoutParentMessageInput = {
    id?: string
    senderId: string
    recipientId: string
    subject: string
    content: string
    isRead?: boolean
    sentAt?: Date | string
    childMessages?: MessageUncheckedCreateNestedManyWithoutParentMessageInput
  }

  export type MessageCreateOrConnectWithoutParentMessageInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutParentMessageInput, MessageUncheckedCreateWithoutParentMessageInput>
  }

  export type MessageCreateManyParentMessageInputEnvelope = {
    data: MessageCreateManyParentMessageInput | MessageCreateManyParentMessageInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutMessagesSentInput = {
    update: XOR<UserUpdateWithoutMessagesSentInput, UserUncheckedUpdateWithoutMessagesSentInput>
    create: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesSentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesSentInput, UserUncheckedUpdateWithoutMessagesSentInput>
  }

  export type UserUpdateWithoutMessagesSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput
    messagesReceived?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUpdateManyWithoutStudentNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUncheckedUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type UserUpsertWithoutMessagesReceivedInput = {
    update: XOR<UserUpdateWithoutMessagesReceivedInput, UserUncheckedUpdateWithoutMessagesReceivedInput>
    create: XOR<UserCreateWithoutMessagesReceivedInput, UserUncheckedCreateWithoutMessagesReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesReceivedInput, UserUncheckedUpdateWithoutMessagesReceivedInput>
  }

  export type UserUpdateWithoutMessagesReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUpdateManyWithoutStudentNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUncheckedUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type MessageUpsertWithoutChildMessagesInput = {
    update: XOR<MessageUpdateWithoutChildMessagesInput, MessageUncheckedUpdateWithoutChildMessagesInput>
    create: XOR<MessageCreateWithoutChildMessagesInput, MessageUncheckedCreateWithoutChildMessagesInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutChildMessagesInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutChildMessagesInput, MessageUncheckedUpdateWithoutChildMessagesInput>
  }

  export type MessageUpdateWithoutChildMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutMessagesSentNestedInput
    recipient?: UserUpdateOneRequiredWithoutMessagesReceivedNestedInput
    parentMessage?: MessageUpdateOneWithoutChildMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutChildMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentMessageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUpsertWithWhereUniqueWithoutParentMessageInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutParentMessageInput, MessageUncheckedUpdateWithoutParentMessageInput>
    create: XOR<MessageCreateWithoutParentMessageInput, MessageUncheckedCreateWithoutParentMessageInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutParentMessageInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutParentMessageInput, MessageUncheckedUpdateWithoutParentMessageInput>
  }

  export type MessageUpdateManyWithWhereWithoutParentMessageInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutParentMessageInput>
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutRecipientInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestCreateNestedManyWithoutStudentInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryUncheckedCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportUncheckedCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutRecipientNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUpdateManyWithoutStudentNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUncheckedUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type UserCreateWithoutDocumentsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documentPermissions?: DocumentPermissionCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestCreateNestedManyWithoutStudentInput
  }

  export type UserUncheckedCreateWithoutDocumentsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documentPermissions?: DocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryUncheckedCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportUncheckedCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type UserCreateOrConnectWithoutDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
  }

  export type ClassCreateWithoutDocumentsInput = {
    id?: string
    grade: GradeCreateNestedOneWithoutClassesInput
    classSection: ClassSectionCreateNestedOneWithoutClassesInput
    academicYear: AcademicYearCreateNestedOneWithoutClassesInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutClassInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutClassInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClassInput
    gradeCategories?: GradeCategoryCreateNestedManyWithoutClassInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutDocumentsInput = {
    id?: string
    gradeId: string
    classSectionId: string
    academicYearId: string
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutClassInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutClassInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClassInput
    gradeCategories?: GradeCategoryUncheckedCreateNestedManyWithoutClassInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutDocumentsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutDocumentsInput, ClassUncheckedCreateWithoutDocumentsInput>
  }

  export type SubjectCreateWithoutDocumentsInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    grade: GradeCreateNestedOneWithoutSubjectsInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutSubjectInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutSubjectInput
    gradeCategories?: GradeCategoryCreateNestedManyWithoutSubjectInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutSubjectInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutSubjectInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    gradeId: string
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutSubjectInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutSubjectInput
    gradeCategories?: GradeCategoryUncheckedCreateNestedManyWithoutSubjectInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutSubjectInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutSubjectInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutDocumentsInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutDocumentsInput, SubjectUncheckedCreateWithoutDocumentsInput>
  }

  export type DocumentPermissionCreateWithoutDocumentInput = {
    id?: string
    permissionType: string
    user: UserCreateNestedOneWithoutDocumentPermissionsInput
  }

  export type DocumentPermissionUncheckedCreateWithoutDocumentInput = {
    id?: string
    userId: string
    permissionType: string
  }

  export type DocumentPermissionCreateOrConnectWithoutDocumentInput = {
    where: DocumentPermissionWhereUniqueInput
    create: XOR<DocumentPermissionCreateWithoutDocumentInput, DocumentPermissionUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentPermissionCreateManyDocumentInputEnvelope = {
    data: DocumentPermissionCreateManyDocumentInput | DocumentPermissionCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutDocumentsInput = {
    update: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documentPermissions?: DocumentPermissionUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUpdateManyWithoutStudentNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documentPermissions?: DocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUncheckedUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ClassUpsertWithoutDocumentsInput = {
    update: XOR<ClassUpdateWithoutDocumentsInput, ClassUncheckedUpdateWithoutDocumentsInput>
    create: XOR<ClassCreateWithoutDocumentsInput, ClassUncheckedCreateWithoutDocumentsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutDocumentsInput, ClassUncheckedUpdateWithoutDocumentsInput>
  }

  export type ClassUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: GradeUpdateOneRequiredWithoutClassesNestedInput
    classSection?: ClassSectionUpdateOneRequiredWithoutClassesNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutClassesNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutClassNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutClassNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClassNestedInput
    gradeCategories?: GradeCategoryUpdateManyWithoutClassNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    classSectionId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutClassNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutClassNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClassNestedInput
    gradeCategories?: GradeCategoryUncheckedUpdateManyWithoutClassNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutClassNestedInput
  }

  export type SubjectUpsertWithoutDocumentsInput = {
    update: XOR<SubjectUpdateWithoutDocumentsInput, SubjectUncheckedUpdateWithoutDocumentsInput>
    create: XOR<SubjectCreateWithoutDocumentsInput, SubjectUncheckedCreateWithoutDocumentsInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutDocumentsInput, SubjectUncheckedUpdateWithoutDocumentsInput>
  }

  export type SubjectUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: GradeUpdateOneRequiredWithoutSubjectsNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutSubjectNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutSubjectNestedInput
    gradeCategories?: GradeCategoryUpdateManyWithoutSubjectNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutSubjectNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutSubjectNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: StringFieldUpdateOperationsInput | string
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutSubjectNestedInput
    gradeCategories?: GradeCategoryUncheckedUpdateManyWithoutSubjectNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutSubjectNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutSubjectNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type DocumentPermissionUpsertWithWhereUniqueWithoutDocumentInput = {
    where: DocumentPermissionWhereUniqueInput
    update: XOR<DocumentPermissionUpdateWithoutDocumentInput, DocumentPermissionUncheckedUpdateWithoutDocumentInput>
    create: XOR<DocumentPermissionCreateWithoutDocumentInput, DocumentPermissionUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentPermissionUpdateWithWhereUniqueWithoutDocumentInput = {
    where: DocumentPermissionWhereUniqueInput
    data: XOR<DocumentPermissionUpdateWithoutDocumentInput, DocumentPermissionUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentPermissionUpdateManyWithWhereWithoutDocumentInput = {
    where: DocumentPermissionScalarWhereInput
    data: XOR<DocumentPermissionUpdateManyMutationInput, DocumentPermissionUncheckedUpdateManyWithoutDocumentInput>
  }

  export type DocumentCreateWithoutPermissionsInput = {
    id?: string
    title: string
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    category: string
    uploadedAt?: Date | string
    uploadedBy: UserCreateNestedOneWithoutDocumentsInput
    class?: ClassCreateNestedOneWithoutDocumentsInput
    subject?: SubjectCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutPermissionsInput = {
    id?: string
    title: string
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedById: string
    category: string
    classId?: string | null
    subjectId?: string | null
    uploadedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutPermissionsInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutPermissionsInput, DocumentUncheckedCreateWithoutPermissionsInput>
  }

  export type UserCreateWithoutDocumentPermissionsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestCreateNestedManyWithoutStudentInput
  }

  export type UserUncheckedCreateWithoutDocumentPermissionsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryUncheckedCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportUncheckedCreateNestedManyWithoutStudentInput
    registrationRequests?: StudentRegistrationRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type UserCreateOrConnectWithoutDocumentPermissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentPermissionsInput, UserUncheckedCreateWithoutDocumentPermissionsInput>
  }

  export type DocumentUpsertWithoutPermissionsInput = {
    update: XOR<DocumentUpdateWithoutPermissionsInput, DocumentUncheckedUpdateWithoutPermissionsInput>
    create: XOR<DocumentCreateWithoutPermissionsInput, DocumentUncheckedCreateWithoutPermissionsInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutPermissionsInput, DocumentUncheckedUpdateWithoutPermissionsInput>
  }

  export type DocumentUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    class?: ClassUpdateOneWithoutDocumentsNestedInput
    subject?: SubjectUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutDocumentPermissionsInput = {
    update: XOR<UserUpdateWithoutDocumentPermissionsInput, UserUncheckedUpdateWithoutDocumentPermissionsInput>
    create: XOR<UserCreateWithoutDocumentPermissionsInput, UserUncheckedCreateWithoutDocumentPermissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentPermissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentPermissionsInput, UserUncheckedUpdateWithoutDocumentPermissionsInput>
  }

  export type UserUpdateWithoutDocumentPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUpdateManyWithoutStudentNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUncheckedUpdateManyWithoutStudentNestedInput
    registrationRequests?: StudentRegistrationRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type UserCreateWithoutRegistrationRequestsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutRecipientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportCreateNestedManyWithoutStudentInput
  }

  export type UserUncheckedCreateWithoutRegistrationRequestsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    gender?: string | null
    role: $Enums.Role
    phone?: string | null
    address?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutRecipientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUploadedByInput
    documentPermissions?: DocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    classSchedules?: ClassScheduleUncheckedCreateNestedManyWithoutTeacherInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedCreateNestedManyWithoutMarkedByInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesAsStudent?: GradeEntryUncheckedCreateNestedManyWithoutStudentInput
    gradeEntriesCreated?: GradeEntryUncheckedCreateNestedManyWithoutCreatedByInput
    gradeReports?: GradeReportUncheckedCreateNestedManyWithoutStudentInput
  }

  export type UserCreateOrConnectWithoutRegistrationRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRegistrationRequestsInput, UserUncheckedCreateWithoutRegistrationRequestsInput>
  }

  export type SemesterCreateWithoutRegistrationRequestsInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    registrationOpen?: boolean
    minAverage?: number | null
    noFailedSubjects?: boolean | null
    academicYear: AcademicYearCreateNestedOneWithoutSemestersInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutSemesterInput
    gradeReports?: GradeReportCreateNestedManyWithoutSemesterInput
    gradeEntries?: GradeEntryCreateNestedManyWithoutSemesterInput
    studentEnrollments?: StudentEnrollmentCreateNestedManyWithoutSemesterInput
  }

  export type SemesterUncheckedCreateWithoutRegistrationRequestsInput = {
    id?: string
    name: string
    academicYearId: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    registrationOpen?: boolean
    minAverage?: number | null
    noFailedSubjects?: boolean | null
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutSemesterInput
    gradeReports?: GradeReportUncheckedCreateNestedManyWithoutSemesterInput
    gradeEntries?: GradeEntryUncheckedCreateNestedManyWithoutSemesterInput
    studentEnrollments?: StudentEnrollmentUncheckedCreateNestedManyWithoutSemesterInput
  }

  export type SemesterCreateOrConnectWithoutRegistrationRequestsInput = {
    where: SemesterWhereUniqueInput
    create: XOR<SemesterCreateWithoutRegistrationRequestsInput, SemesterUncheckedCreateWithoutRegistrationRequestsInput>
  }

  export type UserUpsertWithoutRegistrationRequestsInput = {
    update: XOR<UserUpdateWithoutRegistrationRequestsInput, UserUncheckedUpdateWithoutRegistrationRequestsInput>
    create: XOR<UserCreateWithoutRegistrationRequestsInput, UserUncheckedCreateWithoutRegistrationRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRegistrationRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRegistrationRequestsInput, UserUncheckedUpdateWithoutRegistrationRequestsInput>
  }

  export type UserUpdateWithoutRegistrationRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUpdateManyWithoutStudentNestedInput
  }

  export type UserUncheckedUpdateWithoutRegistrationRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutRecipientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    documentPermissions?: DocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    attendanceRecordsAsStudent?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecordsMarked?: AttendanceRecordUncheckedUpdateManyWithoutMarkedByNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesAsStudent?: GradeEntryUncheckedUpdateManyWithoutStudentNestedInput
    gradeEntriesCreated?: GradeEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    gradeReports?: GradeReportUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SemesterUpsertWithoutRegistrationRequestsInput = {
    update: XOR<SemesterUpdateWithoutRegistrationRequestsInput, SemesterUncheckedUpdateWithoutRegistrationRequestsInput>
    create: XOR<SemesterCreateWithoutRegistrationRequestsInput, SemesterUncheckedCreateWithoutRegistrationRequestsInput>
    where?: SemesterWhereInput
  }

  export type SemesterUpdateToOneWithWhereWithoutRegistrationRequestsInput = {
    where?: SemesterWhereInput
    data: XOR<SemesterUpdateWithoutRegistrationRequestsInput, SemesterUncheckedUpdateWithoutRegistrationRequestsInput>
  }

  export type SemesterUpdateWithoutRegistrationRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    registrationOpen?: BoolFieldUpdateOperationsInput | boolean
    minAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    noFailedSubjects?: NullableBoolFieldUpdateOperationsInput | boolean | null
    academicYear?: AcademicYearUpdateOneRequiredWithoutSemestersNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutSemesterNestedInput
    gradeReports?: GradeReportUpdateManyWithoutSemesterNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutSemesterNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutSemesterNestedInput
  }

  export type SemesterUncheckedUpdateWithoutRegistrationRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    registrationOpen?: BoolFieldUpdateOperationsInput | boolean
    minAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    noFailedSubjects?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutSemesterNestedInput
    gradeReports?: GradeReportUncheckedUpdateManyWithoutSemesterNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutSemesterNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutSemesterNestedInput
  }

  export type UserSessionCreateManyUserInput = {
    sessionId?: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type AnnouncementCreateManyAuthorInput = {
    id?: string
    title: string
    content: string
    targetRoles?: AnnouncementCreatetargetRolesInput | string[]
    targetClasses?: AnnouncementCreatetargetClassesInput | string[]
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type MessageCreateManySenderInput = {
    id?: string
    recipientId: string
    subject: string
    content: string
    isRead?: boolean
    sentAt?: Date | string
    parentMessageId?: string | null
  }

  export type MessageCreateManyRecipientInput = {
    id?: string
    senderId: string
    subject: string
    content: string
    isRead?: boolean
    sentAt?: Date | string
    parentMessageId?: string | null
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    content: string
    type: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type DocumentCreateManyUploadedByInput = {
    id?: string
    title: string
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    category: string
    classId?: string | null
    subjectId?: string | null
    uploadedAt?: Date | string
  }

  export type DocumentPermissionCreateManyUserInput = {
    id?: string
    documentId: string
    permissionType: string
  }

  export type TeacherSubjectCreateManyTeacherInput = {
    id?: string
    subjectId: string
    classId: string
    academicYearId: string
  }

  export type StudentEnrollmentCreateManyStudentInput = {
    id?: string
    classId: string
    academicYearId: string
    semesterId?: string | null
    enrollmentDate?: Date | string
  }

  export type ClassScheduleCreateManyTeacherInput = {
    id?: string
    classId: string
    subjectId: string
    dayOfWeek: number
    startTime: string
    endTime: string
  }

  export type AttendanceRecordCreateManyStudentInput = {
    id?: string
    classId: string
    subjectId: string
    date: Date | string
    period?: number | null
    status: $Enums.AttendanceStatus
    markedById: string
    markedAt?: Date | string
    remarks?: string | null
  }

  export type AttendanceRecordCreateManyMarkedByInput = {
    id?: string
    studentId: string
    classId: string
    subjectId: string
    date: Date | string
    period?: number | null
    status: $Enums.AttendanceStatus
    markedAt?: Date | string
    remarks?: string | null
  }

  export type AttendanceSummaryCreateManyStudentInput = {
    id?: string
    subjectId: string
    semesterId: string
    totalClasses: number
    presentCount: number
    absentCount: number
    lateCount: number
  }

  export type GradeEntryCreateManyStudentInput = {
    id?: string
    subjectId: string
    categoryId: string
    classId: string
    academicYearId: string
    pointsEarned: number
    totalPoints: number
    date: Date | string
    semesterId: string
    createdById: string
  }

  export type GradeEntryCreateManyCreatedByInput = {
    id?: string
    studentId: string
    subjectId: string
    categoryId: string
    classId: string
    academicYearId: string
    pointsEarned: number
    totalPoints: number
    date: Date | string
    semesterId: string
  }

  export type GradeReportCreateManyStudentInput = {
    id?: string
    semesterId: string
    overallGpa: number
    generatedAt?: Date | string
  }

  export type StudentRegistrationRequestCreateManyStudentInput = {
    id?: string
    semesterId: string
    status?: string
    createdAt?: Date | string
    approvedAt?: Date | string | null
    adminId?: string | null
  }

  export type UserSessionUpdateWithoutUserInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateWithoutUserInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyWithoutUserInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetRoles?: AnnouncementUpdatetargetRolesInput | string[]
    targetClasses?: AnnouncementUpdatetargetClassesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnnouncementUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetRoles?: AnnouncementUpdatetargetRolesInput | string[]
    targetClasses?: AnnouncementUpdatetargetClassesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnnouncementUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    targetRoles?: AnnouncementUpdatetargetRolesInput | string[]
    targetClasses?: AnnouncementUpdatetargetClassesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: UserUpdateOneRequiredWithoutMessagesReceivedNestedInput
    parentMessage?: MessageUpdateOneWithoutChildMessagesNestedInput
    childMessages?: MessageUpdateManyWithoutParentMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    childMessages?: MessageUncheckedUpdateManyWithoutParentMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentMessageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutMessagesSentNestedInput
    parentMessage?: MessageUpdateOneWithoutChildMessagesNestedInput
    childMessages?: MessageUpdateManyWithoutParentMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    childMessages?: MessageUncheckedUpdateManyWithoutParentMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentMessageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutDocumentsNestedInput
    subject?: SubjectUpdateOneWithoutDocumentsNestedInput
    permissions?: DocumentPermissionUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: DocumentPermissionUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentPermissionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionType?: StringFieldUpdateOperationsInput | string
    document?: DocumentUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type DocumentPermissionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    permissionType?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentPermissionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    permissionType?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherSubjectUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: SubjectUpdateOneRequiredWithoutTeacherSubjectsNestedInput
    class?: ClassUpdateOneRequiredWithoutTeacherSubjectsNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutTeacherSubjectsNestedInput
  }

  export type TeacherSubjectUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherSubjectUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentEnrollmentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutStudentEnrollmentsNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutStudentEnrollmentsNestedInput
    semester?: SemesterUpdateOneWithoutStudentEnrollmentsNestedInput
  }

  export type StudentEnrollmentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    semesterId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentEnrollmentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    semesterId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassScheduleUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    class?: ClassUpdateOneRequiredWithoutClassSchedulesNestedInput
    subject?: SubjectUpdateOneRequiredWithoutClassSchedulesNestedInput
  }

  export type ClassScheduleUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
  }

  export type ClassScheduleUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
  }

  export type AttendanceRecordUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    markedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    class?: ClassUpdateOneRequiredWithoutAttendanceRecordsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutAttendanceRecordsNestedInput
    markedBy?: UserUpdateOneRequiredWithoutAttendanceRecordsMarkedNestedInput
  }

  export type AttendanceRecordUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    markedById?: StringFieldUpdateOperationsInput | string
    markedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    markedById?: StringFieldUpdateOperationsInput | string
    markedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceRecordUpdateWithoutMarkedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    markedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    student?: UserUpdateOneRequiredWithoutAttendanceRecordsAsStudentNestedInput
    class?: ClassUpdateOneRequiredWithoutAttendanceRecordsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutAttendanceRecordsNestedInput
  }

  export type AttendanceRecordUncheckedUpdateWithoutMarkedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    markedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutMarkedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    markedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceSummaryUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalClasses?: IntFieldUpdateOperationsInput | number
    presentCount?: IntFieldUpdateOperationsInput | number
    absentCount?: IntFieldUpdateOperationsInput | number
    lateCount?: IntFieldUpdateOperationsInput | number
    subject?: SubjectUpdateOneRequiredWithoutAttendanceSummariesNestedInput
    semester?: SemesterUpdateOneRequiredWithoutAttendanceSummariesNestedInput
  }

  export type AttendanceSummaryUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    totalClasses?: IntFieldUpdateOperationsInput | number
    presentCount?: IntFieldUpdateOperationsInput | number
    absentCount?: IntFieldUpdateOperationsInput | number
    lateCount?: IntFieldUpdateOperationsInput | number
  }

  export type AttendanceSummaryUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    totalClasses?: IntFieldUpdateOperationsInput | number
    presentCount?: IntFieldUpdateOperationsInput | number
    absentCount?: IntFieldUpdateOperationsInput | number
    lateCount?: IntFieldUpdateOperationsInput | number
  }

  export type GradeEntryUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointsEarned?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutGradeEntriesNestedInput
    category?: GradeCategoryUpdateOneRequiredWithoutGradeEntriesNestedInput
    class?: ClassUpdateOneRequiredWithoutGradeEntriesNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutGradeEntriesNestedInput
    semester?: SemesterUpdateOneRequiredWithoutGradeEntriesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutGradeEntriesCreatedNestedInput
  }

  export type GradeEntryUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    pointsEarned?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type GradeEntryUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    pointsEarned?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type GradeEntryUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointsEarned?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: UserUpdateOneRequiredWithoutGradeEntriesAsStudentNestedInput
    subject?: SubjectUpdateOneRequiredWithoutGradeEntriesNestedInput
    category?: GradeCategoryUpdateOneRequiredWithoutGradeEntriesNestedInput
    class?: ClassUpdateOneRequiredWithoutGradeEntriesNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutGradeEntriesNestedInput
    semester?: SemesterUpdateOneRequiredWithoutGradeEntriesNestedInput
  }

  export type GradeEntryUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    pointsEarned?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterId?: StringFieldUpdateOperationsInput | string
  }

  export type GradeEntryUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    pointsEarned?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterId?: StringFieldUpdateOperationsInput | string
  }

  export type GradeReportUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallGpa?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semester?: SemesterUpdateOneRequiredWithoutGradeReportsNestedInput
  }

  export type GradeReportUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    overallGpa?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeReportUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    overallGpa?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentRegistrationRequestUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: SemesterUpdateOneRequiredWithoutRegistrationRequestsNestedInput
  }

  export type StudentRegistrationRequestUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentRegistrationRequestUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SemesterCreateManyAcademicYearInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    isCurrent?: boolean
    registrationOpen?: boolean
    minAverage?: number | null
    noFailedSubjects?: boolean | null
  }

  export type ClassCreateManyAcademicYearInput = {
    id?: string
    gradeId: string
    classSectionId: string
  }

  export type TeacherSubjectCreateManyAcademicYearInput = {
    id?: string
    teacherId: string
    subjectId: string
    classId: string
  }

  export type StudentEnrollmentCreateManyAcademicYearInput = {
    id?: string
    studentId: string
    classId: string
    semesterId?: string | null
    enrollmentDate?: Date | string
  }

  export type GradeEntryCreateManyAcademicYearInput = {
    id?: string
    studentId: string
    subjectId: string
    categoryId: string
    classId: string
    pointsEarned: number
    totalPoints: number
    date: Date | string
    semesterId: string
    createdById: string
  }

  export type SemesterUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    registrationOpen?: BoolFieldUpdateOperationsInput | boolean
    minAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    noFailedSubjects?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutSemesterNestedInput
    gradeReports?: GradeReportUpdateManyWithoutSemesterNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutSemesterNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutSemesterNestedInput
    registrationRequests?: StudentRegistrationRequestUpdateManyWithoutSemesterNestedInput
  }

  export type SemesterUncheckedUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    registrationOpen?: BoolFieldUpdateOperationsInput | boolean
    minAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    noFailedSubjects?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutSemesterNestedInput
    gradeReports?: GradeReportUncheckedUpdateManyWithoutSemesterNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutSemesterNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutSemesterNestedInput
    registrationRequests?: StudentRegistrationRequestUncheckedUpdateManyWithoutSemesterNestedInput
  }

  export type SemesterUncheckedUpdateManyWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    registrationOpen?: BoolFieldUpdateOperationsInput | boolean
    minAverage?: NullableFloatFieldUpdateOperationsInput | number | null
    noFailedSubjects?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ClassUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: GradeUpdateOneRequiredWithoutClassesNestedInput
    classSection?: ClassSectionUpdateOneRequiredWithoutClassesNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutClassNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutClassNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClassNestedInput
    documents?: DocumentUpdateManyWithoutClassNestedInput
    gradeCategories?: GradeCategoryUpdateManyWithoutClassNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    classSectionId?: StringFieldUpdateOperationsInput | string
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutClassNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutClassNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClassNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClassNestedInput
    gradeCategories?: GradeCategoryUncheckedUpdateManyWithoutClassNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    classSectionId?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherSubjectUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacher?: UserUpdateOneRequiredWithoutTeacherSubjectsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutTeacherSubjectsNestedInput
    class?: ClassUpdateOneRequiredWithoutTeacherSubjectsNestedInput
  }

  export type TeacherSubjectUncheckedUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherSubjectUncheckedUpdateManyWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentEnrollmentUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: UserUpdateOneRequiredWithoutStudentEnrollmentsNestedInput
    class?: ClassUpdateOneRequiredWithoutStudentEnrollmentsNestedInput
    semester?: SemesterUpdateOneWithoutStudentEnrollmentsNestedInput
  }

  export type StudentEnrollmentUncheckedUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    semesterId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentEnrollmentUncheckedUpdateManyWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    semesterId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeEntryUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointsEarned?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: UserUpdateOneRequiredWithoutGradeEntriesAsStudentNestedInput
    subject?: SubjectUpdateOneRequiredWithoutGradeEntriesNestedInput
    category?: GradeCategoryUpdateOneRequiredWithoutGradeEntriesNestedInput
    class?: ClassUpdateOneRequiredWithoutGradeEntriesNestedInput
    semester?: SemesterUpdateOneRequiredWithoutGradeEntriesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutGradeEntriesCreatedNestedInput
  }

  export type GradeEntryUncheckedUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    pointsEarned?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type GradeEntryUncheckedUpdateManyWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    pointsEarned?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type AttendanceSummaryCreateManySemesterInput = {
    id?: string
    studentId: string
    subjectId: string
    totalClasses: number
    presentCount: number
    absentCount: number
    lateCount: number
  }

  export type GradeReportCreateManySemesterInput = {
    id?: string
    studentId: string
    overallGpa: number
    generatedAt?: Date | string
  }

  export type GradeEntryCreateManySemesterInput = {
    id?: string
    studentId: string
    subjectId: string
    categoryId: string
    classId: string
    academicYearId: string
    pointsEarned: number
    totalPoints: number
    date: Date | string
    createdById: string
  }

  export type StudentEnrollmentCreateManySemesterInput = {
    id?: string
    studentId: string
    classId: string
    academicYearId: string
    enrollmentDate?: Date | string
  }

  export type StudentRegistrationRequestCreateManySemesterInput = {
    id?: string
    studentId: string
    status?: string
    createdAt?: Date | string
    approvedAt?: Date | string | null
    adminId?: string | null
  }

  export type AttendanceSummaryUpdateWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalClasses?: IntFieldUpdateOperationsInput | number
    presentCount?: IntFieldUpdateOperationsInput | number
    absentCount?: IntFieldUpdateOperationsInput | number
    lateCount?: IntFieldUpdateOperationsInput | number
    student?: UserUpdateOneRequiredWithoutAttendanceSummariesNestedInput
    subject?: SubjectUpdateOneRequiredWithoutAttendanceSummariesNestedInput
  }

  export type AttendanceSummaryUncheckedUpdateWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    totalClasses?: IntFieldUpdateOperationsInput | number
    presentCount?: IntFieldUpdateOperationsInput | number
    absentCount?: IntFieldUpdateOperationsInput | number
    lateCount?: IntFieldUpdateOperationsInput | number
  }

  export type AttendanceSummaryUncheckedUpdateManyWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    totalClasses?: IntFieldUpdateOperationsInput | number
    presentCount?: IntFieldUpdateOperationsInput | number
    absentCount?: IntFieldUpdateOperationsInput | number
    lateCount?: IntFieldUpdateOperationsInput | number
  }

  export type GradeReportUpdateWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallGpa?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: UserUpdateOneRequiredWithoutGradeReportsNestedInput
  }

  export type GradeReportUncheckedUpdateWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    overallGpa?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeReportUncheckedUpdateManyWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    overallGpa?: FloatFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeEntryUpdateWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointsEarned?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: UserUpdateOneRequiredWithoutGradeEntriesAsStudentNestedInput
    subject?: SubjectUpdateOneRequiredWithoutGradeEntriesNestedInput
    category?: GradeCategoryUpdateOneRequiredWithoutGradeEntriesNestedInput
    class?: ClassUpdateOneRequiredWithoutGradeEntriesNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutGradeEntriesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutGradeEntriesCreatedNestedInput
  }

  export type GradeEntryUncheckedUpdateWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    pointsEarned?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type GradeEntryUncheckedUpdateManyWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    pointsEarned?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type StudentEnrollmentUpdateWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: UserUpdateOneRequiredWithoutStudentEnrollmentsNestedInput
    class?: ClassUpdateOneRequiredWithoutStudentEnrollmentsNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutStudentEnrollmentsNestedInput
  }

  export type StudentEnrollmentUncheckedUpdateWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentEnrollmentUncheckedUpdateManyWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentRegistrationRequestUpdateWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    student?: UserUpdateOneRequiredWithoutRegistrationRequestsNestedInput
  }

  export type StudentRegistrationRequestUncheckedUpdateWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentRegistrationRequestUncheckedUpdateManyWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassCreateManyClassSectionInput = {
    id?: string
    gradeId: string
    academicYearId: string
  }

  export type ClassUpdateWithoutClassSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: GradeUpdateOneRequiredWithoutClassesNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutClassesNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutClassNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutClassNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClassNestedInput
    documents?: DocumentUpdateManyWithoutClassNestedInput
    gradeCategories?: GradeCategoryUpdateManyWithoutClassNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutClassSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutClassNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutClassNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClassNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClassNestedInput
    gradeCategories?: GradeCategoryUncheckedUpdateManyWithoutClassNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutClassSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    gradeId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
  }

  export type ClassSectionCreateManyGradeInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectCreateManyGradeInput = {
    id?: string
    name: string
    code: string
    description?: string | null
  }

  export type ClassCreateManyGradeInput = {
    id?: string
    classSectionId: string
    academicYearId: string
  }

  export type ClassSectionUpdateWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUpdateManyWithoutClassSectionNestedInput
  }

  export type ClassSectionUncheckedUpdateWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUncheckedUpdateManyWithoutClassSectionNestedInput
  }

  export type ClassSectionUncheckedUpdateManyWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectUpdateWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    teacherSubjects?: TeacherSubjectUpdateManyWithoutSubjectNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutSubjectNestedInput
    gradeCategories?: GradeCategoryUpdateManyWithoutSubjectNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutSubjectNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutSubjectNestedInput
    documents?: DocumentUpdateManyWithoutSubjectNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutSubjectNestedInput
    gradeCategories?: GradeCategoryUncheckedUpdateManyWithoutSubjectNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutSubjectNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutSubjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutSubjectNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassUpdateWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    classSection?: ClassSectionUpdateOneRequiredWithoutClassesNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutClassesNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutClassNestedInput
    studentEnrollments?: StudentEnrollmentUpdateManyWithoutClassNestedInput
    classSchedules?: ClassScheduleUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClassNestedInput
    documents?: DocumentUpdateManyWithoutClassNestedInput
    gradeCategories?: GradeCategoryUpdateManyWithoutClassNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    classSectionId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutClassNestedInput
    studentEnrollments?: StudentEnrollmentUncheckedUpdateManyWithoutClassNestedInput
    classSchedules?: ClassScheduleUncheckedUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClassNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClassNestedInput
    gradeCategories?: GradeCategoryUncheckedUpdateManyWithoutClassNestedInput
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    classSectionId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherSubjectCreateManySubjectInput = {
    id?: string
    teacherId: string
    classId: string
    academicYearId: string
  }

  export type ClassScheduleCreateManySubjectInput = {
    id?: string
    classId: string
    teacherId: string
    dayOfWeek: number
    startTime: string
    endTime: string
  }

  export type GradeCategoryCreateManySubjectInput = {
    id?: string
    name: string
    weight: number
    classId: string
  }

  export type GradeEntryCreateManySubjectInput = {
    id?: string
    studentId: string
    categoryId: string
    classId: string
    academicYearId: string
    pointsEarned: number
    totalPoints: number
    date: Date | string
    semesterId: string
    createdById: string
  }

  export type AttendanceRecordCreateManySubjectInput = {
    id?: string
    studentId: string
    classId: string
    date: Date | string
    period?: number | null
    status: $Enums.AttendanceStatus
    markedById: string
    markedAt?: Date | string
    remarks?: string | null
  }

  export type DocumentCreateManySubjectInput = {
    id?: string
    title: string
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedById: string
    category: string
    classId?: string | null
    uploadedAt?: Date | string
  }

  export type AttendanceSummaryCreateManySubjectInput = {
    id?: string
    studentId: string
    semesterId: string
    totalClasses: number
    presentCount: number
    absentCount: number
    lateCount: number
  }

  export type TeacherSubjectUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacher?: UserUpdateOneRequiredWithoutTeacherSubjectsNestedInput
    class?: ClassUpdateOneRequiredWithoutTeacherSubjectsNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutTeacherSubjectsNestedInput
  }

  export type TeacherSubjectUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherSubjectUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
  }

  export type ClassScheduleUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    class?: ClassUpdateOneRequiredWithoutClassSchedulesNestedInput
    teacher?: UserUpdateOneRequiredWithoutClassSchedulesNestedInput
  }

  export type ClassScheduleUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
  }

  export type ClassScheduleUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
  }

  export type GradeCategoryUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    class?: ClassUpdateOneRequiredWithoutGradeCategoriesNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutCategoryNestedInput
  }

  export type GradeCategoryUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    classId?: StringFieldUpdateOperationsInput | string
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type GradeCategoryUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type GradeEntryUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointsEarned?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: UserUpdateOneRequiredWithoutGradeEntriesAsStudentNestedInput
    category?: GradeCategoryUpdateOneRequiredWithoutGradeEntriesNestedInput
    class?: ClassUpdateOneRequiredWithoutGradeEntriesNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutGradeEntriesNestedInput
    semester?: SemesterUpdateOneRequiredWithoutGradeEntriesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutGradeEntriesCreatedNestedInput
  }

  export type GradeEntryUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    pointsEarned?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type GradeEntryUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    pointsEarned?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type AttendanceRecordUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    markedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    student?: UserUpdateOneRequiredWithoutAttendanceRecordsAsStudentNestedInput
    class?: ClassUpdateOneRequiredWithoutAttendanceRecordsNestedInput
    markedBy?: UserUpdateOneRequiredWithoutAttendanceRecordsMarkedNestedInput
  }

  export type AttendanceRecordUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    markedById?: StringFieldUpdateOperationsInput | string
    markedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    markedById?: StringFieldUpdateOperationsInput | string
    markedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    class?: ClassUpdateOneWithoutDocumentsNestedInput
    permissions?: DocumentPermissionUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: DocumentPermissionUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceSummaryUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalClasses?: IntFieldUpdateOperationsInput | number
    presentCount?: IntFieldUpdateOperationsInput | number
    absentCount?: IntFieldUpdateOperationsInput | number
    lateCount?: IntFieldUpdateOperationsInput | number
    student?: UserUpdateOneRequiredWithoutAttendanceSummariesNestedInput
    semester?: SemesterUpdateOneRequiredWithoutAttendanceSummariesNestedInput
  }

  export type AttendanceSummaryUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    totalClasses?: IntFieldUpdateOperationsInput | number
    presentCount?: IntFieldUpdateOperationsInput | number
    absentCount?: IntFieldUpdateOperationsInput | number
    lateCount?: IntFieldUpdateOperationsInput | number
  }

  export type AttendanceSummaryUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    totalClasses?: IntFieldUpdateOperationsInput | number
    presentCount?: IntFieldUpdateOperationsInput | number
    absentCount?: IntFieldUpdateOperationsInput | number
    lateCount?: IntFieldUpdateOperationsInput | number
  }

  export type TeacherSubjectCreateManyClassInput = {
    id?: string
    teacherId: string
    subjectId: string
    academicYearId: string
  }

  export type StudentEnrollmentCreateManyClassInput = {
    id?: string
    studentId: string
    academicYearId: string
    semesterId?: string | null
    enrollmentDate?: Date | string
  }

  export type ClassScheduleCreateManyClassInput = {
    id?: string
    subjectId: string
    teacherId: string
    dayOfWeek: number
    startTime: string
    endTime: string
  }

  export type AttendanceRecordCreateManyClassInput = {
    id?: string
    studentId: string
    subjectId: string
    date: Date | string
    period?: number | null
    status: $Enums.AttendanceStatus
    markedById: string
    markedAt?: Date | string
    remarks?: string | null
  }

  export type DocumentCreateManyClassInput = {
    id?: string
    title: string
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedById: string
    category: string
    subjectId?: string | null
    uploadedAt?: Date | string
  }

  export type GradeCategoryCreateManyClassInput = {
    id?: string
    name: string
    weight: number
    subjectId: string
  }

  export type GradeEntryCreateManyClassInput = {
    id?: string
    studentId: string
    subjectId: string
    categoryId: string
    academicYearId: string
    pointsEarned: number
    totalPoints: number
    date: Date | string
    semesterId: string
    createdById: string
  }

  export type TeacherSubjectUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacher?: UserUpdateOneRequiredWithoutTeacherSubjectsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutTeacherSubjectsNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutTeacherSubjectsNestedInput
  }

  export type TeacherSubjectUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherSubjectUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentEnrollmentUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: UserUpdateOneRequiredWithoutStudentEnrollmentsNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutStudentEnrollmentsNestedInput
    semester?: SemesterUpdateOneWithoutStudentEnrollmentsNestedInput
  }

  export type StudentEnrollmentUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    semesterId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentEnrollmentUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    semesterId?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassScheduleUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: SubjectUpdateOneRequiredWithoutClassSchedulesNestedInput
    teacher?: UserUpdateOneRequiredWithoutClassSchedulesNestedInput
  }

  export type ClassScheduleUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
  }

  export type ClassScheduleUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
  }

  export type AttendanceRecordUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    markedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    student?: UserUpdateOneRequiredWithoutAttendanceRecordsAsStudentNestedInput
    subject?: SubjectUpdateOneRequiredWithoutAttendanceRecordsNestedInput
    markedBy?: UserUpdateOneRequiredWithoutAttendanceRecordsMarkedNestedInput
  }

  export type AttendanceRecordUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    markedById?: StringFieldUpdateOperationsInput | string
    markedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    markedById?: StringFieldUpdateOperationsInput | string
    markedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    subject?: SubjectUpdateOneWithoutDocumentsNestedInput
    permissions?: DocumentPermissionUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: DocumentPermissionUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeCategoryUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    subject?: SubjectUpdateOneRequiredWithoutGradeCategoriesNestedInput
    gradeEntries?: GradeEntryUpdateManyWithoutCategoryNestedInput
  }

  export type GradeCategoryUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    subjectId?: StringFieldUpdateOperationsInput | string
    gradeEntries?: GradeEntryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type GradeCategoryUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    subjectId?: StringFieldUpdateOperationsInput | string
  }

  export type GradeEntryUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointsEarned?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: UserUpdateOneRequiredWithoutGradeEntriesAsStudentNestedInput
    subject?: SubjectUpdateOneRequiredWithoutGradeEntriesNestedInput
    category?: GradeCategoryUpdateOneRequiredWithoutGradeEntriesNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutGradeEntriesNestedInput
    semester?: SemesterUpdateOneRequiredWithoutGradeEntriesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutGradeEntriesCreatedNestedInput
  }

  export type GradeEntryUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    pointsEarned?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type GradeEntryUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    pointsEarned?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type GradeEntryCreateManyCategoryInput = {
    id?: string
    studentId: string
    subjectId: string
    classId: string
    academicYearId: string
    pointsEarned: number
    totalPoints: number
    date: Date | string
    semesterId: string
    createdById: string
  }

  export type GradeEntryUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointsEarned?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: UserUpdateOneRequiredWithoutGradeEntriesAsStudentNestedInput
    subject?: SubjectUpdateOneRequiredWithoutGradeEntriesNestedInput
    class?: ClassUpdateOneRequiredWithoutGradeEntriesNestedInput
    academicYear?: AcademicYearUpdateOneRequiredWithoutGradeEntriesNestedInput
    semester?: SemesterUpdateOneRequiredWithoutGradeEntriesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutGradeEntriesCreatedNestedInput
  }

  export type GradeEntryUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    pointsEarned?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type GradeEntryUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYearId?: StringFieldUpdateOperationsInput | string
    pointsEarned?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type MessageCreateManyParentMessageInput = {
    id?: string
    senderId: string
    recipientId: string
    subject: string
    content: string
    isRead?: boolean
    sentAt?: Date | string
  }

  export type MessageUpdateWithoutParentMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutMessagesSentNestedInput
    recipient?: UserUpdateOneRequiredWithoutMessagesReceivedNestedInput
    childMessages?: MessageUpdateManyWithoutParentMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutParentMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childMessages?: MessageUncheckedUpdateManyWithoutParentMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutParentMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentPermissionCreateManyDocumentInput = {
    id?: string
    userId: string
    permissionType: string
  }

  export type DocumentPermissionUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionType?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutDocumentPermissionsNestedInput
  }

  export type DocumentPermissionUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissionType?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentPermissionUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissionType?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}